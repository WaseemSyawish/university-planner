"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/attendance";
exports.ids = ["pages/api/attendance"];
exports.modules = {

/***/ "(api-node)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fattendance&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cattendance.js&middlewareConfigBase64=e30%3D!":
/*!**************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fattendance&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cattendance.js&middlewareConfigBase64=e30%3D! ***!
  \**************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   handler: () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_api_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/api-utils */ \"(api-node)/./node_modules/next/dist/server/api-utils/index.js\");\n/* harmony import */ var next_dist_server_api_utils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_api_utils__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/route-kind */ \"(api-node)/./node_modules/next/dist/server/route-kind.js\");\n/* harmony import */ var next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/route-modules/pages-api/module.compiled */ \"(api-node)/./node_modules/next/dist/server/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api-node)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _pages_api_attendance_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pages\\api\\attendance.js */ \"(api-node)/./pages/api/attendance.js\");\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/dist/server/lib/trace/tracer */ \"(api-node)/./node_modules/next/dist/server/lib/trace/tracer.js\");\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/dist/server/lib/trace/constants */ \"(api-node)/./node_modules/next/dist/server/lib/trace/constants.js\");\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_6__);\n\n\n\n\n// Import the userland code.\n\n\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_3__.hoist)(_pages_api_attendance_js__WEBPACK_IMPORTED_MODULE_4__, 'default'));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_3__.hoist)(_pages_api_attendance_js__WEBPACK_IMPORTED_MODULE_4__, 'config');\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_2__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/attendance\",\n        pathname: \"/api/attendance\",\n        // The following aren't used in production.\n        bundlePath: '',\n        filename: ''\n    },\n    userland: _pages_api_attendance_js__WEBPACK_IMPORTED_MODULE_4__,\n    distDir: \".next\" || 0,\n    relativeProjectDir:  false || ''\n});\nasync function handler(req, res, ctx) {\n    let srcPage = \"/api/attendance\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (false) {}\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return;\n    }\n    const { query, params, prerenderManifest, routerServerContext } = prepareResult;\n    try {\n        const method = req.method || 'GET';\n        const tracer = (0,next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_5__.getTracer)();\n        const activeSpan = tracer.getActiveScopeSpan();\n        const onRequestError = routeModule.instrumentationOnRequestError.bind(routeModule);\n        const invokeRouteModule = async (span)=>routeModule.render(req, res, {\n                query: {\n                    ...query,\n                    ...params\n                },\n                params,\n                allowedRevalidateHeaderKeys: [],\n                multiZoneDraftMode: Boolean(false),\n                trustHostHeader: false,\n                // TODO: get this from from runtime env so manifest\n                // doesn't need to load\n                previewProps: prerenderManifest.preview,\n                propagateError: false,\n                dev: routeModule.isDev,\n                page: \"/api/attendance\",\n                internalRevalidate: routerServerContext == null ? void 0 : routerServerContext.revalidate,\n                onError: (...args)=>onRequestError(req, ...args)\n            }).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_6__.BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${req.url}`);\n                }\n            });\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await invokeRouteModule(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_6__.BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${req.url}`,\n                    kind: next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_5__.SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, invokeRouteModule));\n        }\n    } catch (err) {\n        // we re-throw in dev to show the error overlay\n        if (routeModule.isDev) {\n            throw err;\n        }\n        // this is technically an invariant as error handling\n        // should be done inside of api-resolver onError\n        (0,next_dist_server_api_utils__WEBPACK_IMPORTED_MODULE_0__.sendError)(res, 500, 'Internal Server Error');\n    } finally{\n        // We don't allow any waitUntil work in pages API routes currently\n        // so if callback is present return with resolved promise since no\n        // pending work\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n    }\n}\n\n//# sourceMappingURL=pages-api.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtcm91dGUtbG9hZGVyL2luZGV4LmpzP2tpbmQ9UEFHRVNfQVBJJnBhZ2U9JTJGYXBpJTJGYXR0ZW5kYW5jZSZwcmVmZXJyZWRSZWdpb249JmFic29sdXRlUGFnZVBhdGg9LiUyRnBhZ2VzJTVDYXBpJTVDYXR0ZW5kYW5jZS5qcyZtaWRkbGV3YXJlQ29uZmlnQmFzZTY0PWUzMCUzRCEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUQ7QUFDQztBQUN1QztBQUNyQztBQUMxRDtBQUN3RDtBQUNnQjtBQUNGO0FBQ3RFO0FBQ0EsaUVBQWUsd0VBQUssQ0FBQyxxREFBUSxZQUFZLEVBQUM7QUFDMUM7QUFDTyxlQUFlLHdFQUFLLENBQUMscURBQVE7QUFDcEM7QUFDQSx3QkFBd0IseUdBQW1CO0FBQzNDO0FBQ0EsY0FBYyxrRUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVk7QUFDWixhQUFhLE9BQW9DLElBQUksQ0FBRTtBQUN2RCx3QkFBd0IsTUFBdUM7QUFDL0QsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXFCLEVBQUUsRUFFMUI7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0RBQXdEO0FBQ3BFO0FBQ0E7QUFDQSx1QkFBdUIsNEVBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsNkNBQTZDLEVBQTZDO0FBQzFGLDRDQUE0QyxLQUF3QztBQUNwRixpQ0FBaUMsS0FBb0M7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGdGQUFjO0FBQy9FLCtEQUErRCx5Q0FBeUM7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUSxFQUFFLE1BQU07QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxrQkFBa0I7QUFDbEIsdUNBQXVDLFFBQVEsRUFBRSxRQUFRO0FBQ3pEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDZFQUE2RSxnRkFBYztBQUMzRixpQ0FBaUMsUUFBUSxFQUFFLFFBQVE7QUFDbkQsMEJBQTBCLHVFQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEscUVBQVM7QUFDakIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNlbmRFcnJvciB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2FwaS11dGlsc1wiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvcm91dGUta2luZFwiO1xuaW1wb3J0IHsgUGFnZXNBUElSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3JvdXRlLW1vZHVsZXMvcGFnZXMtYXBpL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgaG9pc3QgfSBmcm9tIFwibmV4dC9kaXN0L2J1aWxkL3RlbXBsYXRlcy9oZWxwZXJzXCI7XG4vLyBJbXBvcnQgdGhlIHVzZXJsYW5kIGNvZGUuXG5pbXBvcnQgKiBhcyB1c2VybGFuZCBmcm9tIFwiLi9wYWdlc1xcXFxhcGlcXFxcYXR0ZW5kYW5jZS5qc1wiO1xuaW1wb3J0IHsgZ2V0VHJhY2VyLCBTcGFuS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi90cmFjZS90cmFjZXJcIjtcbmltcG9ydCB7IEJhc2VTZXJ2ZXJTcGFuIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL3RyYWNlL2NvbnN0YW50c1wiO1xuLy8gUmUtZXhwb3J0IHRoZSBoYW5kbGVyIChzaG91bGQgYmUgdGhlIGRlZmF1bHQgZXhwb3J0KS5cbmV4cG9ydCBkZWZhdWx0IGhvaXN0KHVzZXJsYW5kLCAnZGVmYXVsdCcpO1xuLy8gUmUtZXhwb3J0IGNvbmZpZy5cbmV4cG9ydCBjb25zdCBjb25maWcgPSBob2lzdCh1c2VybGFuZCwgJ2NvbmZpZycpO1xuLy8gQ3JlYXRlIGFuZCBleHBvcnQgdGhlIHJvdXRlIG1vZHVsZSB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG5jb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBQYWdlc0FQSVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5QQUdFU19BUEksXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9hdHRlbmRhbmNlXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvYXR0ZW5kYW5jZVwiLFxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGFyZW4ndCB1c2VkIGluIHByb2R1Y3Rpb24uXG4gICAgICAgIGJ1bmRsZVBhdGg6ICcnLFxuICAgICAgICBmaWxlbmFtZTogJydcbiAgICB9LFxuICAgIHVzZXJsYW5kLFxuICAgIGRpc3REaXI6IHByb2Nlc3MuZW52Ll9fTkVYVF9SRUxBVElWRV9ESVNUX0RJUiB8fCAnJyxcbiAgICByZWxhdGl2ZVByb2plY3REaXI6IHByb2Nlc3MuZW52Ll9fTkVYVF9SRUxBVElWRV9QUk9KRUNUX0RJUiB8fCAnJ1xufSk7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaGFuZGxlcihyZXEsIHJlcywgY3R4KSB7XG4gICAgbGV0IHNyY1BhZ2UgPSBcIi9hcGkvYXR0ZW5kYW5jZVwiO1xuICAgIC8vIHR1cmJvcGFjayBkb2Vzbid0IG5vcm1hbGl6ZSBgL2luZGV4YCBpbiB0aGUgcGFnZSBuYW1lXG4gICAgLy8gc28gd2UgbmVlZCB0byB0byBwcm9jZXNzIGR5bmFtaWMgcm91dGVzIHByb3Blcmx5XG4gICAgLy8gVE9ETzogZml4IHR1cmJvcGFjayBwcm92aWRpbmcgZGlmZmVyaW5nIHZhbHVlIGZyb20gd2VicGFja1xuICAgIGlmIChwcm9jZXNzLmVudi5UVVJCT1BBQ0spIHtcbiAgICAgICAgc3JjUGFnZSA9IHNyY1BhZ2UucmVwbGFjZSgvXFwvaW5kZXgkLywgJycpIHx8ICcvJztcbiAgICB9XG4gICAgY29uc3QgcHJlcGFyZVJlc3VsdCA9IGF3YWl0IHJvdXRlTW9kdWxlLnByZXBhcmUocmVxLCByZXMsIHtcbiAgICAgICAgc3JjUGFnZVxuICAgIH0pO1xuICAgIGlmICghcHJlcGFyZVJlc3VsdCkge1xuICAgICAgICByZXMuc3RhdHVzQ29kZSA9IDQwMDtcbiAgICAgICAgcmVzLmVuZCgnQmFkIFJlcXVlc3QnKTtcbiAgICAgICAgY3R4LndhaXRVbnRpbCA9PSBudWxsID8gdm9pZCAwIDogY3R4LndhaXRVbnRpbC5jYWxsKGN0eCwgUHJvbWlzZS5yZXNvbHZlKCkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgcXVlcnksIHBhcmFtcywgcHJlcmVuZGVyTWFuaWZlc3QsIHJvdXRlclNlcnZlckNvbnRleHQgfSA9IHByZXBhcmVSZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gcmVxLm1ldGhvZCB8fCAnR0VUJztcbiAgICAgICAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKCk7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVNwYW4gPSB0cmFjZXIuZ2V0QWN0aXZlU2NvcGVTcGFuKCk7XG4gICAgICAgIGNvbnN0IG9uUmVxdWVzdEVycm9yID0gcm91dGVNb2R1bGUuaW5zdHJ1bWVudGF0aW9uT25SZXF1ZXN0RXJyb3IuYmluZChyb3V0ZU1vZHVsZSk7XG4gICAgICAgIGNvbnN0IGludm9rZVJvdXRlTW9kdWxlID0gYXN5bmMgKHNwYW4pPT5yb3V0ZU1vZHVsZS5yZW5kZXIocmVxLCByZXMsIHtcbiAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICAuLi5xdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgLi4ucGFyYW1zXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICAgICAgYWxsb3dlZFJldmFsaWRhdGVIZWFkZXJLZXlzOiBwcm9jZXNzLmVudi5fX05FWFRfQUxMT1dFRF9SRVZBTElEQVRFX0hFQURFUlMsXG4gICAgICAgICAgICAgICAgbXVsdGlab25lRHJhZnRNb2RlOiBCb29sZWFuKHByb2Nlc3MuZW52Ll9fTkVYVF9NVUxUSV9aT05FX0RSQUZUX01PREUpLFxuICAgICAgICAgICAgICAgIHRydXN0SG9zdEhlYWRlcjogcHJvY2Vzcy5lbnYuX19ORVhUX1RSVVNUX0hPU1RfSEVBREVSLFxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGdldCB0aGlzIGZyb20gZnJvbSBydW50aW1lIGVudiBzbyBtYW5pZmVzdFxuICAgICAgICAgICAgICAgIC8vIGRvZXNuJ3QgbmVlZCB0byBsb2FkXG4gICAgICAgICAgICAgICAgcHJldmlld1Byb3BzOiBwcmVyZW5kZXJNYW5pZmVzdC5wcmV2aWV3LFxuICAgICAgICAgICAgICAgIHByb3BhZ2F0ZUVycm9yOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkZXY6IHJvdXRlTW9kdWxlLmlzRGV2LFxuICAgICAgICAgICAgICAgIHBhZ2U6IFwiL2FwaS9hdHRlbmRhbmNlXCIsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxSZXZhbGlkYXRlOiByb3V0ZXJTZXJ2ZXJDb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiByb3V0ZXJTZXJ2ZXJDb250ZXh0LnJldmFsaWRhdGUsXG4gICAgICAgICAgICAgICAgb25FcnJvcjogKC4uLmFyZ3MpPT5vblJlcXVlc3RFcnJvcihyZXEsIC4uLmFyZ3MpXG4gICAgICAgICAgICB9KS5maW5hbGx5KCgpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFzcGFuKSByZXR1cm47XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHAuc3RhdHVzX2NvZGUnOiByZXMuc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgJ25leHQucnNjJzogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByb290U3BhbkF0dHJpYnV0ZXMgPSB0cmFjZXIuZ2V0Um9vdFNwYW5BdHRyaWJ1dGVzKCk7XG4gICAgICAgICAgICAgICAgLy8gV2Ugd2VyZSB1bmFibGUgdG8gZ2V0IGF0dHJpYnV0ZXMsIHByb2JhYmx5IE9URUwgaXMgbm90IGVuYWJsZWRcbiAgICAgICAgICAgICAgICBpZiAoIXJvb3RTcGFuQXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyb290U3BhbkF0dHJpYnV0ZXMuZ2V0KCduZXh0LnNwYW5fdHlwZScpICE9PSBCYXNlU2VydmVyU3Bhbi5oYW5kbGVSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5leHBlY3RlZCByb290IHNwYW4gdHlwZSAnJHtyb290U3BhbkF0dHJpYnV0ZXMuZ2V0KCduZXh0LnNwYW5fdHlwZScpfScuIFBsZWFzZSByZXBvcnQgdGhpcyBOZXh0LmpzIGlzc3VlIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qc2ApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlID0gcm9vdFNwYW5BdHRyaWJ1dGVzLmdldCgnbmV4dC5yb3V0ZScpO1xuICAgICAgICAgICAgICAgIGlmIChyb3V0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYCR7bWV0aG9kfSAke3JvdXRlfWA7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbmV4dC5yb3V0ZSc6IHJvdXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHAucm91dGUnOiByb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICduZXh0LnNwYW5fbmFtZSc6IG5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4udXBkYXRlTmFtZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzcGFuLnVwZGF0ZU5hbWUoYCR7bWV0aG9kfSAke3JlcS51cmx9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIC8vIFRPRE86IGFjdGl2ZVNwYW4gY29kZSBwYXRoIGlzIGZvciB3aGVuIHdyYXBwZWQgYnlcbiAgICAgICAgLy8gbmV4dC1zZXJ2ZXIgY2FuIGJlIHJlbW92ZWQgd2hlbiB0aGlzIGlzIG5vIGxvbmdlciB1c2VkXG4gICAgICAgIGlmIChhY3RpdmVTcGFuKSB7XG4gICAgICAgICAgICBhd2FpdCBpbnZva2VSb3V0ZU1vZHVsZShhY3RpdmVTcGFuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRyYWNlci53aXRoUHJvcGFnYXRlZENvbnRleHQocmVxLmhlYWRlcnMsICgpPT50cmFjZXIudHJhY2UoQmFzZVNlcnZlclNwYW4uaGFuZGxlUmVxdWVzdCwge1xuICAgICAgICAgICAgICAgICAgICBzcGFuTmFtZTogYCR7bWV0aG9kfSAke3JlcS51cmx9YCxcbiAgICAgICAgICAgICAgICAgICAga2luZDogU3BhbktpbmQuU0VSVkVSLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaHR0cC5tZXRob2QnOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaHR0cC50YXJnZXQnOiByZXEudXJsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBpbnZva2VSb3V0ZU1vZHVsZSkpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIHdlIHJlLXRocm93IGluIGRldiB0byBzaG93IHRoZSBlcnJvciBvdmVybGF5XG4gICAgICAgIGlmIChyb3V0ZU1vZHVsZS5pc0Rldikge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMgaXMgdGVjaG5pY2FsbHkgYW4gaW52YXJpYW50IGFzIGVycm9yIGhhbmRsaW5nXG4gICAgICAgIC8vIHNob3VsZCBiZSBkb25lIGluc2lkZSBvZiBhcGktcmVzb2x2ZXIgb25FcnJvclxuICAgICAgICBzZW5kRXJyb3IocmVzLCA1MDAsICdJbnRlcm5hbCBTZXJ2ZXIgRXJyb3InKTtcbiAgICB9IGZpbmFsbHl7XG4gICAgICAgIC8vIFdlIGRvbid0IGFsbG93IGFueSB3YWl0VW50aWwgd29yayBpbiBwYWdlcyBBUEkgcm91dGVzIGN1cnJlbnRseVxuICAgICAgICAvLyBzbyBpZiBjYWxsYmFjayBpcyBwcmVzZW50IHJldHVybiB3aXRoIHJlc29sdmVkIHByb21pc2Ugc2luY2Ugbm9cbiAgICAgICAgLy8gcGVuZGluZyB3b3JrXG4gICAgICAgIGN0eC53YWl0VW50aWwgPT0gbnVsbCA/IHZvaWQgMCA6IGN0eC53YWl0VW50aWwuY2FsbChjdHgsIFByb21pc2UucmVzb2x2ZSgpKTtcbiAgICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhZ2VzLWFwaS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api-node)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fattendance&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cattendance.js&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api-node)/./pages/api/attendance.js":
/*!*********************************!*\
  !*** ./pages/api/attendance.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var _prisma_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @prisma/client */ \"@prisma/client\");\n/* harmony import */ var _prisma_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_prisma_client__WEBPACK_IMPORTED_MODULE_0__);\n// Consolidated attendance API handler below.\n// Removed an earlier simplistic file-based handler to avoid duplicate default exports.\n\nlet prisma;\nlet prismaUsable = true;\nfunction initPrisma() {\n    if (prisma) return prisma;\n    try {\n        prisma = new _prisma_client__WEBPACK_IMPORTED_MODULE_0__.PrismaClient();\n        return prisma;\n    } catch (err) {\n        console.error('Prisma init error:', err);\n        prismaUsable = false;\n        return null;\n    }\n}\nfunction getPrisma() {\n    if (!prismaUsable) return null;\n    return prisma || initPrisma();\n}\nlet attendanceFallback;\nlet coursesFallback;\nasync function getAttendanceFallback() {\n    if (attendanceFallback) return attendanceFallback;\n    const mod = await __webpack_require__.e(/*! import() */ \"_api-node_lib_attendanceFallback_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../../lib/attendanceFallback.js */ \"(api-node)/./lib/attendanceFallback.js\", 23));\n    attendanceFallback = mod.default || mod;\n    return attendanceFallback;\n}\nasync function getCoursesFallback() {\n    if (coursesFallback) return coursesFallback;\n    const mod = await __webpack_require__.e(/*! import() */ \"_api-node_lib_coursesFallback_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../../lib/coursesFallback.js */ \"(api-node)/./lib/coursesFallback.js\", 23));\n    coursesFallback = mod.default || mod;\n    return coursesFallback;\n}\nfunction isPrismaEngineError(err) {\n    if (!err) return false;\n    const msg = err.message || '';\n    return msg.includes('Query Engine') || msg.includes('could not locate the Query Engine') || err.name === 'PrismaClientInitializationError';\n}\nasync function handler(req, res) {\n    const { method } = req;\n    try {\n        switch(method){\n            case 'GET':\n                return await handleGet(req, res);\n            case 'POST':\n                return await handlePost(req, res);\n            case 'PUT':\n                return await handlePut(req, res);\n            case 'DELETE':\n                return await handleDelete(req, res);\n            default:\n                res.setHeader('Allow', [\n                    'GET',\n                    'POST',\n                    'PUT',\n                    'DELETE'\n                ]);\n                return res.status(405).json({\n                    success: false,\n                    error: `Method ${method} not allowed`\n                });\n        }\n    } catch (error) {\n        console.error('API Error:', error);\n        return res.status(500).json({\n            success: false,\n            error: 'Internal server error',\n            details:  true ? error.message : 0\n        });\n    } finally{\n    // Intentionally do NOT disconnect the global Prisma client here. Disconnecting\n    // per-request causes connection churn and slower responses. The client is\n    // managed globally and should be disconnected only on process shutdown.\n    }\n}\n// GET /api/attendance - Fetch attendance sessions for a course\nasync function handleGet(req, res) {\n    const { courseId } = req.query;\n    if (!courseId) {\n        return res.status(400).json({\n            success: false,\n            error: 'courseId parameter is required'\n        });\n    }\n    // Resolve user from next-auth token only (required)\n    let effectiveUserId = null;\n    try {\n        const { getToken } = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! next-auth/jwt */ \"next-auth/jwt\", 23));\n        const token = await getToken({\n            req,\n            secret: process.env.NEXTAUTH_SECRET || 'dev-nextauth-secret'\n        });\n        effectiveUserId = token && token.userId ? token.userId : null;\n    } catch (e) {\n        console.warn('Failed to resolve token in attendance GET', e);\n    }\n    if (!effectiveUserId) {\n        return res.status(401).json({\n            success: false,\n            error: 'Not authenticated'\n        });\n    }\n    try {\n        // Verify the course belongs to the user (or resolve fallback)\n        const p = getPrisma();\n        let course;\n        if (!p) {\n            const fb = await getCoursesFallback();\n            course = fb.find(courseId);\n        } else {\n            try {\n                course = await p.course.findFirst({\n                    where: {\n                        id: courseId,\n                        user_id: effectiveUserId\n                    }\n                });\n            } catch (err) {\n                if (isPrismaEngineError(err)) {\n                    console.warn('Prisma engine not available during course find; using fallback');\n                    const fb = await getCoursesFallback();\n                    course = fb.find(courseId);\n                } else throw err;\n            }\n        }\n        if (!course) {\n            return res.status(404).json({\n                success: false,\n                error: 'Course not found or you do not have permission to access it'\n            });\n        }\n        // Fetch attendance sessions for the course (oldest first)\n        const p2 = getPrisma();\n        let sessions = [];\n        if (!p2) {\n            const fb = await getAttendanceFallback();\n            sessions = fb.list({\n                courseId,\n                userId: effectiveUserId\n            });\n        } else {\n            try {\n                sessions = await p2.attendanceSession.findMany({\n                    where: {\n                        course_id: courseId,\n                        user_id: effectiveUserId\n                    },\n                    orderBy: {\n                        date: 'asc'\n                    },\n                    include: {\n                        courses: {\n                            select: {\n                                name: true,\n                                code: true,\n                                color: true\n                            }\n                        }\n                    }\n                });\n            } catch (err) {\n                if (isPrismaEngineError(err)) {\n                    console.warn('Prisma engine not available during attendance findMany; using fallback');\n                    const fb = await getAttendanceFallback();\n                    sessions = fb.list({\n                        courseId,\n                        userId: effectiveUserId\n                    });\n                } else throw err;\n            }\n        }\n        const formattedSessions = sessions.map((session)=>({\n                id: session.id,\n                date: typeof session.date === 'string' ? session.date.split('T')[0] : session.date.toISOString().split('T')[0],\n                status: session.status,\n                points: session.points || 0,\n                notes: session.notes || '',\n                course: {\n                    name: session.courses ? session.courses.name : course.name,\n                    code: session.courses ? session.courses.code : course.code,\n                    color: session.courses ? session.courses.color : course.color\n                },\n                createdAt: session.created_at,\n                updatedAt: session.updated_at\n            }));\n        return res.status(200).json({\n            success: true,\n            sessions: formattedSessions,\n            total: formattedSessions.length,\n            course: {\n                id: course.id,\n                name: course.name,\n                code: course.code,\n                color: course.color\n            }\n        });\n    } catch (error) {\n        console.error('Error fetching attendance sessions:', error);\n        return res.status(500).json({\n            success: false,\n            error: 'Failed to fetch attendance sessions',\n            details:  true ? error.message : 0\n        });\n    }\n}\n// POST /api/attendance - Create a new attendance session\nasync function handlePost(req, res) {\n    const { date, status, points, courseId, notes } = req.body;\n    // Resolve user id from token (required)\n    let effectiveUserId = null;\n    try {\n        const { getToken } = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! next-auth/jwt */ \"next-auth/jwt\", 23));\n        const token = await getToken({\n            req,\n            secret: process.env.NEXTAUTH_SECRET || 'dev-nextauth-secret'\n        });\n        effectiveUserId = token && token.userId ? token.userId : null;\n    } catch (e) {\n        console.warn('Failed to resolve token in attendance POST', e);\n    }\n    if (!effectiveUserId) {\n        return res.status(401).json({\n            success: false,\n            error: 'Not authenticated'\n        });\n    }\n    if (!date || !status || !courseId) {\n        return res.status(400).json({\n            success: false,\n            error: 'Missing required fields: date, status, courseId'\n        });\n    }\n    if (!isValidStatus(status)) {\n        return res.status(400).json({\n            success: false,\n            error: 'Invalid status. Must be one of: PRESENT, ABSENT, LATE, HOLIDAY, EXCUSED'\n        });\n    }\n    try {\n        // Verify the course belongs to the user\n        const p = getPrisma();\n        let course;\n        if (!p) {\n            const fb = await getCoursesFallback();\n            course = fb.find(courseId);\n            if (course) {\n                if (!effectiveUserId || course.user_id !== effectiveUserId) effectiveUserId = course.user_id;\n            }\n        } else {\n            try {\n                course = await p.course.findFirst({\n                    where: {\n                        id: courseId,\n                        user_id: effectiveUserId\n                    }\n                });\n                if (!course) {\n                    // Do not fallback to other owners — enforce strict ownership\n                    return res.status(403).json({\n                        success: false,\n                        error: 'Not authorized to add attendance for this course'\n                    });\n                }\n            } catch (err) {\n                if (isPrismaEngineError(err)) {\n                    console.warn('Prisma engine not available during course find (POST); using fallback');\n                    const fb = await getCoursesFallback();\n                    course = fb.find(courseId);\n                    if (course) {\n                        if (!effectiveUserId || course.user_id !== effectiveUserId) effectiveUserId = course.user_id;\n                    }\n                } else throw err;\n            }\n        }\n        if (!course) {\n            return res.status(404).json({\n                success: false,\n                error: 'Course not found or you do not have permission to access it'\n            });\n        }\n        const sessionDate = new Date(date);\n        if (isNaN(sessionDate.getTime())) {\n            return res.status(400).json({\n                success: false,\n                error: 'Invalid date format'\n            });\n        }\n        // Check for duplicate session on the same date\n        // Check for duplicate session on the same date\n        const p2 = getPrisma();\n        let existingSession;\n        if (!p2) {\n            const fb = await getAttendanceFallback();\n            existingSession = fb.list({\n                courseId,\n                userId: effectiveUserId\n            }).find((s)=>s.date.split('T')[0] === sessionDate.toISOString().split('T')[0]);\n        } else {\n            try {\n                existingSession = await p2.attendanceSession.findFirst({\n                    where: {\n                        date: sessionDate,\n                        course_id: courseId,\n                        user_id: effectiveUserId\n                    }\n                });\n            } catch (err) {\n                if (isPrismaEngineError(err)) {\n                    console.warn('Prisma engine not available during duplicate check; using fallback');\n                    const fb = await getAttendanceFallback();\n                    existingSession = fb.list({\n                        courseId,\n                        userId: effectiveUserId\n                    }).find((s)=>s.date.split('T')[0] === sessionDate.toISOString().split('T')[0]);\n                } else throw err;\n            }\n        }\n        if (existingSession) return res.status(400).json({\n            success: false,\n            error: 'An attendance session already exists for this date and course'\n        });\n        // Calculate points based on status if not provided\n        const sessionPoints = points !== undefined ? parseInt(points) || 0 : getDefaultPoints(status);\n        // Create the attendance session\n        // Create the attendance session (Prisma or fallback)\n        const p3 = getPrisma();\n        let newSession;\n        if (!p3) {\n            const fb = await getAttendanceFallback();\n            newSession = fb.create({\n                date: sessionDate.toISOString(),\n                status,\n                points: sessionPoints,\n                notes,\n                userId: effectiveUserId,\n                courseId\n            });\n        } else {\n            try {\n                newSession = await p3.attendanceSession.create({\n                    data: {\n                        date: sessionDate,\n                        status: status.toUpperCase(),\n                        points: sessionPoints,\n                        notes: notes?.trim() || null,\n                        user_id: effectiveUserId,\n                        course_id: courseId\n                    },\n                    include: {\n                        courses: {\n                            select: {\n                                name: true,\n                                code: true,\n                                color: true\n                            }\n                        }\n                    }\n                });\n            } catch (err) {\n                if (isPrismaEngineError(err)) {\n                    console.warn('Prisma engine not available during attendance.create; using fallback');\n                    const fb = await getAttendanceFallback();\n                    newSession = fb.create({\n                        date: sessionDate.toISOString(),\n                        status,\n                        points: sessionPoints,\n                        notes,\n                        userId: effectiveUserId,\n                        courseId\n                    });\n                } else throw err;\n            }\n        }\n        const formattedSession = {\n            id: newSession.id,\n            date: typeof newSession.date === 'string' ? newSession.date.split('T')[0] : newSession.date.toISOString().split('T')[0],\n            status: newSession.status,\n            points: newSession.points || 0,\n            notes: newSession.notes || '',\n            course: {\n                name: newSession.courses ? newSession.courses.name : course.name,\n                code: newSession.courses ? newSession.courses.code : course.code,\n                color: newSession.courses ? newSession.courses.color : course.color\n            },\n            createdAt: newSession.created_at,\n            updatedAt: newSession.updated_at\n        };\n        return res.status(201).json({\n            success: true,\n            session: formattedSession,\n            message: 'Attendance session created successfully'\n        });\n    } catch (error) {\n        console.error('Error creating attendance session:', error);\n        if (error.code === 'P2002') {\n            return res.status(400).json({\n                success: false,\n                error: 'An attendance session already exists for this date and course'\n            });\n        }\n        return res.status(500).json({\n            success: false,\n            error: 'Failed to create attendance session',\n            details:  true ? error.message : 0\n        });\n    }\n}\n// PUT /api/attendance - Update an existing attendance session\n// Identity is resolved from next-auth token only; client must not supply userId\nasync function handlePut(req, res) {\n    const { id, date, status, points, notes } = req.body;\n    if (!id) {\n        return res.status(400).json({\n            success: false,\n            error: 'Session ID is required'\n        });\n    }\n    try {\n        // Resolve auth token to identify user and verify the session belongs to them\n        let tokenUserId = null;\n        try {\n            const { getToken } = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! next-auth/jwt */ \"next-auth/jwt\", 23));\n            const token = await getToken({\n                req,\n                secret: process.env.NEXTAUTH_SECRET || 'dev-nextauth-secret'\n            });\n            tokenUserId = token && token.userId ? token.userId : null;\n        } catch (e) {\n            console.warn('Failed to resolve token in attendance PUT', e);\n        }\n        if (!tokenUserId) return res.status(401).json({\n            success: false,\n            error: 'Not authenticated'\n        });\n        const p4 = getPrisma();\n        let existingSession;\n        if (!p4) {\n            const fb = await getAttendanceFallback();\n            existingSession = fb.find(id);\n            if (existingSession && existingSession.user_id !== tokenUserId) existingSession = null;\n            if (existingSession && !existingSession.courses) existingSession.courses = {\n                name: existingSession.course || null\n            };\n        } else {\n            try {\n                existingSession = await p4.attendanceSession.findFirst({\n                    where: {\n                        id: id,\n                        user_id: tokenUserId\n                    },\n                    include: {\n                        courses: true\n                    }\n                });\n            } catch (err) {\n                if (isPrismaEngineError(err)) {\n                    console.warn('Prisma engine not available during session find (PUT); using fallback');\n                    const fb = await getAttendanceFallback();\n                    existingSession = fb.find(id);\n                    if (existingSession && existingSession.user_id !== tokenUserId) existingSession = null;\n                    if (existingSession && !existingSession.courses) existingSession.courses = {\n                        name: existingSession.course || null\n                    };\n                } else throw err;\n            }\n        }\n        // Validate status if provided\n        if (status && !isValidStatus(status)) {\n            return res.status(400).json({\n                success: false,\n                error: 'Invalid status. Must be one of: PRESENT, ABSENT, LATE, HOLIDAY, EXCUSED'\n            });\n        }\n        // Prepare update data\n        const updateData = {};\n        if (date) {\n            const sessionDate = new Date(date);\n            if (isNaN(sessionDate.getTime())) {\n                return res.status(400).json({\n                    success: false,\n                    error: 'Invalid date format'\n                });\n            }\n            // Check for duplicate date (excluding current session)\n            const p5 = getPrisma();\n            let duplicateSession;\n            if (!p5) {\n                const fb = await getAttendanceFallback();\n                duplicateSession = fb.list({\n                    courseId: existingSession.course_id,\n                    userId: tokenUserId\n                }).find((s)=>s.date.split('T')[0] === sessionDate.toISOString().split('T')[0] && s.id !== id);\n            } else {\n                try {\n                    duplicateSession = await p5.attendanceSession.findFirst({\n                        where: {\n                            date: sessionDate,\n                            course_id: existingSession.course_id,\n                            user_id: tokenUserId,\n                            id: {\n                                not: id\n                            }\n                        }\n                    });\n                } catch (err) {\n                    if (isPrismaEngineError(err)) {\n                        console.warn('Prisma engine not available during duplicate check (PUT); using fallback');\n                        const fb = await getAttendanceFallback();\n                        duplicateSession = fb.list({\n                            courseId: existingSession.course_id,\n                            userId: tokenUserId\n                        }).find((s)=>s.date.split('T')[0] === sessionDate.toISOString().split('T')[0] && s.id !== id);\n                    } else throw err;\n                }\n            }\n            if (duplicateSession) return res.status(400).json({\n                success: false,\n                error: 'Another attendance session already exists for this date and course'\n            });\n            updateData.date = sessionDate;\n        }\n        if (status) {\n            updateData.status = status.toUpperCase();\n            // Auto-update points based on new status if points not explicitly provided\n            if (points === undefined) {\n                updateData.points = getDefaultPoints(status);\n            }\n        }\n        if (points !== undefined) {\n            updateData.points = parseInt(points) || 0;\n        }\n        if (notes !== undefined) {\n            updateData.notes = notes?.trim() || null;\n        }\n        updateData.updated_at = new Date();\n        // Update the session (Prisma or fallback)\n        const p6 = getPrisma();\n        let updatedSession;\n        if (!p6) {\n            const fb = await getAttendanceFallback();\n            updatedSession = fb.update(id, updateData);\n            if (updatedSession && !updatedSession.courses) updatedSession.courses = {\n                name: updatedSession.course || null\n            };\n        } else {\n            try {\n                updatedSession = await p6.attendanceSession.update({\n                    where: {\n                        id\n                    },\n                    data: updateData,\n                    include: {\n                        courses: {\n                            select: {\n                                name: true,\n                                code: true,\n                                color: true\n                            }\n                        }\n                    }\n                });\n            } catch (err) {\n                if (isPrismaEngineError(err)) {\n                    console.warn('Prisma engine not available during attendance.update; using fallback');\n                    const fb = await getAttendanceFallback();\n                    updatedSession = fb.update(id, updateData);\n                    if (updatedSession && !updatedSession.courses) updatedSession.courses = {\n                        name: updatedSession.course || null\n                    };\n                } else throw err;\n            }\n        }\n        const formattedSession = {\n            id: updatedSession.id,\n            date: updatedSession.date.toISOString().split('T')[0],\n            status: updatedSession.status,\n            points: updatedSession.points || 0,\n            notes: updatedSession.notes || '',\n            course: {\n                name: updatedSession.courses.name,\n                code: updatedSession.courses.code,\n                color: updatedSession.courses.color\n            },\n            createdAt: updatedSession.created_at,\n            updatedAt: updatedSession.updated_at\n        };\n        return res.status(200).json({\n            success: true,\n            session: formattedSession,\n            message: 'Attendance session updated successfully'\n        });\n    } catch (error) {\n        console.error('Error updating attendance session:', error);\n        if (error.code === 'P2002') {\n            return res.status(400).json({\n                success: false,\n                error: 'Another attendance session already exists for this date and course'\n            });\n        }\n        return res.status(500).json({\n            success: false,\n            error: 'Failed to update attendance session',\n            details:  true ? error.message : 0\n        });\n    }\n}\n// DELETE /api/attendance - Delete an attendance session\nasync function handleDelete(req, res) {\n    const { id } = req.body;\n    if (!id) {\n        return res.status(400).json({\n            success: false,\n            error: 'Session ID is required'\n        });\n    }\n    // Resolve user id from token (required)\n    let tokenUserId = null;\n    try {\n        const { getToken } = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! next-auth/jwt */ \"next-auth/jwt\", 23));\n        const token = await getToken({\n            req,\n            secret: process.env.NEXTAUTH_SECRET || 'dev-nextauth-secret'\n        });\n        tokenUserId = token && token.userId ? token.userId : null;\n    } catch (e) {\n        console.warn('Failed to resolve token in attendance DELETE', e);\n    }\n    if (!tokenUserId) return res.status(401).json({\n        success: false,\n        error: 'Not authenticated'\n    });\n    try {\n        // Verify the session belongs to the user and delete (Prisma or fallback)\n        const p7 = getPrisma();\n        let existingDelSession;\n        if (!p7) {\n            const fb = await getAttendanceFallback();\n            existingDelSession = fb.find(id);\n            if (existingDelSession && existingDelSession.user_id !== tokenUserId) existingDelSession = null;\n            if (!existingDelSession) return res.status(404).json({\n                success: false,\n                error: 'Attendance session not found or you do not have permission to delete it'\n            });\n            fb.delete(id);\n            return res.status(200).json({\n                success: true,\n                message: `Attendance session for ${existingDelSession.course || existingDelSession.course_id} deleted successfully`,\n                deletedSession: {\n                    id: existingDelSession.id,\n                    date: existingDelSession.date.split('T')[0],\n                    course: existingDelSession.course || existingDelSession.course_id\n                }\n            });\n        } else {\n            try {\n                existingDelSession = await p7.attendanceSession.findFirst({\n                    where: {\n                        id: id,\n                        user_id: tokenUserId\n                    },\n                    include: {\n                        courses: {\n                            select: {\n                                name: true\n                            }\n                        }\n                    }\n                });\n                if (!existingDelSession) return res.status(404).json({\n                    success: false,\n                    error: 'Attendance session not found or you do not have permission to delete it'\n                });\n                await p7.attendanceSession.delete({\n                    where: {\n                        id\n                    }\n                });\n                return res.status(200).json({\n                    success: true,\n                    message: `Attendance session for ${existingDelSession.courses.name} deleted successfully`,\n                    deletedSession: {\n                        id: existingDelSession.id,\n                        date: existingDelSession.date.toISOString().split('T')[0],\n                        course: existingDelSession.courses.name\n                    }\n                });\n            } catch (err) {\n                if (isPrismaEngineError(err)) {\n                    console.warn('Prisma engine not available during delete; using fallback');\n                    const fb = await getAttendanceFallback();\n                    existingDelSession = fb.find(id);\n                    if (!existingDelSession || existingDelSession.user_id !== tokenUserId) return res.status(404).json({\n                        success: false,\n                        error: 'Attendance session not found or you do not have permission to delete it'\n                    });\n                    fb.delete(id);\n                    return res.status(200).json({\n                        success: true,\n                        message: `Attendance session for ${existingDelSession.course || existingDelSession.course_id} deleted successfully`,\n                        deletedSession: {\n                            id: existingDelSession.id,\n                            date: existingDelSession.date.split('T')[0],\n                            course: existingDelSession.course || existingDelSession.course_id\n                        }\n                    });\n                }\n                throw err;\n            }\n        }\n    } catch (error) {\n        console.error('Error deleting attendance session:', error);\n        return res.status(500).json({\n            success: false,\n            error: 'Failed to delete attendance session',\n            details:  true ? error.message : 0\n        });\n    }\n}\n// Helper functions\nfunction isValidStatus(status) {\n    const validStatuses = [\n        'PRESENT',\n        'ABSENT',\n        'LATE',\n        'HOLIDAY',\n        'EXCUSED'\n    ];\n    return validStatuses.includes(status.toUpperCase());\n}\nfunction getDefaultPoints(status) {\n    switch(status.toUpperCase()){\n        case 'PRESENT':\n            return 2;\n        case 'EXCUSED':\n            return 1;\n        case 'LATE':\n            return 1; // idk what late is worth\n        case 'ABSENT':\n            return 0;\n        case 'HOLIDAY':\n            return 0;\n        default:\n            return 0;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNTLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTs0QkFBRXZCLFFBQVE2RCxtQkFBbUI3RCxNQUFNLElBQUk2RCxtQkFBbUJqRCxTQUFTO3dCQUFDO29CQUFFO2dCQUNsVTtnQkFDQSxNQUFNdEQ7WUFDUjtRQUNGO0lBQ0YsRUFBRSxPQUFPRSxPQUFPO1FBQ2RELFFBQVFDLEtBQUssQ0FBQyxzQ0FBc0NBO1FBQ3BELE9BQU9lLElBQUlPLE1BQU0sQ0FBQyxLQUFLQyxJQUFJLENBQUM7WUFDMUJDLFNBQVM7WUFDVHhCLE9BQU87WUFDUHlCLFNBQVNDLEtBQXNDLEdBQUcxQixNQUFNVSxPQUFPLEdBQUdpQixDQUFTQTtRQUM3RTtJQUNGO0FBQ0Y7QUFFQSxtQkFBbUI7QUFDbkIsU0FBUytDLGNBQWNwRCxNQUFNO0lBQzNCLE1BQU1rRixnQkFBZ0I7UUFBQztRQUFXO1FBQVU7UUFBUTtRQUFXO0tBQVU7SUFDekUsT0FBT0EsY0FBYzdGLFFBQVEsQ0FBQ1csT0FBT2tFLFdBQVc7QUFDbEQ7QUFFQSxTQUFTTCxpQkFBaUI3RCxNQUFNO0lBQzlCLE9BQVFBLE9BQU9rRSxXQUFXO1FBQ3hCLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTyxHQUFHLHlCQUF5QjtRQUNyQyxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1Q7WUFDRSxPQUFPO0lBQ1g7QUFDRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFx1bml2ZXJzaXR5LXBsYW5uZXJcXHBhZ2VzXFxhcGlcXGF0dGVuZGFuY2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29uc29saWRhdGVkIGF0dGVuZGFuY2UgQVBJIGhhbmRsZXIgYmVsb3cuXHJcbi8vIFJlbW92ZWQgYW4gZWFybGllciBzaW1wbGlzdGljIGZpbGUtYmFzZWQgaGFuZGxlciB0byBhdm9pZCBkdXBsaWNhdGUgZGVmYXVsdCBleHBvcnRzLlxyXG5pbXBvcnQgeyBQcmlzbWFDbGllbnQgfSBmcm9tICdAcHJpc21hL2NsaWVudCc7XHJcblxyXG5sZXQgcHJpc21hO1xyXG5sZXQgcHJpc21hVXNhYmxlID0gdHJ1ZTtcclxuXHJcbmZ1bmN0aW9uIGluaXRQcmlzbWEoKSB7XHJcbiAgaWYgKHByaXNtYSkgcmV0dXJuIHByaXNtYTtcclxuICB0cnkge1xyXG4gICAgcHJpc21hID0gbmV3IFByaXNtYUNsaWVudCgpO1xyXG4gICAgcmV0dXJuIHByaXNtYTtcclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ1ByaXNtYSBpbml0IGVycm9yOicsIGVycik7XHJcbiAgICBwcmlzbWFVc2FibGUgPSBmYWxzZTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0UHJpc21hKCkge1xyXG4gIGlmICghcHJpc21hVXNhYmxlKSByZXR1cm4gbnVsbDtcclxuICByZXR1cm4gcHJpc21hIHx8IGluaXRQcmlzbWEoKTtcclxufVxyXG5cclxubGV0IGF0dGVuZGFuY2VGYWxsYmFjaztcclxubGV0IGNvdXJzZXNGYWxsYmFjaztcclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGdldEF0dGVuZGFuY2VGYWxsYmFjaygpIHtcclxuICBpZiAoYXR0ZW5kYW5jZUZhbGxiYWNrKSByZXR1cm4gYXR0ZW5kYW5jZUZhbGxiYWNrO1xyXG4gIGNvbnN0IG1vZCA9IGF3YWl0IGltcG9ydCgnLi4vLi4vbGliL2F0dGVuZGFuY2VGYWxsYmFjay5qcycpO1xyXG4gIGF0dGVuZGFuY2VGYWxsYmFjayA9IG1vZC5kZWZhdWx0IHx8IG1vZDtcclxuICByZXR1cm4gYXR0ZW5kYW5jZUZhbGxiYWNrO1xyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBnZXRDb3Vyc2VzRmFsbGJhY2soKSB7XHJcbiAgaWYgKGNvdXJzZXNGYWxsYmFjaykgcmV0dXJuIGNvdXJzZXNGYWxsYmFjaztcclxuICBjb25zdCBtb2QgPSBhd2FpdCBpbXBvcnQoJy4uLy4uL2xpYi9jb3Vyc2VzRmFsbGJhY2suanMnKTtcclxuICBjb3Vyc2VzRmFsbGJhY2sgPSBtb2QuZGVmYXVsdCB8fCBtb2Q7XHJcbiAgcmV0dXJuIGNvdXJzZXNGYWxsYmFjaztcclxufVxyXG5cclxuZnVuY3Rpb24gaXNQcmlzbWFFbmdpbmVFcnJvcihlcnIpIHtcclxuICBpZiAoIWVycikgcmV0dXJuIGZhbHNlO1xyXG4gIGNvbnN0IG1zZyA9IGVyci5tZXNzYWdlIHx8ICcnO1xyXG4gIHJldHVybiBtc2cuaW5jbHVkZXMoJ1F1ZXJ5IEVuZ2luZScpIHx8IG1zZy5pbmNsdWRlcygnY291bGQgbm90IGxvY2F0ZSB0aGUgUXVlcnkgRW5naW5lJykgfHwgZXJyLm5hbWUgPT09ICdQcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yJztcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gaGFuZGxlcihyZXEsIHJlcykge1xyXG4gIGNvbnN0IHsgbWV0aG9kIH0gPSByZXE7XHJcblxyXG4gIHRyeSB7XHJcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xyXG4gICAgICBjYXNlICdHRVQnOlxyXG4gICAgICAgIHJldHVybiBhd2FpdCBoYW5kbGVHZXQocmVxLCByZXMpO1xyXG4gICAgICBjYXNlICdQT1NUJzpcclxuICAgICAgICByZXR1cm4gYXdhaXQgaGFuZGxlUG9zdChyZXEsIHJlcyk7XHJcbiAgICAgIGNhc2UgJ1BVVCc6XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IGhhbmRsZVB1dChyZXEsIHJlcyk7XHJcbiAgICAgIGNhc2UgJ0RFTEVURSc6XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IGhhbmRsZURlbGV0ZShyZXEsIHJlcyk7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmVzLnNldEhlYWRlcignQWxsb3cnLCBbJ0dFVCcsICdQT1NUJywgJ1BVVCcsICdERUxFVEUnXSk7XHJcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDA1KS5qc29uKHsgXHJcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSwgXHJcbiAgICAgICAgICBlcnJvcjogYE1ldGhvZCAke21ldGhvZH0gbm90IGFsbG93ZWRgIFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdBUEkgRXJyb3I6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoNTAwKS5qc29uKHsgXHJcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICBlcnJvcjogJ0ludGVybmFsIHNlcnZlciBlcnJvcicsXHJcbiAgICAgIGRldGFpbHM6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnID8gZXJyb3IubWVzc2FnZSA6IHVuZGVmaW5lZFxyXG4gICAgfSk7XHJcbiAgfSBmaW5hbGx5IHtcclxuICAgIC8vIEludGVudGlvbmFsbHkgZG8gTk9UIGRpc2Nvbm5lY3QgdGhlIGdsb2JhbCBQcmlzbWEgY2xpZW50IGhlcmUuIERpc2Nvbm5lY3RpbmdcclxuICAgIC8vIHBlci1yZXF1ZXN0IGNhdXNlcyBjb25uZWN0aW9uIGNodXJuIGFuZCBzbG93ZXIgcmVzcG9uc2VzLiBUaGUgY2xpZW50IGlzXHJcbiAgICAvLyBtYW5hZ2VkIGdsb2JhbGx5IGFuZCBzaG91bGQgYmUgZGlzY29ubmVjdGVkIG9ubHkgb24gcHJvY2VzcyBzaHV0ZG93bi5cclxuICB9XHJcbn1cclxuXHJcbi8vIEdFVCAvYXBpL2F0dGVuZGFuY2UgLSBGZXRjaCBhdHRlbmRhbmNlIHNlc3Npb25zIGZvciBhIGNvdXJzZVxyXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVHZXQocmVxLCByZXMpIHtcclxuICBjb25zdCB7IGNvdXJzZUlkIH0gPSByZXEucXVlcnk7XHJcblxyXG4gIGlmICghY291cnNlSWQpIHtcclxuICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7IFxyXG4gICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgZXJyb3I6ICdjb3Vyc2VJZCBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQnIFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBSZXNvbHZlIHVzZXIgZnJvbSBuZXh0LWF1dGggdG9rZW4gb25seSAocmVxdWlyZWQpXHJcbiAgbGV0IGVmZmVjdGl2ZVVzZXJJZCA9IG51bGw7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgZ2V0VG9rZW4gfSA9IGF3YWl0IGltcG9ydCgnbmV4dC1hdXRoL2p3dCcpO1xyXG4gICAgY29uc3QgdG9rZW4gPSBhd2FpdCBnZXRUb2tlbih7IHJlcSwgc2VjcmV0OiBwcm9jZXNzLmVudi5ORVhUQVVUSF9TRUNSRVQgfHwgJ2Rldi1uZXh0YXV0aC1zZWNyZXQnIH0pO1xyXG4gICAgZWZmZWN0aXZlVXNlcklkID0gdG9rZW4gJiYgdG9rZW4udXNlcklkID8gdG9rZW4udXNlcklkIDogbnVsbDtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byByZXNvbHZlIHRva2VuIGluIGF0dGVuZGFuY2UgR0VUJywgZSk7XHJcbiAgfVxyXG5cclxuICBpZiAoIWVmZmVjdGl2ZVVzZXJJZCkge1xyXG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAxKS5qc29uKHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnTm90IGF1dGhlbnRpY2F0ZWQnIH0pO1xyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIC8vIFZlcmlmeSB0aGUgY291cnNlIGJlbG9uZ3MgdG8gdGhlIHVzZXIgKG9yIHJlc29sdmUgZmFsbGJhY2spXHJcbiAgICBjb25zdCBwID0gZ2V0UHJpc21hKCk7XHJcbiAgICBsZXQgY291cnNlO1xyXG4gICAgaWYgKCFwKSB7XHJcbiAgICAgIGNvbnN0IGZiID0gYXdhaXQgZ2V0Q291cnNlc0ZhbGxiYWNrKCk7XHJcbiAgICAgIGNvdXJzZSA9IGZiLmZpbmQoY291cnNlSWQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb3Vyc2UgPSBhd2FpdCBwLmNvdXJzZS5maW5kRmlyc3QoeyB3aGVyZTogeyBpZDogY291cnNlSWQsIHVzZXJfaWQ6IGVmZmVjdGl2ZVVzZXJJZCB9IH0pO1xyXG4gICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBpZiAoaXNQcmlzbWFFbmdpbmVFcnJvcihlcnIpKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1ByaXNtYSBlbmdpbmUgbm90IGF2YWlsYWJsZSBkdXJpbmcgY291cnNlIGZpbmQ7IHVzaW5nIGZhbGxiYWNrJyk7XHJcbiAgICAgICAgICBjb25zdCBmYiA9IGF3YWl0IGdldENvdXJzZXNGYWxsYmFjaygpO1xyXG4gICAgICAgICAgY291cnNlID0gZmIuZmluZChjb3Vyc2VJZCk7XHJcbiAgICAgICAgfSBlbHNlIHRocm93IGVycjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICghY291cnNlKSB7XHJcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwNCkuanNvbih7IFxyXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgIGVycm9yOiAnQ291cnNlIG5vdCBmb3VuZCBvciB5b3UgZG8gbm90IGhhdmUgcGVybWlzc2lvbiB0byBhY2Nlc3MgaXQnIFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGZXRjaCBhdHRlbmRhbmNlIHNlc3Npb25zIGZvciB0aGUgY291cnNlIChvbGRlc3QgZmlyc3QpXHJcbiAgICBjb25zdCBwMiA9IGdldFByaXNtYSgpO1xyXG4gICAgbGV0IHNlc3Npb25zID0gW107XHJcbiAgICBpZiAoIXAyKSB7XHJcbiAgICAgIGNvbnN0IGZiID0gYXdhaXQgZ2V0QXR0ZW5kYW5jZUZhbGxiYWNrKCk7XHJcbiAgICAgIHNlc3Npb25zID0gZmIubGlzdCh7IGNvdXJzZUlkLCB1c2VySWQ6IGVmZmVjdGl2ZVVzZXJJZCB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgc2Vzc2lvbnMgPSBhd2FpdCBwMi5hdHRlbmRhbmNlU2Vzc2lvbi5maW5kTWFueSh7XHJcbiAgICB3aGVyZTogeyBjb3Vyc2VfaWQ6IGNvdXJzZUlkLCB1c2VyX2lkOiBlZmZlY3RpdmVVc2VySWQgfSxcclxuICAgICAgICAgIG9yZGVyQnk6IHsgZGF0ZTogJ2FzYycgfSxcclxuICAgICAgICAgIGluY2x1ZGU6IHsgY291cnNlczogeyBzZWxlY3Q6IHsgbmFtZTogdHJ1ZSwgY29kZTogdHJ1ZSwgY29sb3I6IHRydWUgfSB9IH1cclxuICAgICAgICB9KTtcclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgaWYgKGlzUHJpc21hRW5naW5lRXJyb3IoZXJyKSkge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKCdQcmlzbWEgZW5naW5lIG5vdCBhdmFpbGFibGUgZHVyaW5nIGF0dGVuZGFuY2UgZmluZE1hbnk7IHVzaW5nIGZhbGxiYWNrJyk7XHJcbiAgICAgICAgICBjb25zdCBmYiA9IGF3YWl0IGdldEF0dGVuZGFuY2VGYWxsYmFjaygpO1xyXG4gICAgICAgICAgc2Vzc2lvbnMgPSBmYi5saXN0KHsgY291cnNlSWQsIHVzZXJJZDogZWZmZWN0aXZlVXNlcklkIH0pO1xyXG4gICAgICAgIH0gZWxzZSB0aHJvdyBlcnI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBmb3JtYXR0ZWRTZXNzaW9ucyA9IHNlc3Npb25zLm1hcChzZXNzaW9uID0+ICh7XHJcbiAgICAgIGlkOiBzZXNzaW9uLmlkLFxyXG4gICAgICBkYXRlOiAodHlwZW9mIHNlc3Npb24uZGF0ZSA9PT0gJ3N0cmluZycgPyBzZXNzaW9uLmRhdGUuc3BsaXQoJ1QnKVswXSA6IHNlc3Npb24uZGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0pLFxyXG4gICAgICBzdGF0dXM6IHNlc3Npb24uc3RhdHVzLFxyXG4gICAgICBwb2ludHM6IHNlc3Npb24ucG9pbnRzIHx8IDAsXHJcbiAgICAgIG5vdGVzOiBzZXNzaW9uLm5vdGVzIHx8ICcnLFxyXG4gICAgICBjb3Vyc2U6IHtcclxuICAgICAgICBuYW1lOiBzZXNzaW9uLmNvdXJzZXMgPyBzZXNzaW9uLmNvdXJzZXMubmFtZSA6IGNvdXJzZS5uYW1lLFxyXG4gICAgICAgIGNvZGU6IHNlc3Npb24uY291cnNlcyA/IHNlc3Npb24uY291cnNlcy5jb2RlIDogY291cnNlLmNvZGUsXHJcbiAgICAgICAgY29sb3I6IHNlc3Npb24uY291cnNlcyA/IHNlc3Npb24uY291cnNlcy5jb2xvciA6IGNvdXJzZS5jb2xvclxyXG4gICAgICB9LFxyXG4gICAgICBjcmVhdGVkQXQ6IHNlc3Npb24uY3JlYXRlZF9hdCxcclxuICAgICAgdXBkYXRlZEF0OiBzZXNzaW9uLnVwZGF0ZWRfYXRcclxuICAgIH0pKTtcclxuXHJcbiAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oeyBzdWNjZXNzOiB0cnVlLCBzZXNzaW9uczogZm9ybWF0dGVkU2Vzc2lvbnMsIHRvdGFsOiBmb3JtYXR0ZWRTZXNzaW9ucy5sZW5ndGgsIGNvdXJzZTogeyBpZDogY291cnNlLmlkLCBuYW1lOiBjb3Vyc2UubmFtZSwgY29kZTogY291cnNlLmNvZGUsIGNvbG9yOiBjb3Vyc2UuY29sb3IgfSB9KTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgYXR0ZW5kYW5jZSBzZXNzaW9uczonLCBlcnJvcik7XHJcbiAgICByZXR1cm4gcmVzLnN0YXR1cyg1MDApLmpzb24oeyBcclxuICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgIGVycm9yOiAnRmFpbGVkIHRvIGZldGNoIGF0dGVuZGFuY2Ugc2Vzc2lvbnMnLFxyXG4gICAgICBkZXRhaWxzOiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IGVycm9yLm1lc3NhZ2UgOiB1bmRlZmluZWRcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuLy8gUE9TVCAvYXBpL2F0dGVuZGFuY2UgLSBDcmVhdGUgYSBuZXcgYXR0ZW5kYW5jZSBzZXNzaW9uXHJcbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVBvc3QocmVxLCByZXMpIHtcclxuICBjb25zdCB7IGRhdGUsIHN0YXR1cywgcG9pbnRzLCBjb3Vyc2VJZCwgbm90ZXMgfSA9IHJlcS5ib2R5O1xyXG5cclxuICAvLyBSZXNvbHZlIHVzZXIgaWQgZnJvbSB0b2tlbiAocmVxdWlyZWQpXHJcbiAgbGV0IGVmZmVjdGl2ZVVzZXJJZCA9IG51bGw7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgZ2V0VG9rZW4gfSA9IGF3YWl0IGltcG9ydCgnbmV4dC1hdXRoL2p3dCcpO1xyXG4gICAgY29uc3QgdG9rZW4gPSBhd2FpdCBnZXRUb2tlbih7IHJlcSwgc2VjcmV0OiBwcm9jZXNzLmVudi5ORVhUQVVUSF9TRUNSRVQgfHwgJ2Rldi1uZXh0YXV0aC1zZWNyZXQnIH0pO1xyXG4gICAgZWZmZWN0aXZlVXNlcklkID0gdG9rZW4gJiYgdG9rZW4udXNlcklkID8gdG9rZW4udXNlcklkIDogbnVsbDtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byByZXNvbHZlIHRva2VuIGluIGF0dGVuZGFuY2UgUE9TVCcsIGUpO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFlZmZlY3RpdmVVc2VySWQpIHtcclxuICAgIHJldHVybiByZXMuc3RhdHVzKDQwMSkuanNvbih7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ05vdCBhdXRoZW50aWNhdGVkJyB9KTtcclxuICB9XHJcblxyXG4gIGlmICghZGF0ZSB8fCAhc3RhdHVzIHx8ICFjb3Vyc2VJZCkge1xyXG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHsgXHJcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICBlcnJvcjogJ01pc3NpbmcgcmVxdWlyZWQgZmllbGRzOiBkYXRlLCBzdGF0dXMsIGNvdXJzZUlkJyBcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFpc1ZhbGlkU3RhdHVzKHN0YXR1cykpIHtcclxuICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7IFxyXG4gICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgZXJyb3I6ICdJbnZhbGlkIHN0YXR1cy4gTXVzdCBiZSBvbmUgb2Y6IFBSRVNFTlQsIEFCU0VOVCwgTEFURSwgSE9MSURBWSwgRVhDVVNFRCcgXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgLy8gVmVyaWZ5IHRoZSBjb3Vyc2UgYmVsb25ncyB0byB0aGUgdXNlclxyXG4gIGNvbnN0IHAgPSBnZXRQcmlzbWEoKTtcclxuICAgIGxldCBjb3Vyc2U7XHJcbiAgICBpZiAoIXApIHtcclxuICAgICAgY29uc3QgZmIgPSBhd2FpdCBnZXRDb3Vyc2VzRmFsbGJhY2soKTtcclxuICAgICAgY291cnNlID0gZmIuZmluZChjb3Vyc2VJZCk7XHJcbiAgICAgIGlmIChjb3Vyc2UpIHtcclxuICAgICAgICBpZiAoIWVmZmVjdGl2ZVVzZXJJZCB8fCBjb3Vyc2UudXNlcl9pZCAhPT0gZWZmZWN0aXZlVXNlcklkKSBlZmZlY3RpdmVVc2VySWQgPSBjb3Vyc2UudXNlcl9pZDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb3Vyc2UgPSBhd2FpdCBwLmNvdXJzZS5maW5kRmlyc3QoeyB3aGVyZTogeyBpZDogY291cnNlSWQsIHVzZXJfaWQ6IGVmZmVjdGl2ZVVzZXJJZCB9IH0pO1xyXG4gICAgICAgIGlmICghY291cnNlKSB7XHJcbiAgICAgICAgICAvLyBEbyBub3QgZmFsbGJhY2sgdG8gb3RoZXIgb3duZXJzIOKAlCBlbmZvcmNlIHN0cmljdCBvd25lcnNoaXBcclxuICAgICAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwMykuanNvbih7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ05vdCBhdXRob3JpemVkIHRvIGFkZCBhdHRlbmRhbmNlIGZvciB0aGlzIGNvdXJzZScgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBpZiAoaXNQcmlzbWFFbmdpbmVFcnJvcihlcnIpKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1ByaXNtYSBlbmdpbmUgbm90IGF2YWlsYWJsZSBkdXJpbmcgY291cnNlIGZpbmQgKFBPU1QpOyB1c2luZyBmYWxsYmFjaycpO1xyXG4gICAgICAgICAgY29uc3QgZmIgPSBhd2FpdCBnZXRDb3Vyc2VzRmFsbGJhY2soKTtcclxuICAgICAgICAgIGNvdXJzZSA9IGZiLmZpbmQoY291cnNlSWQpO1xyXG4gICAgICAgICAgaWYgKGNvdXJzZSkge1xyXG4gICAgICAgICAgICBpZiAoIWVmZmVjdGl2ZVVzZXJJZCB8fCBjb3Vyc2UudXNlcl9pZCAhPT0gZWZmZWN0aXZlVXNlcklkKSBlZmZlY3RpdmVVc2VySWQgPSBjb3Vyc2UudXNlcl9pZDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgdGhyb3cgZXJyO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFjb3Vyc2UpIHtcclxuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDA0KS5qc29uKHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnQ291cnNlIG5vdCBmb3VuZCBvciB5b3UgZG8gbm90IGhhdmUgcGVybWlzc2lvbiB0byBhY2Nlc3MgaXQnIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNlc3Npb25EYXRlID0gbmV3IERhdGUoZGF0ZSk7XHJcbiAgICBcclxuICAgIGlmIChpc05hTihzZXNzaW9uRGF0ZS5nZXRUaW1lKCkpKSB7XHJcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7IFxyXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgIGVycm9yOiAnSW52YWxpZCBkYXRlIGZvcm1hdCcgXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENoZWNrIGZvciBkdXBsaWNhdGUgc2Vzc2lvbiBvbiB0aGUgc2FtZSBkYXRlXHJcbiAgICAvLyBDaGVjayBmb3IgZHVwbGljYXRlIHNlc3Npb24gb24gdGhlIHNhbWUgZGF0ZVxyXG4gICAgY29uc3QgcDIgPSBnZXRQcmlzbWEoKTtcclxuICAgIGxldCBleGlzdGluZ1Nlc3Npb247XHJcbiAgICBpZiAoIXAyKSB7XHJcbiAgICAgIGNvbnN0IGZiID0gYXdhaXQgZ2V0QXR0ZW5kYW5jZUZhbGxiYWNrKCk7XHJcbiAgICAgIGV4aXN0aW5nU2Vzc2lvbiA9IGZiLmxpc3QoeyBjb3Vyc2VJZCwgdXNlcklkOiBlZmZlY3RpdmVVc2VySWQgfSkuZmluZChzID0+IHMuZGF0ZS5zcGxpdCgnVCcpWzBdID09PSBzZXNzaW9uRGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBleGlzdGluZ1Nlc3Npb24gPSBhd2FpdCBwMi5hdHRlbmRhbmNlU2Vzc2lvbi5maW5kRmlyc3QoeyB3aGVyZTogeyBkYXRlOiBzZXNzaW9uRGF0ZSwgY291cnNlX2lkOiBjb3Vyc2VJZCwgdXNlcl9pZDogZWZmZWN0aXZlVXNlcklkIH0gfSk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgIGlmIChpc1ByaXNtYUVuZ2luZUVycm9yKGVycikpIHtcclxuICAgICAgICAgIGNvbnNvbGUud2FybignUHJpc21hIGVuZ2luZSBub3QgYXZhaWxhYmxlIGR1cmluZyBkdXBsaWNhdGUgY2hlY2s7IHVzaW5nIGZhbGxiYWNrJyk7XHJcbiAgICAgICAgICBjb25zdCBmYiA9IGF3YWl0IGdldEF0dGVuZGFuY2VGYWxsYmFjaygpO1xyXG4gICAgICAgICAgZXhpc3RpbmdTZXNzaW9uID0gZmIubGlzdCh7IGNvdXJzZUlkLCB1c2VySWQ6IGVmZmVjdGl2ZVVzZXJJZCB9KS5maW5kKHMgPT4gcy5kYXRlLnNwbGl0KCdUJylbMF0gPT09IHNlc3Npb25EYXRlLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSk7XHJcbiAgICAgICAgfSBlbHNlIHRocm93IGVycjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChleGlzdGluZ1Nlc3Npb24pIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ0FuIGF0dGVuZGFuY2Ugc2Vzc2lvbiBhbHJlYWR5IGV4aXN0cyBmb3IgdGhpcyBkYXRlIGFuZCBjb3Vyc2UnIH0pO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBwb2ludHMgYmFzZWQgb24gc3RhdHVzIGlmIG5vdCBwcm92aWRlZFxyXG4gICAgY29uc3Qgc2Vzc2lvblBvaW50cyA9IHBvaW50cyAhPT0gdW5kZWZpbmVkID8gcGFyc2VJbnQocG9pbnRzKSB8fCAwIDogZ2V0RGVmYXVsdFBvaW50cyhzdGF0dXMpO1xyXG5cclxuICAgIC8vIENyZWF0ZSB0aGUgYXR0ZW5kYW5jZSBzZXNzaW9uXHJcbiAgICAvLyBDcmVhdGUgdGhlIGF0dGVuZGFuY2Ugc2Vzc2lvbiAoUHJpc21hIG9yIGZhbGxiYWNrKVxyXG4gICAgY29uc3QgcDMgPSBnZXRQcmlzbWEoKTtcclxuICAgIGxldCBuZXdTZXNzaW9uO1xyXG4gICAgaWYgKCFwMykge1xyXG4gICAgICBjb25zdCBmYiA9IGF3YWl0IGdldEF0dGVuZGFuY2VGYWxsYmFjaygpO1xyXG4gICAgICBuZXdTZXNzaW9uID0gZmIuY3JlYXRlKHsgZGF0ZTogc2Vzc2lvbkRhdGUudG9JU09TdHJpbmcoKSwgc3RhdHVzLCBwb2ludHM6IHNlc3Npb25Qb2ludHMsIG5vdGVzLCB1c2VySWQ6IGVmZmVjdGl2ZVVzZXJJZCwgY291cnNlSWQgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIG5ld1Nlc3Npb24gPSBhd2FpdCBwMy5hdHRlbmRhbmNlU2Vzc2lvbi5jcmVhdGUoeyBkYXRhOiB7IGRhdGU6IHNlc3Npb25EYXRlLCBzdGF0dXM6IHN0YXR1cy50b1VwcGVyQ2FzZSgpLCBwb2ludHM6IHNlc3Npb25Qb2ludHMsIG5vdGVzOiBub3Rlcz8udHJpbSgpIHx8IG51bGwsIHVzZXJfaWQ6IGVmZmVjdGl2ZVVzZXJJZCwgY291cnNlX2lkOiBjb3Vyc2VJZCB9LCBpbmNsdWRlOiB7IGNvdXJzZXM6IHsgc2VsZWN0OiB7IG5hbWU6IHRydWUsIGNvZGU6IHRydWUsIGNvbG9yOiB0cnVlIH0gfSB9IH0pO1xyXG4gICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBpZiAoaXNQcmlzbWFFbmdpbmVFcnJvcihlcnIpKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1ByaXNtYSBlbmdpbmUgbm90IGF2YWlsYWJsZSBkdXJpbmcgYXR0ZW5kYW5jZS5jcmVhdGU7IHVzaW5nIGZhbGxiYWNrJyk7XHJcbiAgICAgICAgICBjb25zdCBmYiA9IGF3YWl0IGdldEF0dGVuZGFuY2VGYWxsYmFjaygpO1xyXG4gICAgICAgICAgbmV3U2Vzc2lvbiA9IGZiLmNyZWF0ZSh7IGRhdGU6IHNlc3Npb25EYXRlLnRvSVNPU3RyaW5nKCksIHN0YXR1cywgcG9pbnRzOiBzZXNzaW9uUG9pbnRzLCBub3RlcywgdXNlcklkOiBlZmZlY3RpdmVVc2VySWQsIGNvdXJzZUlkIH0pO1xyXG4gICAgICAgIH0gZWxzZSB0aHJvdyBlcnI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBmb3JtYXR0ZWRTZXNzaW9uID0ge1xyXG4gICAgICBpZDogbmV3U2Vzc2lvbi5pZCxcclxuICAgICAgZGF0ZTogKHR5cGVvZiBuZXdTZXNzaW9uLmRhdGUgPT09ICdzdHJpbmcnID8gbmV3U2Vzc2lvbi5kYXRlLnNwbGl0KCdUJylbMF0gOiBuZXdTZXNzaW9uLmRhdGUudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdKSxcclxuICAgICAgc3RhdHVzOiBuZXdTZXNzaW9uLnN0YXR1cyxcclxuICAgICAgcG9pbnRzOiBuZXdTZXNzaW9uLnBvaW50cyB8fCAwLFxyXG4gICAgICBub3RlczogbmV3U2Vzc2lvbi5ub3RlcyB8fCAnJyxcclxuICAgICAgY291cnNlOiB7IG5hbWU6IG5ld1Nlc3Npb24uY291cnNlcyA/IG5ld1Nlc3Npb24uY291cnNlcy5uYW1lIDogY291cnNlLm5hbWUsIGNvZGU6IG5ld1Nlc3Npb24uY291cnNlcyA/IG5ld1Nlc3Npb24uY291cnNlcy5jb2RlIDogY291cnNlLmNvZGUsIGNvbG9yOiBuZXdTZXNzaW9uLmNvdXJzZXMgPyBuZXdTZXNzaW9uLmNvdXJzZXMuY29sb3IgOiBjb3Vyc2UuY29sb3IgfSxcclxuICAgICAgY3JlYXRlZEF0OiBuZXdTZXNzaW9uLmNyZWF0ZWRfYXQsXHJcbiAgICAgIHVwZGF0ZWRBdDogbmV3U2Vzc2lvbi51cGRhdGVkX2F0XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiByZXMuc3RhdHVzKDIwMSkuanNvbih7XHJcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgIHNlc3Npb246IGZvcm1hdHRlZFNlc3Npb24sXHJcbiAgICAgIG1lc3NhZ2U6ICdBdHRlbmRhbmNlIHNlc3Npb24gY3JlYXRlZCBzdWNjZXNzZnVsbHknXHJcbiAgICB9KTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgYXR0ZW5kYW5jZSBzZXNzaW9uOicsIGVycm9yKTtcclxuICAgIFxyXG4gICAgaWYgKGVycm9yLmNvZGUgPT09ICdQMjAwMicpIHtcclxuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHsgXHJcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgZXJyb3I6ICdBbiBhdHRlbmRhbmNlIHNlc3Npb24gYWxyZWFkeSBleGlzdHMgZm9yIHRoaXMgZGF0ZSBhbmQgY291cnNlJyBcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiByZXMuc3RhdHVzKDUwMCkuanNvbih7IFxyXG4gICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgZXJyb3I6ICdGYWlsZWQgdG8gY3JlYXRlIGF0dGVuZGFuY2Ugc2Vzc2lvbicsXHJcbiAgICAgIGRldGFpbHM6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnID8gZXJyb3IubWVzc2FnZSA6IHVuZGVmaW5lZFxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBQVVQgL2FwaS9hdHRlbmRhbmNlIC0gVXBkYXRlIGFuIGV4aXN0aW5nIGF0dGVuZGFuY2Ugc2Vzc2lvblxyXG4vLyBJZGVudGl0eSBpcyByZXNvbHZlZCBmcm9tIG5leHQtYXV0aCB0b2tlbiBvbmx5OyBjbGllbnQgbXVzdCBub3Qgc3VwcGx5IHVzZXJJZFxyXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVQdXQocmVxLCByZXMpIHtcclxuICBjb25zdCB7IGlkLCBkYXRlLCBzdGF0dXMsIHBvaW50cywgbm90ZXMgfSA9IHJlcS5ib2R5O1xyXG5cclxuICBpZiAoIWlkKSB7XHJcbiAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDApLmpzb24oeyBcclxuICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgIGVycm9yOiAnU2Vzc2lvbiBJRCBpcyByZXF1aXJlZCcgXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICAvLyBSZXNvbHZlIGF1dGggdG9rZW4gdG8gaWRlbnRpZnkgdXNlciBhbmQgdmVyaWZ5IHRoZSBzZXNzaW9uIGJlbG9uZ3MgdG8gdGhlbVxyXG4gICAgbGV0IHRva2VuVXNlcklkID0gbnVsbDtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHsgZ2V0VG9rZW4gfSA9IGF3YWl0IGltcG9ydCgnbmV4dC1hdXRoL2p3dCcpO1xyXG4gICAgICBjb25zdCB0b2tlbiA9IGF3YWl0IGdldFRva2VuKHsgcmVxLCBzZWNyZXQ6IHByb2Nlc3MuZW52Lk5FWFRBVVRIX1NFQ1JFVCB8fCAnZGV2LW5leHRhdXRoLXNlY3JldCcgfSk7XHJcbiAgICAgIHRva2VuVXNlcklkID0gdG9rZW4gJiYgdG9rZW4udXNlcklkID8gdG9rZW4udXNlcklkIDogbnVsbDtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gcmVzb2x2ZSB0b2tlbiBpbiBhdHRlbmRhbmNlIFBVVCcsIGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdG9rZW5Vc2VySWQpIHJldHVybiByZXMuc3RhdHVzKDQwMSkuanNvbih7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ05vdCBhdXRoZW50aWNhdGVkJyB9KTtcclxuXHJcbiAgICBjb25zdCBwNCA9IGdldFByaXNtYSgpO1xyXG4gICAgbGV0IGV4aXN0aW5nU2Vzc2lvbjtcclxuICAgIGlmICghcDQpIHtcclxuICAgICAgY29uc3QgZmIgPSBhd2FpdCBnZXRBdHRlbmRhbmNlRmFsbGJhY2soKTtcclxuICAgICAgZXhpc3RpbmdTZXNzaW9uID0gZmIuZmluZChpZCk7XHJcbiAgICAgIGlmIChleGlzdGluZ1Nlc3Npb24gJiYgZXhpc3RpbmdTZXNzaW9uLnVzZXJfaWQgIT09IHRva2VuVXNlcklkKSBleGlzdGluZ1Nlc3Npb24gPSBudWxsO1xyXG4gICAgICBpZiAoZXhpc3RpbmdTZXNzaW9uICYmICFleGlzdGluZ1Nlc3Npb24uY291cnNlcykgZXhpc3RpbmdTZXNzaW9uLmNvdXJzZXMgPSB7IG5hbWU6IGV4aXN0aW5nU2Vzc2lvbi5jb3Vyc2UgfHwgbnVsbCB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBleGlzdGluZ1Nlc3Npb24gPSBhd2FpdCBwNC5hdHRlbmRhbmNlU2Vzc2lvbi5maW5kRmlyc3QoeyB3aGVyZTogeyBpZDogaWQsIHVzZXJfaWQ6IHRva2VuVXNlcklkIH0sIGluY2x1ZGU6IHsgY291cnNlczogdHJ1ZSB9IH0pO1xyXG4gICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBpZiAoaXNQcmlzbWFFbmdpbmVFcnJvcihlcnIpKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1ByaXNtYSBlbmdpbmUgbm90IGF2YWlsYWJsZSBkdXJpbmcgc2Vzc2lvbiBmaW5kIChQVVQpOyB1c2luZyBmYWxsYmFjaycpO1xyXG4gICAgICAgICAgY29uc3QgZmIgPSBhd2FpdCBnZXRBdHRlbmRhbmNlRmFsbGJhY2soKTtcclxuICAgICAgICAgIGV4aXN0aW5nU2Vzc2lvbiA9IGZiLmZpbmQoaWQpO1xyXG4gICAgICAgICAgaWYgKGV4aXN0aW5nU2Vzc2lvbiAmJiBleGlzdGluZ1Nlc3Npb24udXNlcl9pZCAhPT0gdG9rZW5Vc2VySWQpIGV4aXN0aW5nU2Vzc2lvbiA9IG51bGw7XHJcbiAgICAgICAgICBpZiAoZXhpc3RpbmdTZXNzaW9uICYmICFleGlzdGluZ1Nlc3Npb24uY291cnNlcykgZXhpc3RpbmdTZXNzaW9uLmNvdXJzZXMgPSB7IG5hbWU6IGV4aXN0aW5nU2Vzc2lvbi5jb3Vyc2UgfHwgbnVsbCB9O1xyXG4gICAgICAgIH0gZWxzZSB0aHJvdyBlcnI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBWYWxpZGF0ZSBzdGF0dXMgaWYgcHJvdmlkZWRcclxuICAgIGlmIChzdGF0dXMgJiYgIWlzVmFsaWRTdGF0dXMoc3RhdHVzKSkge1xyXG4gICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDApLmpzb24oeyBcclxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICBlcnJvcjogJ0ludmFsaWQgc3RhdHVzLiBNdXN0IGJlIG9uZSBvZjogUFJFU0VOVCwgQUJTRU5ULCBMQVRFLCBIT0xJREFZLCBFWENVU0VEJyBcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHJlcGFyZSB1cGRhdGUgZGF0YVxyXG4gICAgY29uc3QgdXBkYXRlRGF0YSA9IHt9O1xyXG4gICAgXHJcbiAgICBpZiAoZGF0ZSkge1xyXG4gICAgICBjb25zdCBzZXNzaW9uRGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xyXG4gICAgICBpZiAoaXNOYU4oc2Vzc2lvbkRhdGUuZ2V0VGltZSgpKSkge1xyXG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7IFxyXG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgICBlcnJvcjogJ0ludmFsaWQgZGF0ZSBmb3JtYXQnIFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAgIC8vIENoZWNrIGZvciBkdXBsaWNhdGUgZGF0ZSAoZXhjbHVkaW5nIGN1cnJlbnQgc2Vzc2lvbilcclxuICAgICAgICBjb25zdCBwNSA9IGdldFByaXNtYSgpO1xyXG4gICAgICAgIGxldCBkdXBsaWNhdGVTZXNzaW9uO1xyXG4gICAgICAgIGlmICghcDUpIHtcclxuICAgICAgICAgIGNvbnN0IGZiID0gYXdhaXQgZ2V0QXR0ZW5kYW5jZUZhbGxiYWNrKCk7XHJcbiAgICAgICAgICBkdXBsaWNhdGVTZXNzaW9uID0gZmIubGlzdCh7IGNvdXJzZUlkOiBleGlzdGluZ1Nlc3Npb24uY291cnNlX2lkLCB1c2VySWQ6IHRva2VuVXNlcklkIH0pLmZpbmQocyA9PiBzLmRhdGUuc3BsaXQoJ1QnKVswXSA9PT0gc2Vzc2lvbkRhdGUudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdICYmIHMuaWQgIT09IGlkKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZHVwbGljYXRlU2Vzc2lvbiA9IGF3YWl0IHA1LmF0dGVuZGFuY2VTZXNzaW9uLmZpbmRGaXJzdCh7IHdoZXJlOiB7IGRhdGU6IHNlc3Npb25EYXRlLCBjb3Vyc2VfaWQ6IGV4aXN0aW5nU2Vzc2lvbi5jb3Vyc2VfaWQsIHVzZXJfaWQ6IHRva2VuVXNlcklkLCBpZDogeyBub3Q6IGlkIH0gfSB9KTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBpZiAoaXNQcmlzbWFFbmdpbmVFcnJvcihlcnIpKSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQcmlzbWEgZW5naW5lIG5vdCBhdmFpbGFibGUgZHVyaW5nIGR1cGxpY2F0ZSBjaGVjayAoUFVUKTsgdXNpbmcgZmFsbGJhY2snKTtcclxuICAgICAgICAgICAgICBjb25zdCBmYiA9IGF3YWl0IGdldEF0dGVuZGFuY2VGYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgIGR1cGxpY2F0ZVNlc3Npb24gPSBmYi5saXN0KHsgY291cnNlSWQ6IGV4aXN0aW5nU2Vzc2lvbi5jb3Vyc2VfaWQsIHVzZXJJZDogdG9rZW5Vc2VySWQgfSkuZmluZChzID0+IHMuZGF0ZS5zcGxpdCgnVCcpWzBdID09PSBzZXNzaW9uRGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0gJiYgcy5pZCAhPT0gaWQpO1xyXG4gICAgICAgICAgICB9IGVsc2UgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGR1cGxpY2F0ZVNlc3Npb24pIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ0Fub3RoZXIgYXR0ZW5kYW5jZSBzZXNzaW9uIGFscmVhZHkgZXhpc3RzIGZvciB0aGlzIGRhdGUgYW5kIGNvdXJzZScgfSk7XHJcbiAgICAgIFxyXG4gICAgICB1cGRhdGVEYXRhLmRhdGUgPSBzZXNzaW9uRGF0ZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHN0YXR1cykge1xyXG4gICAgICB1cGRhdGVEYXRhLnN0YXR1cyA9IHN0YXR1cy50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAvLyBBdXRvLXVwZGF0ZSBwb2ludHMgYmFzZWQgb24gbmV3IHN0YXR1cyBpZiBwb2ludHMgbm90IGV4cGxpY2l0bHkgcHJvdmlkZWRcclxuICAgICAgaWYgKHBvaW50cyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdXBkYXRlRGF0YS5wb2ludHMgPSBnZXREZWZhdWx0UG9pbnRzKHN0YXR1cyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHBvaW50cyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHVwZGF0ZURhdGEucG9pbnRzID0gcGFyc2VJbnQocG9pbnRzKSB8fCAwO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAobm90ZXMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB1cGRhdGVEYXRhLm5vdGVzID0gbm90ZXM/LnRyaW0oKSB8fCBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZURhdGEudXBkYXRlZF9hdCA9IG5ldyBEYXRlKCk7XHJcblxyXG4gICAgLy8gVXBkYXRlIHRoZSBzZXNzaW9uIChQcmlzbWEgb3IgZmFsbGJhY2spXHJcbiAgICBjb25zdCBwNiA9IGdldFByaXNtYSgpO1xyXG4gICAgbGV0IHVwZGF0ZWRTZXNzaW9uO1xyXG4gICAgaWYgKCFwNikge1xyXG4gICAgICBjb25zdCBmYiA9IGF3YWl0IGdldEF0dGVuZGFuY2VGYWxsYmFjaygpO1xyXG4gICAgICB1cGRhdGVkU2Vzc2lvbiA9IGZiLnVwZGF0ZShpZCwgdXBkYXRlRGF0YSk7XHJcbiAgICAgIGlmICh1cGRhdGVkU2Vzc2lvbiAmJiAhdXBkYXRlZFNlc3Npb24uY291cnNlcykgdXBkYXRlZFNlc3Npb24uY291cnNlcyA9IHsgbmFtZTogdXBkYXRlZFNlc3Npb24uY291cnNlIHx8IG51bGwgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgdXBkYXRlZFNlc3Npb24gPSBhd2FpdCBwNi5hdHRlbmRhbmNlU2Vzc2lvbi51cGRhdGUoeyB3aGVyZTogeyBpZCB9LCBkYXRhOiB1cGRhdGVEYXRhLCBpbmNsdWRlOiB7IGNvdXJzZXM6IHsgc2VsZWN0OiB7IG5hbWU6IHRydWUsIGNvZGU6IHRydWUsIGNvbG9yOiB0cnVlIH0gfSB9IH0pO1xyXG4gICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBpZiAoaXNQcmlzbWFFbmdpbmVFcnJvcihlcnIpKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1ByaXNtYSBlbmdpbmUgbm90IGF2YWlsYWJsZSBkdXJpbmcgYXR0ZW5kYW5jZS51cGRhdGU7IHVzaW5nIGZhbGxiYWNrJyk7XHJcbiAgICAgICAgICBjb25zdCBmYiA9IGF3YWl0IGdldEF0dGVuZGFuY2VGYWxsYmFjaygpO1xyXG4gICAgICAgICAgdXBkYXRlZFNlc3Npb24gPSBmYi51cGRhdGUoaWQsIHVwZGF0ZURhdGEpO1xyXG4gICAgICAgICAgaWYgKHVwZGF0ZWRTZXNzaW9uICYmICF1cGRhdGVkU2Vzc2lvbi5jb3Vyc2VzKSB1cGRhdGVkU2Vzc2lvbi5jb3Vyc2VzID0geyBuYW1lOiB1cGRhdGVkU2Vzc2lvbi5jb3Vyc2UgfHwgbnVsbCB9O1xyXG4gICAgICAgIH0gZWxzZSB0aHJvdyBlcnI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBmb3JtYXR0ZWRTZXNzaW9uID0ge1xyXG4gICAgICBpZDogdXBkYXRlZFNlc3Npb24uaWQsXHJcbiAgICAgIGRhdGU6IHVwZGF0ZWRTZXNzaW9uLmRhdGUudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdLFxyXG4gICAgICBzdGF0dXM6IHVwZGF0ZWRTZXNzaW9uLnN0YXR1cyxcclxuICAgICAgcG9pbnRzOiB1cGRhdGVkU2Vzc2lvbi5wb2ludHMgfHwgMCxcclxuICAgICAgbm90ZXM6IHVwZGF0ZWRTZXNzaW9uLm5vdGVzIHx8ICcnLFxyXG4gICAgICBjb3Vyc2U6IHtcclxuICAgICAgICBuYW1lOiB1cGRhdGVkU2Vzc2lvbi5jb3Vyc2VzLm5hbWUsXHJcbiAgICAgICAgY29kZTogdXBkYXRlZFNlc3Npb24uY291cnNlcy5jb2RlLFxyXG4gICAgICAgIGNvbG9yOiB1cGRhdGVkU2Vzc2lvbi5jb3Vyc2VzLmNvbG9yXHJcbiAgICAgIH0sXHJcbiAgICAgIGNyZWF0ZWRBdDogdXBkYXRlZFNlc3Npb24uY3JlYXRlZF9hdCxcclxuICAgICAgdXBkYXRlZEF0OiB1cGRhdGVkU2Vzc2lvbi51cGRhdGVkX2F0XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiByZXMuc3RhdHVzKDIwMCkuanNvbih7XHJcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgIHNlc3Npb246IGZvcm1hdHRlZFNlc3Npb24sXHJcbiAgICAgIG1lc3NhZ2U6ICdBdHRlbmRhbmNlIHNlc3Npb24gdXBkYXRlZCBzdWNjZXNzZnVsbHknXHJcbiAgICB9KTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgYXR0ZW5kYW5jZSBzZXNzaW9uOicsIGVycm9yKTtcclxuICAgIFxyXG4gICAgaWYgKGVycm9yLmNvZGUgPT09ICdQMjAwMicpIHtcclxuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHsgXHJcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgZXJyb3I6ICdBbm90aGVyIGF0dGVuZGFuY2Ugc2Vzc2lvbiBhbHJlYWR5IGV4aXN0cyBmb3IgdGhpcyBkYXRlIGFuZCBjb3Vyc2UnIFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoNTAwKS5qc29uKHsgXHJcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICBlcnJvcjogJ0ZhaWxlZCB0byB1cGRhdGUgYXR0ZW5kYW5jZSBzZXNzaW9uJyxcclxuICAgICAgZGV0YWlsczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyBlcnJvci5tZXNzYWdlIDogdW5kZWZpbmVkXHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbi8vIERFTEVURSAvYXBpL2F0dGVuZGFuY2UgLSBEZWxldGUgYW4gYXR0ZW5kYW5jZSBzZXNzaW9uXHJcbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZURlbGV0ZShyZXEsIHJlcykge1xyXG4gIGNvbnN0IHsgaWQgfSA9IHJlcS5ib2R5O1xyXG5cclxuICBpZiAoIWlkKSB7XHJcbiAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDApLmpzb24oeyBcclxuICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgIGVycm9yOiAnU2Vzc2lvbiBJRCBpcyByZXF1aXJlZCcgXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIFJlc29sdmUgdXNlciBpZCBmcm9tIHRva2VuIChyZXF1aXJlZClcclxuICBsZXQgdG9rZW5Vc2VySWQgPSBudWxsO1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IGdldFRva2VuIH0gPSBhd2FpdCBpbXBvcnQoJ25leHQtYXV0aC9qd3QnKTtcclxuICAgIGNvbnN0IHRva2VuID0gYXdhaXQgZ2V0VG9rZW4oeyByZXEsIHNlY3JldDogcHJvY2Vzcy5lbnYuTkVYVEFVVEhfU0VDUkVUIHx8ICdkZXYtbmV4dGF1dGgtc2VjcmV0JyB9KTtcclxuICAgIHRva2VuVXNlcklkID0gdG9rZW4gJiYgdG9rZW4udXNlcklkID8gdG9rZW4udXNlcklkIDogbnVsbDtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byByZXNvbHZlIHRva2VuIGluIGF0dGVuZGFuY2UgREVMRVRFJywgZSk7XHJcbiAgfVxyXG5cclxuICBpZiAoIXRva2VuVXNlcklkKSByZXR1cm4gcmVzLnN0YXR1cyg0MDEpLmpzb24oeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdOb3QgYXV0aGVudGljYXRlZCcgfSk7XHJcblxyXG4gIHRyeSB7XHJcbiAgICAvLyBWZXJpZnkgdGhlIHNlc3Npb24gYmVsb25ncyB0byB0aGUgdXNlciBhbmQgZGVsZXRlIChQcmlzbWEgb3IgZmFsbGJhY2spXHJcbiAgICBjb25zdCBwNyA9IGdldFByaXNtYSgpO1xyXG4gICAgbGV0IGV4aXN0aW5nRGVsU2Vzc2lvbjtcclxuICAgIGlmICghcDcpIHtcclxuICAgICAgY29uc3QgZmIgPSBhd2FpdCBnZXRBdHRlbmRhbmNlRmFsbGJhY2soKTtcclxuICAgICAgZXhpc3RpbmdEZWxTZXNzaW9uID0gZmIuZmluZChpZCk7XHJcbiAgICAgIGlmIChleGlzdGluZ0RlbFNlc3Npb24gJiYgZXhpc3RpbmdEZWxTZXNzaW9uLnVzZXJfaWQgIT09IHRva2VuVXNlcklkKSBleGlzdGluZ0RlbFNlc3Npb24gPSBudWxsO1xyXG4gICAgICBpZiAoIWV4aXN0aW5nRGVsU2Vzc2lvbikgcmV0dXJuIHJlcy5zdGF0dXMoNDA0KS5qc29uKHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnQXR0ZW5kYW5jZSBzZXNzaW9uIG5vdCBmb3VuZCBvciB5b3UgZG8gbm90IGhhdmUgcGVybWlzc2lvbiB0byBkZWxldGUgaXQnIH0pO1xyXG4gICAgICBmYi5kZWxldGUoaWQpO1xyXG4gICAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oeyBzdWNjZXNzOiB0cnVlLCBtZXNzYWdlOiBgQXR0ZW5kYW5jZSBzZXNzaW9uIGZvciAke2V4aXN0aW5nRGVsU2Vzc2lvbi5jb3Vyc2UgfHwgZXhpc3RpbmdEZWxTZXNzaW9uLmNvdXJzZV9pZH0gZGVsZXRlZCBzdWNjZXNzZnVsbHlgLCBkZWxldGVkU2Vzc2lvbjogeyBpZDogZXhpc3RpbmdEZWxTZXNzaW9uLmlkLCBkYXRlOiBleGlzdGluZ0RlbFNlc3Npb24uZGF0ZS5zcGxpdCgnVCcpWzBdLCBjb3Vyc2U6IGV4aXN0aW5nRGVsU2Vzc2lvbi5jb3Vyc2UgfHwgZXhpc3RpbmdEZWxTZXNzaW9uLmNvdXJzZV9pZCB9IH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBleGlzdGluZ0RlbFNlc3Npb24gPSBhd2FpdCBwNy5hdHRlbmRhbmNlU2Vzc2lvbi5maW5kRmlyc3QoeyB3aGVyZTogeyBpZDogaWQsIHVzZXJfaWQ6IHRva2VuVXNlcklkIH0sIGluY2x1ZGU6IHsgY291cnNlczogeyBzZWxlY3Q6IHsgbmFtZTogdHJ1ZSB9IH0gfSB9KTtcclxuICAgICAgICBpZiAoIWV4aXN0aW5nRGVsU2Vzc2lvbikgcmV0dXJuIHJlcy5zdGF0dXMoNDA0KS5qc29uKHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnQXR0ZW5kYW5jZSBzZXNzaW9uIG5vdCBmb3VuZCBvciB5b3UgZG8gbm90IGhhdmUgcGVybWlzc2lvbiB0byBkZWxldGUgaXQnIH0pO1xyXG4gICAgICAgIGF3YWl0IHA3LmF0dGVuZGFuY2VTZXNzaW9uLmRlbGV0ZSh7IHdoZXJlOiB7IGlkIH0gfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoMjAwKS5qc29uKHsgc3VjY2VzczogdHJ1ZSwgbWVzc2FnZTogYEF0dGVuZGFuY2Ugc2Vzc2lvbiBmb3IgJHtleGlzdGluZ0RlbFNlc3Npb24uY291cnNlcy5uYW1lfSBkZWxldGVkIHN1Y2Nlc3NmdWxseWAsIGRlbGV0ZWRTZXNzaW9uOiB7IGlkOiBleGlzdGluZ0RlbFNlc3Npb24uaWQsIGRhdGU6IGV4aXN0aW5nRGVsU2Vzc2lvbi5kYXRlLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSwgY291cnNlOiBleGlzdGluZ0RlbFNlc3Npb24uY291cnNlcy5uYW1lIH0gfSk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgIGlmIChpc1ByaXNtYUVuZ2luZUVycm9yKGVycikpIHtcclxuICAgICAgICAgIGNvbnNvbGUud2FybignUHJpc21hIGVuZ2luZSBub3QgYXZhaWxhYmxlIGR1cmluZyBkZWxldGU7IHVzaW5nIGZhbGxiYWNrJyk7XHJcbiAgICAgICAgICBjb25zdCBmYiA9IGF3YWl0IGdldEF0dGVuZGFuY2VGYWxsYmFjaygpO1xyXG4gICAgICAgICAgZXhpc3RpbmdEZWxTZXNzaW9uID0gZmIuZmluZChpZCk7XHJcbiAgICAgICAgICBpZiAoIWV4aXN0aW5nRGVsU2Vzc2lvbiB8fCBleGlzdGluZ0RlbFNlc3Npb24udXNlcl9pZCAhPT0gdG9rZW5Vc2VySWQpIHJldHVybiByZXMuc3RhdHVzKDQwNCkuanNvbih7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ0F0dGVuZGFuY2Ugc2Vzc2lvbiBub3QgZm91bmQgb3IgeW91IGRvIG5vdCBoYXZlIHBlcm1pc3Npb24gdG8gZGVsZXRlIGl0JyB9KTtcclxuICAgICAgICAgIGZiLmRlbGV0ZShpZCk7XHJcbiAgICAgICAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oeyBzdWNjZXNzOiB0cnVlLCBtZXNzYWdlOiBgQXR0ZW5kYW5jZSBzZXNzaW9uIGZvciAke2V4aXN0aW5nRGVsU2Vzc2lvbi5jb3Vyc2UgfHwgZXhpc3RpbmdEZWxTZXNzaW9uLmNvdXJzZV9pZH0gZGVsZXRlZCBzdWNjZXNzZnVsbHlgLCBkZWxldGVkU2Vzc2lvbjogeyBpZDogZXhpc3RpbmdEZWxTZXNzaW9uLmlkLCBkYXRlOiBleGlzdGluZ0RlbFNlc3Npb24uZGF0ZS5zcGxpdCgnVCcpWzBdLCBjb3Vyc2U6IGV4aXN0aW5nRGVsU2Vzc2lvbi5jb3Vyc2UgfHwgZXhpc3RpbmdEZWxTZXNzaW9uLmNvdXJzZV9pZCB9IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgYXR0ZW5kYW5jZSBzZXNzaW9uOicsIGVycm9yKTtcclxuICAgIHJldHVybiByZXMuc3RhdHVzKDUwMCkuanNvbih7IFxyXG4gICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgZXJyb3I6ICdGYWlsZWQgdG8gZGVsZXRlIGF0dGVuZGFuY2Ugc2Vzc2lvbicsXHJcbiAgICAgIGRldGFpbHM6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnID8gZXJyb3IubWVzc2FnZSA6IHVuZGVmaW5lZFxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBIZWxwZXIgZnVuY3Rpb25zXHJcbmZ1bmN0aW9uIGlzVmFsaWRTdGF0dXMoc3RhdHVzKSB7XHJcbiAgY29uc3QgdmFsaWRTdGF0dXNlcyA9IFsnUFJFU0VOVCcsICdBQlNFTlQnLCAnTEFURScsICdIT0xJREFZJywgJ0VYQ1VTRUQnXTtcclxuICByZXR1cm4gdmFsaWRTdGF0dXNlcy5pbmNsdWRlcyhzdGF0dXMudG9VcHBlckNhc2UoKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldERlZmF1bHRQb2ludHMoc3RhdHVzKSB7XHJcbiAgc3dpdGNoIChzdGF0dXMudG9VcHBlckNhc2UoKSkge1xyXG4gICAgY2FzZSAnUFJFU0VOVCc6XHJcbiAgICAgIHJldHVybiAyO1xyXG4gICAgY2FzZSAnRVhDVVNFRCc6XHJcbiAgICAgIHJldHVybiAxO1xyXG4gICAgY2FzZSAnTEFURSc6XHJcbiAgICAgIHJldHVybiAxOyAvLyBpZGsgd2hhdCBsYXRlIGlzIHdvcnRoXHJcbiAgICBjYXNlICdBQlNFTlQnOlxyXG4gICAgICByZXR1cm4gMDtcclxuICAgIGNhc2UgJ0hPTElEQVknOlxyXG4gICAgICByZXR1cm4gMDtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiAwO1xyXG4gIH1cclxufSJdLCJuYW1lcyI6WyJQcmlzbWFDbGllbnQiLCJwcmlzbWEiLCJwcmlzbWFVc2FibGUiLCJpbml0UHJpc21hIiwiZXJyIiwiY29uc29sZSIsImVycm9yIiwiZ2V0UHJpc21hIiwiYXR0ZW5kYW5jZUZhbGxiYWNrIiwiY291cnNlc0ZhbGxiYWNrIiwiZ2V0QXR0ZW5kYW5jZUZhbGxiYWNrIiwibW9kIiwiZGVmYXVsdCIsImdldENvdXJzZXNGYWxsYmFjayIsImlzUHJpc21hRW5naW5lRXJyb3IiLCJtc2ciLCJtZXNzYWdlIiwiaW5jbHVkZXMiLCJuYW1lIiwiaGFuZGxlciIsInJlcSIsInJlcyIsIm1ldGhvZCIsImhhbmRsZUdldCIsImhhbmRsZVBvc3QiLCJoYW5kbGVQdXQiLCJoYW5kbGVEZWxldGUiLCJzZXRIZWFkZXIiLCJzdGF0dXMiLCJqc29uIiwic3VjY2VzcyIsImRldGFpbHMiLCJwcm9jZXNzIiwidW5kZWZpbmVkIiwiY291cnNlSWQiLCJxdWVyeSIsImVmZmVjdGl2ZVVzZXJJZCIsImdldFRva2VuIiwidG9rZW4iLCJzZWNyZXQiLCJlbnYiLCJORVhUQVVUSF9TRUNSRVQiLCJ1c2VySWQiLCJlIiwid2FybiIsInAiLCJjb3Vyc2UiLCJmYiIsImZpbmQiLCJmaW5kRmlyc3QiLCJ3aGVyZSIsImlkIiwidXNlcl9pZCIsInAyIiwic2Vzc2lvbnMiLCJsaXN0IiwiYXR0ZW5kYW5jZVNlc3Npb24iLCJmaW5kTWFueSIsImNvdXJzZV9pZCIsIm9yZGVyQnkiLCJkYXRlIiwiaW5jbHVkZSIsImNvdXJzZXMiLCJzZWxlY3QiLCJjb2RlIiwiY29sb3IiLCJmb3JtYXR0ZWRTZXNzaW9ucyIsIm1hcCIsInNlc3Npb24iLCJzcGxpdCIsInRvSVNPU3RyaW5nIiwicG9pbnRzIiwibm90ZXMiLCJjcmVhdGVkQXQiLCJjcmVhdGVkX2F0IiwidXBkYXRlZEF0IiwidXBkYXRlZF9hdCIsInRvdGFsIiwibGVuZ3RoIiwiYm9keSIsImlzVmFsaWRTdGF0dXMiLCJzZXNzaW9uRGF0ZSIsIkRhdGUiLCJpc05hTiIsImdldFRpbWUiLCJleGlzdGluZ1Nlc3Npb24iLCJzIiwic2Vzc2lvblBvaW50cyIsInBhcnNlSW50IiwiZ2V0RGVmYXVsdFBvaW50cyIsInAzIiwibmV3U2Vzc2lvbiIsImNyZWF0ZSIsImRhdGEiLCJ0b1VwcGVyQ2FzZSIsInRyaW0iLCJmb3JtYXR0ZWRTZXNzaW9uIiwidG9rZW5Vc2VySWQiLCJwNCIsInVwZGF0ZURhdGEiLCJwNSIsImR1cGxpY2F0ZVNlc3Npb24iLCJub3QiLCJwNiIsInVwZGF0ZWRTZXNzaW9uIiwidXBkYXRlIiwicDciLCJleGlzdGluZ0RlbFNlc3Npb24iLCJkZWxldGUiLCJkZWxldGVkU2Vzc2lvbiIsInZhbGlkU3RhdHVzZXMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api-node)/./pages/api/attendance.js\n");

/***/ }),

/***/ "@prisma/client":
/*!*********************************!*\
  !*** external "@prisma/client" ***!
  \*********************************/
/***/ ((module) => {

module.exports = require("@prisma/client");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "next-auth/jwt":
/*!********************************!*\
  !*** external "next-auth/jwt" ***!
  \********************************/
/***/ ((module) => {

module.exports = require("next-auth/jwt");

/***/ }),

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api-node)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fattendance&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cattendance.js&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();