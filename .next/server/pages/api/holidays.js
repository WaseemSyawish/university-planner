"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/holidays";
exports.ids = ["pages/api/holidays"];
exports.modules = {

/***/ "(api-node)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fholidays&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cholidays.js&middlewareConfigBase64=e30%3D!":
/*!**********************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fholidays&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cholidays.js&middlewareConfigBase64=e30%3D! ***!
  \**********************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   handler: () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_api_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/api-utils */ \"(api-node)/./node_modules/next/dist/server/api-utils/index.js\");\n/* harmony import */ var next_dist_server_api_utils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_api_utils__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/route-kind */ \"(api-node)/./node_modules/next/dist/server/route-kind.js\");\n/* harmony import */ var next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/route-modules/pages-api/module.compiled */ \"(api-node)/./node_modules/next/dist/server/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api-node)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _pages_api_holidays_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pages\\api\\holidays.js */ \"(api-node)/./pages/api/holidays.js\");\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/dist/server/lib/trace/tracer */ \"(api-node)/./node_modules/next/dist/server/lib/trace/tracer.js\");\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/dist/server/lib/trace/constants */ \"(api-node)/./node_modules/next/dist/server/lib/trace/constants.js\");\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_6__);\n\n\n\n\n// Import the userland code.\n\n\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_3__.hoist)(_pages_api_holidays_js__WEBPACK_IMPORTED_MODULE_4__, 'default'));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_3__.hoist)(_pages_api_holidays_js__WEBPACK_IMPORTED_MODULE_4__, 'config');\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_2__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/holidays\",\n        pathname: \"/api/holidays\",\n        // The following aren't used in production.\n        bundlePath: '',\n        filename: ''\n    },\n    userland: _pages_api_holidays_js__WEBPACK_IMPORTED_MODULE_4__,\n    distDir: \".next\" || 0,\n    relativeProjectDir:  false || ''\n});\nasync function handler(req, res, ctx) {\n    let srcPage = \"/api/holidays\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (false) {}\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return;\n    }\n    const { query, params, prerenderManifest, routerServerContext } = prepareResult;\n    try {\n        const method = req.method || 'GET';\n        const tracer = (0,next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_5__.getTracer)();\n        const activeSpan = tracer.getActiveScopeSpan();\n        const onRequestError = routeModule.instrumentationOnRequestError.bind(routeModule);\n        const invokeRouteModule = async (span)=>routeModule.render(req, res, {\n                query: {\n                    ...query,\n                    ...params\n                },\n                params,\n                allowedRevalidateHeaderKeys: [],\n                multiZoneDraftMode: Boolean(false),\n                trustHostHeader: false,\n                // TODO: get this from from runtime env so manifest\n                // doesn't need to load\n                previewProps: prerenderManifest.preview,\n                propagateError: false,\n                dev: routeModule.isDev,\n                page: \"/api/holidays\",\n                internalRevalidate: routerServerContext == null ? void 0 : routerServerContext.revalidate,\n                onError: (...args)=>onRequestError(req, ...args)\n            }).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_6__.BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${req.url}`);\n                }\n            });\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await invokeRouteModule(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_6__.BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${req.url}`,\n                    kind: next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_5__.SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, invokeRouteModule));\n        }\n    } catch (err) {\n        // we re-throw in dev to show the error overlay\n        if (routeModule.isDev) {\n            throw err;\n        }\n        // this is technically an invariant as error handling\n        // should be done inside of api-resolver onError\n        (0,next_dist_server_api_utils__WEBPACK_IMPORTED_MODULE_0__.sendError)(res, 500, 'Internal Server Error');\n    } finally{\n        // We don't allow any waitUntil work in pages API routes currently\n        // so if callback is present return with resolved promise since no\n        // pending work\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n    }\n}\n\n//# sourceMappingURL=pages-api.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtcm91dGUtbG9hZGVyL2luZGV4LmpzP2tpbmQ9UEFHRVNfQVBJJnBhZ2U9JTJGYXBpJTJGaG9saWRheXMmcHJlZmVycmVkUmVnaW9uPSZhYnNvbHV0ZVBhZ2VQYXRoPS4lMkZwYWdlcyU1Q2FwaSU1Q2hvbGlkYXlzLmpzJm1pZGRsZXdhcmVDb25maWdCYXNlNjQ9ZTMwJTNEISIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUF1RDtBQUNDO0FBQ3VDO0FBQ3JDO0FBQzFEO0FBQ3NEO0FBQ2tCO0FBQ0Y7QUFDdEU7QUFDQSxpRUFBZSx3RUFBSyxDQUFDLG1EQUFRLFlBQVksRUFBQztBQUMxQztBQUNPLGVBQWUsd0VBQUssQ0FBQyxtREFBUTtBQUNwQztBQUNBLHdCQUF3Qix5R0FBbUI7QUFDM0M7QUFDQSxjQUFjLGtFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWTtBQUNaLGFBQWEsT0FBb0MsSUFBSSxDQUFFO0FBQ3ZELHdCQUF3QixNQUF1QztBQUMvRCxDQUFDO0FBQ007QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBcUIsRUFBRSxFQUUxQjtBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3REFBd0Q7QUFDcEU7QUFDQTtBQUNBLHVCQUF1Qiw0RUFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSw2Q0FBNkMsRUFBNkM7QUFDMUYsNENBQTRDLEtBQXdDO0FBQ3BGLGlDQUFpQyxLQUFvQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsZ0ZBQWM7QUFDL0UsK0RBQStELHlDQUF5QztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRLEVBQUUsTUFBTTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGtCQUFrQjtBQUNsQix1Q0FBdUMsUUFBUSxFQUFFLFFBQVE7QUFDekQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNkVBQTZFLGdGQUFjO0FBQzNGLGlDQUFpQyxRQUFRLEVBQUUsUUFBUTtBQUNuRCwwQkFBMEIsdUVBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxxRUFBUztBQUNqQixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2VuZEVycm9yIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvYXBpLXV0aWxzXCI7XG5pbXBvcnQgeyBSb3V0ZUtpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBQYWdlc0FQSVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvcm91dGUtbW9kdWxlcy9wYWdlcy1hcGkvbW9kdWxlLmNvbXBpbGVkXCI7XG5pbXBvcnQgeyBob2lzdCB9IGZyb20gXCJuZXh0L2Rpc3QvYnVpbGQvdGVtcGxhdGVzL2hlbHBlcnNcIjtcbi8vIEltcG9ydCB0aGUgdXNlcmxhbmQgY29kZS5cbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCIuL3BhZ2VzXFxcXGFwaVxcXFxob2xpZGF5cy5qc1wiO1xuaW1wb3J0IHsgZ2V0VHJhY2VyLCBTcGFuS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi90cmFjZS90cmFjZXJcIjtcbmltcG9ydCB7IEJhc2VTZXJ2ZXJTcGFuIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL3RyYWNlL2NvbnN0YW50c1wiO1xuLy8gUmUtZXhwb3J0IHRoZSBoYW5kbGVyIChzaG91bGQgYmUgdGhlIGRlZmF1bHQgZXhwb3J0KS5cbmV4cG9ydCBkZWZhdWx0IGhvaXN0KHVzZXJsYW5kLCAnZGVmYXVsdCcpO1xuLy8gUmUtZXhwb3J0IGNvbmZpZy5cbmV4cG9ydCBjb25zdCBjb25maWcgPSBob2lzdCh1c2VybGFuZCwgJ2NvbmZpZycpO1xuLy8gQ3JlYXRlIGFuZCBleHBvcnQgdGhlIHJvdXRlIG1vZHVsZSB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG5jb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBQYWdlc0FQSVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5QQUdFU19BUEksXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9ob2xpZGF5c1wiLFxuICAgICAgICBwYXRobmFtZTogXCIvYXBpL2hvbGlkYXlzXCIsXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgYXJlbid0IHVzZWQgaW4gcHJvZHVjdGlvbi5cbiAgICAgICAgYnVuZGxlUGF0aDogJycsXG4gICAgICAgIGZpbGVuYW1lOiAnJ1xuICAgIH0sXG4gICAgdXNlcmxhbmQsXG4gICAgZGlzdERpcjogcHJvY2Vzcy5lbnYuX19ORVhUX1JFTEFUSVZFX0RJU1RfRElSIHx8ICcnLFxuICAgIHJlbGF0aXZlUHJvamVjdERpcjogcHJvY2Vzcy5lbnYuX19ORVhUX1JFTEFUSVZFX1BST0pFQ1RfRElSIHx8ICcnXG59KTtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoYW5kbGVyKHJlcSwgcmVzLCBjdHgpIHtcbiAgICBsZXQgc3JjUGFnZSA9IFwiL2FwaS9ob2xpZGF5c1wiO1xuICAgIC8vIHR1cmJvcGFjayBkb2Vzbid0IG5vcm1hbGl6ZSBgL2luZGV4YCBpbiB0aGUgcGFnZSBuYW1lXG4gICAgLy8gc28gd2UgbmVlZCB0byB0byBwcm9jZXNzIGR5bmFtaWMgcm91dGVzIHByb3Blcmx5XG4gICAgLy8gVE9ETzogZml4IHR1cmJvcGFjayBwcm92aWRpbmcgZGlmZmVyaW5nIHZhbHVlIGZyb20gd2VicGFja1xuICAgIGlmIChwcm9jZXNzLmVudi5UVVJCT1BBQ0spIHtcbiAgICAgICAgc3JjUGFnZSA9IHNyY1BhZ2UucmVwbGFjZSgvXFwvaW5kZXgkLywgJycpIHx8ICcvJztcbiAgICB9XG4gICAgY29uc3QgcHJlcGFyZVJlc3VsdCA9IGF3YWl0IHJvdXRlTW9kdWxlLnByZXBhcmUocmVxLCByZXMsIHtcbiAgICAgICAgc3JjUGFnZVxuICAgIH0pO1xuICAgIGlmICghcHJlcGFyZVJlc3VsdCkge1xuICAgICAgICByZXMuc3RhdHVzQ29kZSA9IDQwMDtcbiAgICAgICAgcmVzLmVuZCgnQmFkIFJlcXVlc3QnKTtcbiAgICAgICAgY3R4LndhaXRVbnRpbCA9PSBudWxsID8gdm9pZCAwIDogY3R4LndhaXRVbnRpbC5jYWxsKGN0eCwgUHJvbWlzZS5yZXNvbHZlKCkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgcXVlcnksIHBhcmFtcywgcHJlcmVuZGVyTWFuaWZlc3QsIHJvdXRlclNlcnZlckNvbnRleHQgfSA9IHByZXBhcmVSZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gcmVxLm1ldGhvZCB8fCAnR0VUJztcbiAgICAgICAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKCk7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVNwYW4gPSB0cmFjZXIuZ2V0QWN0aXZlU2NvcGVTcGFuKCk7XG4gICAgICAgIGNvbnN0IG9uUmVxdWVzdEVycm9yID0gcm91dGVNb2R1bGUuaW5zdHJ1bWVudGF0aW9uT25SZXF1ZXN0RXJyb3IuYmluZChyb3V0ZU1vZHVsZSk7XG4gICAgICAgIGNvbnN0IGludm9rZVJvdXRlTW9kdWxlID0gYXN5bmMgKHNwYW4pPT5yb3V0ZU1vZHVsZS5yZW5kZXIocmVxLCByZXMsIHtcbiAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICAuLi5xdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgLi4ucGFyYW1zXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICAgICAgYWxsb3dlZFJldmFsaWRhdGVIZWFkZXJLZXlzOiBwcm9jZXNzLmVudi5fX05FWFRfQUxMT1dFRF9SRVZBTElEQVRFX0hFQURFUlMsXG4gICAgICAgICAgICAgICAgbXVsdGlab25lRHJhZnRNb2RlOiBCb29sZWFuKHByb2Nlc3MuZW52Ll9fTkVYVF9NVUxUSV9aT05FX0RSQUZUX01PREUpLFxuICAgICAgICAgICAgICAgIHRydXN0SG9zdEhlYWRlcjogcHJvY2Vzcy5lbnYuX19ORVhUX1RSVVNUX0hPU1RfSEVBREVSLFxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGdldCB0aGlzIGZyb20gZnJvbSBydW50aW1lIGVudiBzbyBtYW5pZmVzdFxuICAgICAgICAgICAgICAgIC8vIGRvZXNuJ3QgbmVlZCB0byBsb2FkXG4gICAgICAgICAgICAgICAgcHJldmlld1Byb3BzOiBwcmVyZW5kZXJNYW5pZmVzdC5wcmV2aWV3LFxuICAgICAgICAgICAgICAgIHByb3BhZ2F0ZUVycm9yOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkZXY6IHJvdXRlTW9kdWxlLmlzRGV2LFxuICAgICAgICAgICAgICAgIHBhZ2U6IFwiL2FwaS9ob2xpZGF5c1wiLFxuICAgICAgICAgICAgICAgIGludGVybmFsUmV2YWxpZGF0ZTogcm91dGVyU2VydmVyQ29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogcm91dGVyU2VydmVyQ29udGV4dC5yZXZhbGlkYXRlLFxuICAgICAgICAgICAgICAgIG9uRXJyb3I6ICguLi5hcmdzKT0+b25SZXF1ZXN0RXJyb3IocmVxLCAuLi5hcmdzKVxuICAgICAgICAgICAgfSkuZmluYWxseSgoKT0+e1xuICAgICAgICAgICAgICAgIGlmICghc3BhbikgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICdodHRwLnN0YXR1c19jb2RlJzogcmVzLnN0YXR1c0NvZGUsXG4gICAgICAgICAgICAgICAgICAgICduZXh0LnJzYyc6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm9vdFNwYW5BdHRyaWJ1dGVzID0gdHJhY2VyLmdldFJvb3RTcGFuQXR0cmlidXRlcygpO1xuICAgICAgICAgICAgICAgIC8vIFdlIHdlcmUgdW5hYmxlIHRvIGdldCBhdHRyaWJ1dGVzLCBwcm9iYWJseSBPVEVMIGlzIG5vdCBlbmFibGVkXG4gICAgICAgICAgICAgICAgaWYgKCFyb290U3BhbkF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocm9vdFNwYW5BdHRyaWJ1dGVzLmdldCgnbmV4dC5zcGFuX3R5cGUnKSAhPT0gQmFzZVNlcnZlclNwYW4uaGFuZGxlUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFVuZXhwZWN0ZWQgcm9vdCBzcGFuIHR5cGUgJyR7cm9vdFNwYW5BdHRyaWJ1dGVzLmdldCgnbmV4dC5zcGFuX3R5cGUnKX0nLiBQbGVhc2UgcmVwb3J0IHRoaXMgTmV4dC5qcyBpc3N1ZSBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanNgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByb3V0ZSA9IHJvb3RTcGFuQXR0cmlidXRlcy5nZXQoJ25leHQucm91dGUnKTtcbiAgICAgICAgICAgICAgICBpZiAocm91dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGAke21ldGhvZH0gJHtyb3V0ZX1gO1xuICAgICAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgJ25leHQucm91dGUnOiByb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdodHRwLnJvdXRlJzogcm91dGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbmV4dC5zcGFuX25hbWUnOiBuYW1lXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzcGFuLnVwZGF0ZU5hbWUobmFtZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3Bhbi51cGRhdGVOYW1lKGAke21ldGhvZH0gJHtyZXEudXJsfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAvLyBUT0RPOiBhY3RpdmVTcGFuIGNvZGUgcGF0aCBpcyBmb3Igd2hlbiB3cmFwcGVkIGJ5XG4gICAgICAgIC8vIG5leHQtc2VydmVyIGNhbiBiZSByZW1vdmVkIHdoZW4gdGhpcyBpcyBubyBsb25nZXIgdXNlZFxuICAgICAgICBpZiAoYWN0aXZlU3Bhbikge1xuICAgICAgICAgICAgYXdhaXQgaW52b2tlUm91dGVNb2R1bGUoYWN0aXZlU3Bhbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCB0cmFjZXIud2l0aFByb3BhZ2F0ZWRDb250ZXh0KHJlcS5oZWFkZXJzLCAoKT0+dHJhY2VyLnRyYWNlKEJhc2VTZXJ2ZXJTcGFuLmhhbmRsZVJlcXVlc3QsIHtcbiAgICAgICAgICAgICAgICAgICAgc3Bhbk5hbWU6IGAke21ldGhvZH0gJHtyZXEudXJsfWAsXG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IFNwYW5LaW5kLlNFUlZFUixcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHAubWV0aG9kJzogbWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHAudGFyZ2V0JzogcmVxLnVybFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgaW52b2tlUm91dGVNb2R1bGUpKTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyB3ZSByZS10aHJvdyBpbiBkZXYgdG8gc2hvdyB0aGUgZXJyb3Igb3ZlcmxheVxuICAgICAgICBpZiAocm91dGVNb2R1bGUuaXNEZXYpIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzIGlzIHRlY2huaWNhbGx5IGFuIGludmFyaWFudCBhcyBlcnJvciBoYW5kbGluZ1xuICAgICAgICAvLyBzaG91bGQgYmUgZG9uZSBpbnNpZGUgb2YgYXBpLXJlc29sdmVyIG9uRXJyb3JcbiAgICAgICAgc2VuZEVycm9yKHJlcywgNTAwLCAnSW50ZXJuYWwgU2VydmVyIEVycm9yJyk7XG4gICAgfSBmaW5hbGx5e1xuICAgICAgICAvLyBXZSBkb24ndCBhbGxvdyBhbnkgd2FpdFVudGlsIHdvcmsgaW4gcGFnZXMgQVBJIHJvdXRlcyBjdXJyZW50bHlcbiAgICAgICAgLy8gc28gaWYgY2FsbGJhY2sgaXMgcHJlc2VudCByZXR1cm4gd2l0aCByZXNvbHZlZCBwcm9taXNlIHNpbmNlIG5vXG4gICAgICAgIC8vIHBlbmRpbmcgd29ya1xuICAgICAgICBjdHgud2FpdFVudGlsID09IG51bGwgPyB2b2lkIDAgOiBjdHgud2FpdFVudGlsLmNhbGwoY3R4LCBQcm9taXNlLnJlc29sdmUoKSk7XG4gICAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWdlcy1hcGkuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api-node)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fholidays&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cholidays.js&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api-node)/./pages/api/holidays.js":
/*!*******************************!*\
  !*** ./pages/api/holidays.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst CACHE_DIR = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), 'data');\n// Safely fetch remote holidays and return an array or empty array on error.\nasync function fetchRemoteHolidays(year, country) {\n    const url = `https://date.nager.at/api/v3/PublicHolidays/${year}/${country}`;\n    try {\n        const r = await fetch(url, {\n            headers: {\n                'User-Agent': 'university-planner'\n            },\n            timeout: 8000\n        });\n        if (!r.ok) {\n            console.warn('Remote holidays fetch returned non-OK status', r.status, url);\n            return [];\n        }\n        const txt = await r.text();\n        if (!txt || !txt.trim()) {\n            console.info('Remote holidays fetch returned empty body for', `${year}-${country}`, url);\n            return [];\n        }\n        try {\n            const remote = JSON.parse(txt);\n            if (Array.isArray(remote) && remote.length > 0) return remote;\n            return [];\n        } catch (parseErr) {\n            const snippet = txt.length > 1000 ? txt.slice(0, 1000) + '...[truncated]' : txt;\n            console.warn('Failed parsing remote holidays JSON for', `${year}-${country}`, 'from', url, 'parseError:', parseErr.message);\n            console.debug('Remote holidays body snippet:', snippet);\n            return [];\n        }\n    } catch (err) {\n        console.error('Failed fetching remote holidays for', `${year}-${country}`, err && err.message ? err.message : err);\n        return [];\n    }\n}\nasync function handler(req, res) {\n    const { year, country } = req.query;\n    // Accept a single year or a range like 2024-2026\n    // Accept a single year or a range like 2024-2026\n    const requested = String(year || '').trim();\n    const cc = String(country || 'IQ').toUpperCase();\n    let years = [];\n    if (!requested) years = [\n        new Date().getFullYear()\n    ];\n    else if (/^\\d{4}$/.test(requested)) years = [\n        Number(requested)\n    ];\n    else if (/^\\d{4}-\\d{4}$/.test(requested)) {\n        const [a, b] = requested.split('-').map(Number);\n        for(let y = Math.min(a, b); y <= Math.max(a, b); y++)years.push(y);\n    } else {\n        // fall back to current year\n        years = [\n            new Date().getFullYear()\n        ];\n    }\n    try {\n        if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(CACHE_DIR)) fs__WEBPACK_IMPORTED_MODULE_0___default().mkdirSync(CACHE_DIR, {\n            recursive: true\n        });\n        // For each requested year, try to load or fetch and cache results; combine into one list\n        let holidays = [];\n        for (const yyyy of years){\n            const cacheFile = path__WEBPACK_IMPORTED_MODULE_1___default().join(CACHE_DIR, `holidays-${cc}-${yyyy}.json`);\n            let cached = null;\n            if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(cacheFile)) {\n                try {\n                    const raw = fs__WEBPACK_IMPORTED_MODULE_0___default().readFileSync(cacheFile, 'utf8');\n                    cached = JSON.parse(raw || '[]');\n                } catch (e) {\n                    cached = null;\n                }\n            }\n            if (cached) {\n                holidays.push(...cached);\n            } else {\n                try {\n                    const remote = await fetchRemoteHolidays(yyyy, cc);\n                    holidays.push(...remote);\n                    try {\n                        fs__WEBPACK_IMPORTED_MODULE_0___default().writeFileSync(cacheFile, JSON.stringify(remote, null, 2), 'utf8');\n                    } catch (e) {}\n                } catch (e) {\n                    console.error(`Failed fetching remote holidays for ${yyyy}-${cc}`, e);\n                }\n            }\n        }\n        // Merge with local Kurdistan/Iraq overrides if present\n        const localOverridesFile = path__WEBPACK_IMPORTED_MODULE_1___default().join(CACHE_DIR, `holidays-iq-kurdistan.json`);\n        let overrides = [];\n        try {\n            if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(localOverridesFile)) {\n                const raw = fs__WEBPACK_IMPORTED_MODULE_0___default().readFileSync(localOverridesFile, 'utf8');\n                overrides = JSON.parse(raw || '[]');\n            }\n        } catch (e) {\n            console.error('Failed reading local holidays overrides', e);\n        }\n        // Filter overrides down to only the requested years to avoid unrelated entries\n        const overrideFiltered = (overrides || []).filter((o)=>{\n            try {\n                const y = Number(String(o.date || '').slice(0, 4));\n                return years.includes(y);\n            } catch (e) {\n                return false;\n            }\n        });\n        // Also load any normalized academic holiday files (created from local PDFs)\n        try {\n            const files = fs__WEBPACK_IMPORTED_MODULE_0___default().readdirSync(CACHE_DIR);\n            const acadFiles = files.filter((f)=>f.startsWith('holidays-academic-') && f.endsWith('-normalized.json'));\n            for (const af of acadFiles){\n                try {\n                    const raw = fs__WEBPACK_IMPORTED_MODULE_0___default().readFileSync(path__WEBPACK_IMPORTED_MODULE_1___default().join(CACHE_DIR, af), 'utf8');\n                    const parsed = JSON.parse(raw || '[]');\n                    const filtered = parsed.filter((o)=>{\n                        const y = Number(String(o.date || '').slice(0, 4));\n                        return years.includes(y);\n                    });\n                    overrideFiltered.push(...filtered);\n                } catch (e) {\n                // non-fatal\n                }\n            }\n        } catch (e) {\n        // non-fatal\n        }\n        // Combine and dedupe by date+name\n        const combined = [];\n        const seen = new Set();\n        (holidays || []).concat(overrideFiltered || []).forEach((h)=>{\n            const key = `${h.date}::${(h.localName || h.name || '').toLowerCase()}`;\n            if (!seen.has(key)) {\n                seen.add(key);\n                combined.push(h);\n            }\n        });\n        // Add computed Eid dates (tabular Islamic calendar approximation) for requested years\n        const computed = [];\n        // Add common recurring holidays (Easter Gregorian, Christmas, Newroz, Iraq Independence Day)\n        function computeGregorianEaster(Y) {\n            // Meeus/Jones/Butcher Gregorian algorithm\n            const a = Y % 19;\n            const b = Math.floor(Y / 100);\n            const c = Y % 100;\n            const d = Math.floor(b / 4);\n            const e = b % 4;\n            const f = Math.floor((b + 8) / 25);\n            const g = Math.floor((b - f + 1) / 3);\n            const h = (19 * a + b - d - g + 15) % 30;\n            const i = Math.floor(c / 4);\n            const k = c % 4;\n            const l = (32 + 2 * e + 2 * i - h - k) % 7;\n            const m = Math.floor((a + 11 * h + 22 * l) / 451);\n            const month = Math.floor((h + l - 7 * m + 114) / 31); // 3=March,4=April\n            const day = (h + l - 7 * m + 114) % 31 + 1;\n            const mm = String(month).padStart(2, '0');\n            const dd = String(day).padStart(2, '0');\n            return `${Y}-${mm}-${dd}`;\n        }\n        function addRecurringHolidays(Y) {\n            // Easter (Gregorian)\n            computed.push({\n                date: computeGregorianEaster(Y),\n                localName: 'Easter',\n                name: 'Easter',\n                counties: [],\n                countryCode: cc,\n                fixed: false,\n                global: true\n            });\n            // Christmas (Dec 25)\n            computed.push({\n                date: `${Y}-12-25`,\n                localName: 'Christmas Day',\n                name: 'Christmas Day',\n                counties: [],\n                countryCode: cc,\n                fixed: true,\n                global: true\n            });\n            // Newroz (Mar 21) - Kurdish New Year\n            computed.push({\n                date: `${Y}-03-21`,\n                localName: 'Newroz',\n                name: 'Newroz (Kurdish New Year)',\n                counties: [\n                    'Kurdistan Region'\n                ],\n                countryCode: cc,\n                fixed: true,\n                global: false\n            });\n            // Iraq Independence Day (Oct 3) - national day\n            computed.push({\n                date: `${Y}-10-03`,\n                localName: 'Independence Day',\n                name: 'Iraq Independence Day',\n                counties: [],\n                countryCode: cc,\n                fixed: true,\n                global: true\n            });\n        }\n        // If a precise Eid lookup file exists, prefer it for exact dates\n        const eidLookupFile = path__WEBPACK_IMPORTED_MODULE_1___default().join(CACHE_DIR, 'holiday-eid-lookup.json');\n        let eidLookup = [];\n        try {\n            if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(eidLookupFile)) eidLookup = JSON.parse(fs__WEBPACK_IMPORTED_MODULE_0___default().readFileSync(eidLookupFile, 'utf8') || '[]');\n        } catch (e) {\n            eidLookup = [];\n        }\n        // helper: convert civil/tabular Islamic date to Julian Day Number\n        function islamicToJD(iy, im, id) {\n            // using arithmetic Islamic calendar\n            const n = id + Math.ceil(29.5 * (im - 1)) + (iy - 1) * 354 + Math.floor((3 + 11 * iy) / 30);\n            // 1948439 is the Julian day number for 1 Muharram, year 1 AH in some references\n            return n + 1948439;\n        }\n        // Fliegel & Van Flandern algorithm: convert Julian day number to Gregorian date\n        function jdToGregorian(jd) {\n            let j = Math.floor(jd) + 0; // ensure integer\n            let l = j + 68569;\n            let n = Math.floor(4 * l / 146097);\n            l = l - Math.floor((146097 * n + 3) / 4);\n            let i = Math.floor(4000 * (l + 1) / 1461001);\n            l = l - Math.floor(1461 * i / 4) + 31;\n            let j1 = Math.floor(80 * l / 2447);\n            let day = l - Math.floor(2447 * j1 / 80);\n            l = Math.floor(j1 / 11);\n            let month = j1 + 2 - 12 * l;\n            let year = 100 * (n - 49) + i + l;\n            return {\n                year,\n                month,\n                day\n            };\n        }\n        // For a Gregorian year Y, estimate likely Hijri years and compute Eid dates\n        const addEidForYear = (Y)=>{\n            // Check lookup first\n            const found = eidLookup.find((x)=>Number(x.year) === Number(Y));\n            if (found) {\n                if (found.eidFitr) computed.push({\n                    date: found.eidFitr,\n                    localName: 'Eid al-Fitr',\n                    name: 'Eid al-Fitr',\n                    counties: [],\n                    countryCode: cc,\n                    fixed: false,\n                    global: true\n                });\n                if (found.eidAdha) computed.push({\n                    date: found.eidAdha,\n                    localName: 'Eid al-Adha',\n                    name: 'Eid al-Adha',\n                    counties: [],\n                    countryCode: cc,\n                    fixed: false,\n                    global: true\n                });\n                return;\n            }\n            const approxHijri = Math.floor((Y - 622) * 33 / 32);\n            const candidates = [\n                approxHijri - 1,\n                approxHijri,\n                approxHijri + 1,\n                approxHijri + 2\n            ];\n            for (const hy of candidates){\n                if (hy <= 0) continue;\n                // Eid al-Fitr: 1 Shawwal (month 10, day 1)\n                try {\n                    const jdFitr = islamicToJD(hy, 10, 1);\n                    const gFitr = jdToGregorian(jdFitr);\n                    if (gFitr.year === Y) {\n                        const mm = String(gFitr.month).padStart(2, '0');\n                        const dd = String(gFitr.day).padStart(2, '0');\n                        computed.push({\n                            date: `${gFitr.year}-${mm}-${dd}`,\n                            localName: 'Eid al-Fitr',\n                            name: 'Eid al-Fitr',\n                            counties: [],\n                            countryCode: cc,\n                            fixed: false,\n                            global: true\n                        });\n                    }\n                } catch (e) {}\n                // Eid al-Adha: 10 Dhu al-Hijjah (month 12, day 10)\n                try {\n                    const jdAdha = islamicToJD(hy, 12, 10);\n                    const gAdha = jdToGregorian(jdAdha);\n                    if (gAdha.year === Y) {\n                        const mm = String(gAdha.month).padStart(2, '0');\n                        const dd = String(gAdha.day).padStart(2, '0');\n                        computed.push({\n                            date: `${gAdha.year}-${mm}-${dd}`,\n                            localName: 'Eid al-Adha',\n                            name: 'Eid al-Adha',\n                            counties: [],\n                            countryCode: cc,\n                            fixed: false,\n                            global: true\n                        });\n                    }\n                } catch (e) {}\n            }\n        };\n        for (const y of years){\n            addEidForYear(y);\n            addRecurringHolidays(y);\n        }\n        // Merge computed eid entries, avoiding duplicates\n        for (const e of computed){\n            const key = `${e.date}::${(e.localName || e.name || '').toLowerCase()}`;\n            if (!seen.has(key)) {\n                seen.add(key);\n                combined.push(e);\n            }\n        }\n        return res.status(200).json({\n            source: 'combined',\n            holidays: combined\n        });\n    } catch (err) {\n        console.error('Holidays API error', err);\n        // If fetching failed, attempt to return any existing cache\n        try {\n            const cacheFile = path__WEBPACK_IMPORTED_MODULE_1___default().join(CACHE_DIR, `holidays-${String(country || 'IQ').toUpperCase()}-${Number(year) || new Date().getFullYear()}.json`);\n            if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(cacheFile)) {\n                const raw = fs__WEBPACK_IMPORTED_MODULE_0___default().readFileSync(cacheFile, 'utf8');\n                const parsed = JSON.parse(raw || '[]');\n                return res.status(200).json({\n                    source: 'cache-on-error',\n                    holidays: parsed\n                });\n            }\n        } catch (e) {\n            console.error('Failed reading cache during error fallback', e);\n        }\n        return res.status(502).json({\n            error: 'Unable to fetch holidays'\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QU83QixJQUFJcEIsTUFBTSxDQUFDLEtBQUs4SCxJQUFJLENBQUM7WUFBRTdHLE9BQU87UUFBMkI7SUFDbEU7QUFDRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFx1bml2ZXJzaXR5LXBsYW5uZXJcXHBhZ2VzXFxhcGlcXGhvbGlkYXlzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmcyBmcm9tICdmcyc7XHJcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xyXG5cclxuY29uc3QgQ0FDSEVfRElSID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdkYXRhJyk7XHJcblxyXG4vLyBTYWZlbHkgZmV0Y2ggcmVtb3RlIGhvbGlkYXlzIGFuZCByZXR1cm4gYW4gYXJyYXkgb3IgZW1wdHkgYXJyYXkgb24gZXJyb3IuXHJcbmFzeW5jIGZ1bmN0aW9uIGZldGNoUmVtb3RlSG9saWRheXMoeWVhciwgY291bnRyeSkge1xyXG4gIGNvbnN0IHVybCA9IGBodHRwczovL2RhdGUubmFnZXIuYXQvYXBpL3YzL1B1YmxpY0hvbGlkYXlzLyR7eWVhcn0vJHtjb3VudHJ5fWA7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHIgPSBhd2FpdCBmZXRjaCh1cmwsIHsgaGVhZGVyczogeyAnVXNlci1BZ2VudCc6ICd1bml2ZXJzaXR5LXBsYW5uZXInIH0sIHRpbWVvdXQ6IDgwMDAgfSk7XHJcbiAgICBpZiAoIXIub2spIHtcclxuICAgICAgY29uc29sZS53YXJuKCdSZW1vdGUgaG9saWRheXMgZmV0Y2ggcmV0dXJuZWQgbm9uLU9LIHN0YXR1cycsIHIuc3RhdHVzLCB1cmwpO1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBjb25zdCB0eHQgPSBhd2FpdCByLnRleHQoKTtcclxuICAgIGlmICghdHh0IHx8ICF0eHQudHJpbSgpKSB7XHJcbiAgICAgIGNvbnNvbGUuaW5mbygnUmVtb3RlIGhvbGlkYXlzIGZldGNoIHJldHVybmVkIGVtcHR5IGJvZHkgZm9yJywgYCR7eWVhcn0tJHtjb3VudHJ5fWAsIHVybCk7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlbW90ZSA9IEpTT04ucGFyc2UodHh0KTtcclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVtb3RlKSAmJiByZW1vdGUubGVuZ3RoID4gMCkgcmV0dXJuIHJlbW90ZTtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfSBjYXRjaCAocGFyc2VFcnIpIHtcclxuICAgICAgY29uc3Qgc25pcHBldCA9IHR4dC5sZW5ndGggPiAxMDAwID8gdHh0LnNsaWNlKDAsIDEwMDApICsgJy4uLlt0cnVuY2F0ZWRdJyA6IHR4dDtcclxuICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgcGFyc2luZyByZW1vdGUgaG9saWRheXMgSlNPTiBmb3InLCBgJHt5ZWFyfS0ke2NvdW50cnl9YCwgJ2Zyb20nLCB1cmwsICdwYXJzZUVycm9yOicsIHBhcnNlRXJyLm1lc3NhZ2UpO1xyXG4gICAgICBjb25zb2xlLmRlYnVnKCdSZW1vdGUgaG9saWRheXMgYm9keSBzbmlwcGV0OicsIHNuaXBwZXQpO1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgZmV0Y2hpbmcgcmVtb3RlIGhvbGlkYXlzIGZvcicsIGAke3llYXJ9LSR7Y291bnRyeX1gLCBlcnIgJiYgZXJyLm1lc3NhZ2UgPyBlcnIubWVzc2FnZSA6IGVycik7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBoYW5kbGVyKHJlcSwgcmVzKSB7XHJcbiAgY29uc3QgeyB5ZWFyLCBjb3VudHJ5IH0gPSByZXEucXVlcnk7XHJcblxyXG4gIC8vIEFjY2VwdCBhIHNpbmdsZSB5ZWFyIG9yIGEgcmFuZ2UgbGlrZSAyMDI0LTIwMjZcclxuICAvLyBBY2NlcHQgYSBzaW5nbGUgeWVhciBvciBhIHJhbmdlIGxpa2UgMjAyNC0yMDI2XHJcbiAgY29uc3QgcmVxdWVzdGVkID0gU3RyaW5nKHllYXIgfHwgJycpLnRyaW0oKTtcclxuICBjb25zdCBjYyA9IFN0cmluZyhjb3VudHJ5IHx8ICdJUScpLnRvVXBwZXJDYXNlKCk7XHJcbiAgbGV0IHllYXJzID0gW107XHJcbiAgaWYgKCFyZXF1ZXN0ZWQpIHllYXJzID0gW25ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKV07XHJcbiAgZWxzZSBpZiAoL15cXGR7NH0kLy50ZXN0KHJlcXVlc3RlZCkpIHllYXJzID0gW051bWJlcihyZXF1ZXN0ZWQpXTtcclxuICBlbHNlIGlmICgvXlxcZHs0fS1cXGR7NH0kLy50ZXN0KHJlcXVlc3RlZCkpIHtcclxuICAgIGNvbnN0IFthLGJdID0gcmVxdWVzdGVkLnNwbGl0KCctJykubWFwKE51bWJlcik7XHJcbiAgICBmb3IgKGxldCB5ID0gTWF0aC5taW4oYSxiKTsgeSA8PSBNYXRoLm1heChhLGIpOyB5KyspIHllYXJzLnB1c2goeSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIGZhbGwgYmFjayB0byBjdXJyZW50IHllYXJcclxuICAgIHllYXJzID0gW25ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKV07XHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKENBQ0hFX0RJUikpIGZzLm1rZGlyU3luYyhDQUNIRV9ESVIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xyXG4gICAgLy8gRm9yIGVhY2ggcmVxdWVzdGVkIHllYXIsIHRyeSB0byBsb2FkIG9yIGZldGNoIGFuZCBjYWNoZSByZXN1bHRzOyBjb21iaW5lIGludG8gb25lIGxpc3RcclxuICAgIGxldCBob2xpZGF5cyA9IFtdO1xyXG4gICAgZm9yIChjb25zdCB5eXl5IG9mIHllYXJzKSB7XHJcbiAgICAgIGNvbnN0IGNhY2hlRmlsZSA9IHBhdGguam9pbihDQUNIRV9ESVIsIGBob2xpZGF5cy0ke2NjfS0ke3l5eXl9Lmpzb25gKTtcclxuICAgICAgbGV0IGNhY2hlZCA9IG51bGw7XHJcbiAgICAgIGlmIChmcy5leGlzdHNTeW5jKGNhY2hlRmlsZSkpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgcmF3ID0gZnMucmVhZEZpbGVTeW5jKGNhY2hlRmlsZSwgJ3V0ZjgnKTtcclxuICAgICAgICAgIGNhY2hlZCA9IEpTT04ucGFyc2UocmF3IHx8ICdbXScpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIGNhY2hlZCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChjYWNoZWQpIHtcclxuICAgICAgICBob2xpZGF5cy5wdXNoKC4uLmNhY2hlZCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IHJlbW90ZSA9IGF3YWl0IGZldGNoUmVtb3RlSG9saWRheXMoeXl5eSwgY2MpO1xyXG4gICAgICAgICAgaG9saWRheXMucHVzaCguLi5yZW1vdGUpO1xyXG4gICAgICAgICAgdHJ5IHsgZnMud3JpdGVGaWxlU3luYyhjYWNoZUZpbGUsIEpTT04uc3RyaW5naWZ5KHJlbW90ZSwgbnVsbCwgMiksICd1dGY4Jyk7IH0gY2F0Y2goZSl7IC8qIG5vbi1mYXRhbCAqLyB9XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIGZldGNoaW5nIHJlbW90ZSBob2xpZGF5cyBmb3IgJHt5eXl5fS0ke2NjfWAsIGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIE1lcmdlIHdpdGggbG9jYWwgS3VyZGlzdGFuL0lyYXEgb3ZlcnJpZGVzIGlmIHByZXNlbnRcclxuICAgIGNvbnN0IGxvY2FsT3ZlcnJpZGVzRmlsZSA9IHBhdGguam9pbihDQUNIRV9ESVIsIGBob2xpZGF5cy1pcS1rdXJkaXN0YW4uanNvbmApO1xyXG4gICAgbGV0IG92ZXJyaWRlcyA9IFtdO1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKGZzLmV4aXN0c1N5bmMobG9jYWxPdmVycmlkZXNGaWxlKSkge1xyXG4gICAgICAgIGNvbnN0IHJhdyA9IGZzLnJlYWRGaWxlU3luYyhsb2NhbE92ZXJyaWRlc0ZpbGUsICd1dGY4Jyk7XHJcbiAgICAgICAgb3ZlcnJpZGVzID0gSlNPTi5wYXJzZShyYXcgfHwgJ1tdJyk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHJlYWRpbmcgbG9jYWwgaG9saWRheXMgb3ZlcnJpZGVzJywgZSk7XHJcbiAgICB9XHJcbiAgICAvLyBGaWx0ZXIgb3ZlcnJpZGVzIGRvd24gdG8gb25seSB0aGUgcmVxdWVzdGVkIHllYXJzIHRvIGF2b2lkIHVucmVsYXRlZCBlbnRyaWVzXHJcbiAgICBjb25zdCBvdmVycmlkZUZpbHRlcmVkID0gKG92ZXJyaWRlcyB8fCBbXSkuZmlsdGVyKG8gPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHkgPSBOdW1iZXIoU3RyaW5nKG8uZGF0ZSB8fCAnJykuc2xpY2UoMCw0KSk7XHJcbiAgICAgICAgcmV0dXJuIHllYXJzLmluY2x1ZGVzKHkpO1xyXG4gICAgICB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQWxzbyBsb2FkIGFueSBub3JtYWxpemVkIGFjYWRlbWljIGhvbGlkYXkgZmlsZXMgKGNyZWF0ZWQgZnJvbSBsb2NhbCBQREZzKVxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgZmlsZXMgPSBmcy5yZWFkZGlyU3luYyhDQUNIRV9ESVIpO1xyXG4gICAgICBjb25zdCBhY2FkRmlsZXMgPSBmaWxlcy5maWx0ZXIoZiA9PiBmLnN0YXJ0c1dpdGgoJ2hvbGlkYXlzLWFjYWRlbWljLScpICYmIGYuZW5kc1dpdGgoJy1ub3JtYWxpemVkLmpzb24nKSk7XHJcbiAgICAgIGZvciAoY29uc3QgYWYgb2YgYWNhZEZpbGVzKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IHJhdyA9IGZzLnJlYWRGaWxlU3luYyhwYXRoLmpvaW4oQ0FDSEVfRElSLCBhZiksICd1dGY4Jyk7XHJcbiAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHJhdyB8fCAnW10nKTtcclxuICAgICAgICAgIGNvbnN0IGZpbHRlcmVkID0gcGFyc2VkLmZpbHRlcihvID0+IHtcclxuICAgICAgICAgICAgY29uc3QgeSA9IE51bWJlcihTdHJpbmcoby5kYXRlIHx8ICcnKS5zbGljZSgwLDQpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHllYXJzLmluY2x1ZGVzKHkpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBvdmVycmlkZUZpbHRlcmVkLnB1c2goLi4uZmlsdGVyZWQpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIC8vIG5vbi1mYXRhbFxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAvLyBub24tZmF0YWxcclxuICAgIH1cclxuXHJcbiAgICAvLyBDb21iaW5lIGFuZCBkZWR1cGUgYnkgZGF0ZStuYW1lXHJcbiAgICBjb25zdCBjb21iaW5lZCA9IFtdO1xyXG4gICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcclxuICAgIChob2xpZGF5cyB8fCBbXSkuY29uY2F0KG92ZXJyaWRlRmlsdGVyZWQgfHwgW10pLmZvckVhY2goaCA9PiB7XHJcbiAgICAgIGNvbnN0IGtleSA9IGAke2guZGF0ZX06OiR7KGgubG9jYWxOYW1lIHx8IGgubmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKX1gO1xyXG4gICAgICBpZiAoIXNlZW4uaGFzKGtleSkpIHtcclxuICAgICAgICBzZWVuLmFkZChrZXkpO1xyXG4gICAgICAgIGNvbWJpbmVkLnB1c2goaCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFkZCBjb21wdXRlZCBFaWQgZGF0ZXMgKHRhYnVsYXIgSXNsYW1pYyBjYWxlbmRhciBhcHByb3hpbWF0aW9uKSBmb3IgcmVxdWVzdGVkIHllYXJzXHJcbiAgICBjb25zdCBjb21wdXRlZCA9IFtdO1xyXG4gICAgLy8gQWRkIGNvbW1vbiByZWN1cnJpbmcgaG9saWRheXMgKEVhc3RlciBHcmVnb3JpYW4sIENocmlzdG1hcywgTmV3cm96LCBJcmFxIEluZGVwZW5kZW5jZSBEYXkpXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlR3JlZ29yaWFuRWFzdGVyKFkpIHtcclxuICAgICAgLy8gTWVldXMvSm9uZXMvQnV0Y2hlciBHcmVnb3JpYW4gYWxnb3JpdGhtXHJcbiAgICAgIGNvbnN0IGEgPSBZICUgMTk7XHJcbiAgICAgIGNvbnN0IGIgPSBNYXRoLmZsb29yKFkgLyAxMDApO1xyXG4gICAgICBjb25zdCBjID0gWSAlIDEwMDtcclxuICAgICAgY29uc3QgZCA9IE1hdGguZmxvb3IoYiAvIDQpO1xyXG4gICAgICBjb25zdCBlID0gYiAlIDQ7XHJcbiAgICAgIGNvbnN0IGYgPSBNYXRoLmZsb29yKChiICsgOCkgLyAyNSk7XHJcbiAgICAgIGNvbnN0IGcgPSBNYXRoLmZsb29yKChiIC0gZiArIDEpIC8gMyk7XHJcbiAgICAgIGNvbnN0IGggPSAoMTkgKiBhICsgYiAtIGQgLSBnICsgMTUpICUgMzA7XHJcbiAgICAgIGNvbnN0IGkgPSBNYXRoLmZsb29yKGMgLyA0KTtcclxuICAgICAgY29uc3QgayA9IGMgJSA0O1xyXG4gICAgICBjb25zdCBsID0gKDMyICsgMiAqIGUgKyAyICogaSAtIGggLSBrKSAlIDc7XHJcbiAgICAgIGNvbnN0IG0gPSBNYXRoLmZsb29yKChhICsgMTEgKiBoICsgMjIgKiBsKSAvIDQ1MSk7XHJcbiAgICAgIGNvbnN0IG1vbnRoID0gTWF0aC5mbG9vcigoaCArIGwgLSA3ICogbSArIDExNCkgLyAzMSk7IC8vIDM9TWFyY2gsND1BcHJpbFxyXG4gICAgICBjb25zdCBkYXkgPSAoKGggKyBsIC0gNyAqIG0gKyAxMTQpICUgMzEpICsgMTtcclxuICAgICAgY29uc3QgbW0gPSBTdHJpbmcobW9udGgpLnBhZFN0YXJ0KDIsICcwJyk7XHJcbiAgICAgIGNvbnN0IGRkID0gU3RyaW5nKGRheSkucGFkU3RhcnQoMiwgJzAnKTtcclxuICAgICAgcmV0dXJuIGAke1l9LSR7bW19LSR7ZGR9YDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRSZWN1cnJpbmdIb2xpZGF5cyhZKSB7XHJcbiAgICAgIC8vIEVhc3RlciAoR3JlZ29yaWFuKVxyXG4gICAgICBjb21wdXRlZC5wdXNoKHsgZGF0ZTogY29tcHV0ZUdyZWdvcmlhbkVhc3RlcihZKSwgbG9jYWxOYW1lOiAnRWFzdGVyJywgbmFtZTogJ0Vhc3RlcicsIGNvdW50aWVzOiBbXSwgY291bnRyeUNvZGU6IGNjLCBmaXhlZDogZmFsc2UsIGdsb2JhbDogdHJ1ZSB9KTtcclxuICAgICAgLy8gQ2hyaXN0bWFzIChEZWMgMjUpXHJcbiAgICAgIGNvbXB1dGVkLnB1c2goeyBkYXRlOiBgJHtZfS0xMi0yNWAsIGxvY2FsTmFtZTogJ0NocmlzdG1hcyBEYXknLCBuYW1lOiAnQ2hyaXN0bWFzIERheScsIGNvdW50aWVzOiBbXSwgY291bnRyeUNvZGU6IGNjLCBmaXhlZDogdHJ1ZSwgZ2xvYmFsOiB0cnVlIH0pO1xyXG4gICAgICAvLyBOZXdyb3ogKE1hciAyMSkgLSBLdXJkaXNoIE5ldyBZZWFyXHJcbiAgICAgIGNvbXB1dGVkLnB1c2goeyBkYXRlOiBgJHtZfS0wMy0yMWAsIGxvY2FsTmFtZTogJ05ld3JveicsIG5hbWU6ICdOZXdyb3ogKEt1cmRpc2ggTmV3IFllYXIpJywgY291bnRpZXM6IFsnS3VyZGlzdGFuIFJlZ2lvbiddLCBjb3VudHJ5Q29kZTogY2MsIGZpeGVkOiB0cnVlLCBnbG9iYWw6IGZhbHNlIH0pO1xyXG4gICAgICAvLyBJcmFxIEluZGVwZW5kZW5jZSBEYXkgKE9jdCAzKSAtIG5hdGlvbmFsIGRheVxyXG4gICAgICBjb21wdXRlZC5wdXNoKHsgZGF0ZTogYCR7WX0tMTAtMDNgLCBsb2NhbE5hbWU6ICdJbmRlcGVuZGVuY2UgRGF5JywgbmFtZTogJ0lyYXEgSW5kZXBlbmRlbmNlIERheScsIGNvdW50aWVzOiBbXSwgY291bnRyeUNvZGU6IGNjLCBmaXhlZDogdHJ1ZSwgZ2xvYmFsOiB0cnVlIH0pO1xyXG4gICAgfVxyXG4gIC8vIElmIGEgcHJlY2lzZSBFaWQgbG9va3VwIGZpbGUgZXhpc3RzLCBwcmVmZXIgaXQgZm9yIGV4YWN0IGRhdGVzXHJcbiAgY29uc3QgZWlkTG9va3VwRmlsZSA9IHBhdGguam9pbihDQUNIRV9ESVIsICdob2xpZGF5LWVpZC1sb29rdXAuanNvbicpO1xyXG4gIGxldCBlaWRMb29rdXAgPSBbXTtcclxuICB0cnkgeyBpZiAoZnMuZXhpc3RzU3luYyhlaWRMb29rdXBGaWxlKSkgZWlkTG9va3VwID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMoZWlkTG9va3VwRmlsZSwndXRmOCcpfHwnW10nKTsgfSBjYXRjaChlKSB7IGVpZExvb2t1cCA9IFtdOyB9XHJcbiAgICAvLyBoZWxwZXI6IGNvbnZlcnQgY2l2aWwvdGFidWxhciBJc2xhbWljIGRhdGUgdG8gSnVsaWFuIERheSBOdW1iZXJcclxuICAgIGZ1bmN0aW9uIGlzbGFtaWNUb0pEKGl5LCBpbSwgaWQpIHtcclxuICAgICAgLy8gdXNpbmcgYXJpdGhtZXRpYyBJc2xhbWljIGNhbGVuZGFyXHJcbiAgICAgIGNvbnN0IG4gPSBpZCArIE1hdGguY2VpbCgyOS41ICogKGltIC0gMSkpICsgKGl5IC0gMSkgKiAzNTQgKyBNYXRoLmZsb29yKCgzICsgMTEgKiBpeSkgLyAzMCk7XHJcbiAgICAgIC8vIDE5NDg0MzkgaXMgdGhlIEp1bGlhbiBkYXkgbnVtYmVyIGZvciAxIE11aGFycmFtLCB5ZWFyIDEgQUggaW4gc29tZSByZWZlcmVuY2VzXHJcbiAgICAgIHJldHVybiBuICsgMTk0ODQzOTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGbGllZ2VsICYgVmFuIEZsYW5kZXJuIGFsZ29yaXRobTogY29udmVydCBKdWxpYW4gZGF5IG51bWJlciB0byBHcmVnb3JpYW4gZGF0ZVxyXG4gICAgZnVuY3Rpb24gamRUb0dyZWdvcmlhbihqZCkge1xyXG4gICAgICBsZXQgaiA9IE1hdGguZmxvb3IoamQpICsgMDsgLy8gZW5zdXJlIGludGVnZXJcclxuICAgICAgbGV0IGwgPSBqICsgNjg1Njk7XHJcbiAgICAgIGxldCBuID0gTWF0aC5mbG9vcigoNCAqIGwpIC8gMTQ2MDk3KTtcclxuICAgICAgbCA9IGwgLSBNYXRoLmZsb29yKCgxNDYwOTcgKiBuICsgMykgLyA0KTtcclxuICAgICAgbGV0IGkgPSBNYXRoLmZsb29yKCg0MDAwICogKGwgKyAxKSkgLyAxNDYxMDAxKTtcclxuICAgICAgbCA9IGwgLSBNYXRoLmZsb29yKCgxNDYxICogaSkgLyA0KSArIDMxO1xyXG4gICAgICBsZXQgajEgPSBNYXRoLmZsb29yKCg4MCAqIGwpIC8gMjQ0Nyk7XHJcbiAgICAgIGxldCBkYXkgPSBsIC0gTWF0aC5mbG9vcigoMjQ0NyAqIGoxKSAvIDgwKTtcclxuICAgICAgbCA9IE1hdGguZmxvb3IoajEgLyAxMSk7XHJcbiAgICAgIGxldCBtb250aCA9IGoxICsgMiAtIDEyICogbDtcclxuICAgICAgbGV0IHllYXIgPSAxMDAgKiAobiAtIDQ5KSArIGkgKyBsO1xyXG4gICAgICByZXR1cm4geyB5ZWFyLCBtb250aCwgZGF5IH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRm9yIGEgR3JlZ29yaWFuIHllYXIgWSwgZXN0aW1hdGUgbGlrZWx5IEhpanJpIHllYXJzIGFuZCBjb21wdXRlIEVpZCBkYXRlc1xyXG4gICAgY29uc3QgYWRkRWlkRm9yWWVhciA9IChZKSA9PiB7XHJcbiAgICAgIC8vIENoZWNrIGxvb2t1cCBmaXJzdFxyXG4gICAgICBjb25zdCBmb3VuZCA9IGVpZExvb2t1cC5maW5kKHggPT4gTnVtYmVyKHgueWVhcikgPT09IE51bWJlcihZKSk7XHJcbiAgICAgIGlmIChmb3VuZCkge1xyXG4gICAgICAgIGlmIChmb3VuZC5laWRGaXRyKSBjb21wdXRlZC5wdXNoKHsgZGF0ZTogZm91bmQuZWlkRml0ciwgbG9jYWxOYW1lOiAnRWlkIGFsLUZpdHInLCBuYW1lOiAnRWlkIGFsLUZpdHInLCBjb3VudGllczogW10sIGNvdW50cnlDb2RlOiBjYywgZml4ZWQ6IGZhbHNlLCBnbG9iYWw6IHRydWUgfSk7XHJcbiAgICAgICAgaWYgKGZvdW5kLmVpZEFkaGEpIGNvbXB1dGVkLnB1c2goeyBkYXRlOiBmb3VuZC5laWRBZGhhLCBsb2NhbE5hbWU6ICdFaWQgYWwtQWRoYScsIG5hbWU6ICdFaWQgYWwtQWRoYScsIGNvdW50aWVzOiBbXSwgY291bnRyeUNvZGU6IGNjLCBmaXhlZDogZmFsc2UsIGdsb2JhbDogdHJ1ZSB9KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgYXBwcm94SGlqcmkgPSBNYXRoLmZsb29yKChZIC0gNjIyKSAqIDMzIC8gMzIpO1xyXG4gICAgICBjb25zdCBjYW5kaWRhdGVzID0gW2FwcHJveEhpanJpIC0gMSwgYXBwcm94SGlqcmksIGFwcHJveEhpanJpICsgMSwgYXBwcm94SGlqcmkgKyAyXTtcclxuICAgICAgZm9yIChjb25zdCBoeSBvZiBjYW5kaWRhdGVzKSB7XHJcbiAgICAgICAgaWYgKGh5IDw9IDApIGNvbnRpbnVlO1xyXG4gICAgICAgIC8vIEVpZCBhbC1GaXRyOiAxIFNoYXd3YWwgKG1vbnRoIDEwLCBkYXkgMSlcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgamRGaXRyID0gaXNsYW1pY1RvSkQoaHksIDEwLCAxKTtcclxuICAgICAgICAgIGNvbnN0IGdGaXRyID0gamRUb0dyZWdvcmlhbihqZEZpdHIpO1xyXG4gICAgICAgICAgaWYgKGdGaXRyLnllYXIgPT09IFkpIHtcclxuICAgICAgICAgICAgY29uc3QgbW0gPSBTdHJpbmcoZ0ZpdHIubW9udGgpLnBhZFN0YXJ0KDIsICcwJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRkID0gU3RyaW5nKGdGaXRyLmRheSkucGFkU3RhcnQoMiwgJzAnKTtcclxuICAgICAgICAgICAgY29tcHV0ZWQucHVzaCh7IGRhdGU6IGAke2dGaXRyLnllYXJ9LSR7bW19LSR7ZGR9YCwgbG9jYWxOYW1lOiAnRWlkIGFsLUZpdHInLCBuYW1lOiAnRWlkIGFsLUZpdHInLCBjb3VudGllczogW10sIGNvdW50cnlDb2RlOiBjYywgZml4ZWQ6IGZhbHNlLCBnbG9iYWw6IHRydWUgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge31cclxuICAgICAgICAvLyBFaWQgYWwtQWRoYTogMTAgRGh1IGFsLUhpamphaCAobW9udGggMTIsIGRheSAxMClcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgamRBZGhhID0gaXNsYW1pY1RvSkQoaHksIDEyLCAxMCk7XHJcbiAgICAgICAgICBjb25zdCBnQWRoYSA9IGpkVG9HcmVnb3JpYW4oamRBZGhhKTtcclxuICAgICAgICAgIGlmIChnQWRoYS55ZWFyID09PSBZKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1tID0gU3RyaW5nKGdBZGhhLm1vbnRoKS5wYWRTdGFydCgyLCAnMCcpO1xyXG4gICAgICAgICAgICBjb25zdCBkZCA9IFN0cmluZyhnQWRoYS5kYXkpLnBhZFN0YXJ0KDIsICcwJyk7XHJcbiAgICAgICAgICAgIGNvbXB1dGVkLnB1c2goeyBkYXRlOiBgJHtnQWRoYS55ZWFyfS0ke21tfS0ke2RkfWAsIGxvY2FsTmFtZTogJ0VpZCBhbC1BZGhhJywgbmFtZTogJ0VpZCBhbC1BZGhhJywgY291bnRpZXM6IFtdLCBjb3VudHJ5Q29kZTogY2MsIGZpeGVkOiBmYWxzZSwgZ2xvYmFsOiB0cnVlIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZm9yIChjb25zdCB5IG9mIHllYXJzKSB7XHJcbiAgICAgIGFkZEVpZEZvclllYXIoeSk7XHJcbiAgICAgIGFkZFJlY3VycmluZ0hvbGlkYXlzKHkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE1lcmdlIGNvbXB1dGVkIGVpZCBlbnRyaWVzLCBhdm9pZGluZyBkdXBsaWNhdGVzXHJcbiAgICBmb3IgKGNvbnN0IGUgb2YgY29tcHV0ZWQpIHtcclxuICAgICAgY29uc3Qga2V5ID0gYCR7ZS5kYXRlfTo6JHsoZS5sb2NhbE5hbWUgfHwgZS5uYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpfWA7XHJcbiAgICAgIGlmICghc2Vlbi5oYXMoa2V5KSkge1xyXG4gICAgICAgIHNlZW4uYWRkKGtleSk7XHJcbiAgICAgICAgY29tYmluZWQucHVzaChlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXMuc3RhdHVzKDIwMCkuanNvbih7IHNvdXJjZTogJ2NvbWJpbmVkJywgaG9saWRheXM6IGNvbWJpbmVkIH0pO1xyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgY29uc29sZS5lcnJvcignSG9saWRheXMgQVBJIGVycm9yJywgZXJyKTtcclxuICAgIC8vIElmIGZldGNoaW5nIGZhaWxlZCwgYXR0ZW1wdCB0byByZXR1cm4gYW55IGV4aXN0aW5nIGNhY2hlXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBjYWNoZUZpbGUgPSBwYXRoLmpvaW4oQ0FDSEVfRElSLCBgaG9saWRheXMtJHtTdHJpbmcoY291bnRyeSB8fCAnSVEnKS50b1VwcGVyQ2FzZSgpfS0ke051bWJlcih5ZWFyKSB8fCBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCl9Lmpzb25gKTtcclxuICAgICAgaWYgKGZzLmV4aXN0c1N5bmMoY2FjaGVGaWxlKSkge1xyXG4gICAgICAgIGNvbnN0IHJhdyA9IGZzLnJlYWRGaWxlU3luYyhjYWNoZUZpbGUsICd1dGY4Jyk7XHJcbiAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShyYXcgfHwgJ1tdJyk7XHJcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoMjAwKS5qc29uKHsgc291cmNlOiAnY2FjaGUtb24tZXJyb3InLCBob2xpZGF5czogcGFyc2VkIH0pO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCByZWFkaW5nIGNhY2hlIGR1cmluZyBlcnJvciBmYWxsYmFjaycsIGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoNTAyKS5qc29uKHsgZXJyb3I6ICdVbmFibGUgdG8gZmV0Y2ggaG9saWRheXMnIH0pO1xyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOlsiZnMiLCJwYXRoIiwiQ0FDSEVfRElSIiwiam9pbiIsInByb2Nlc3MiLCJjd2QiLCJmZXRjaFJlbW90ZUhvbGlkYXlzIiwieWVhciIsImNvdW50cnkiLCJ1cmwiLCJyIiwiZmV0Y2giLCJoZWFkZXJzIiwidGltZW91dCIsIm9rIiwiY29uc29sZSIsIndhcm4iLCJzdGF0dXMiLCJ0eHQiLCJ0ZXh0IiwidHJpbSIsImluZm8iLCJyZW1vdGUiLCJKU09OIiwicGFyc2UiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJwYXJzZUVyciIsInNuaXBwZXQiLCJzbGljZSIsIm1lc3NhZ2UiLCJkZWJ1ZyIsImVyciIsImVycm9yIiwiaGFuZGxlciIsInJlcSIsInJlcyIsInF1ZXJ5IiwicmVxdWVzdGVkIiwiU3RyaW5nIiwiY2MiLCJ0b1VwcGVyQ2FzZSIsInllYXJzIiwiRGF0ZSIsImdldEZ1bGxZZWFyIiwidGVzdCIsIk51bWJlciIsImEiLCJiIiwic3BsaXQiLCJtYXAiLCJ5IiwiTWF0aCIsIm1pbiIsIm1heCIsInB1c2giLCJleGlzdHNTeW5jIiwibWtkaXJTeW5jIiwicmVjdXJzaXZlIiwiaG9saWRheXMiLCJ5eXl5IiwiY2FjaGVGaWxlIiwiY2FjaGVkIiwicmF3IiwicmVhZEZpbGVTeW5jIiwiZSIsIndyaXRlRmlsZVN5bmMiLCJzdHJpbmdpZnkiLCJsb2NhbE92ZXJyaWRlc0ZpbGUiLCJvdmVycmlkZXMiLCJvdmVycmlkZUZpbHRlcmVkIiwiZmlsdGVyIiwibyIsImRhdGUiLCJpbmNsdWRlcyIsImZpbGVzIiwicmVhZGRpclN5bmMiLCJhY2FkRmlsZXMiLCJmIiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwiYWYiLCJwYXJzZWQiLCJmaWx0ZXJlZCIsImNvbWJpbmVkIiwic2VlbiIsIlNldCIsImNvbmNhdCIsImZvckVhY2giLCJoIiwia2V5IiwibG9jYWxOYW1lIiwibmFtZSIsInRvTG93ZXJDYXNlIiwiaGFzIiwiYWRkIiwiY29tcHV0ZWQiLCJjb21wdXRlR3JlZ29yaWFuRWFzdGVyIiwiWSIsImZsb29yIiwiYyIsImQiLCJnIiwiaSIsImsiLCJsIiwibSIsIm1vbnRoIiwiZGF5IiwibW0iLCJwYWRTdGFydCIsImRkIiwiYWRkUmVjdXJyaW5nSG9saWRheXMiLCJjb3VudGllcyIsImNvdW50cnlDb2RlIiwiZml4ZWQiLCJnbG9iYWwiLCJlaWRMb29rdXBGaWxlIiwiZWlkTG9va3VwIiwiaXNsYW1pY1RvSkQiLCJpeSIsImltIiwiaWQiLCJuIiwiY2VpbCIsImpkVG9HcmVnb3JpYW4iLCJqZCIsImoiLCJqMSIsImFkZEVpZEZvclllYXIiLCJmb3VuZCIsImZpbmQiLCJ4IiwiZWlkRml0ciIsImVpZEFkaGEiLCJhcHByb3hIaWpyaSIsImNhbmRpZGF0ZXMiLCJoeSIsImpkRml0ciIsImdGaXRyIiwiamRBZGhhIiwiZ0FkaGEiLCJqc29uIiwic291cmNlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api-node)/./pages/api/holidays.js\n");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api-node)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fholidays&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cholidays.js&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();