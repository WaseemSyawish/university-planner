"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/events";
exports.ids = ["pages/api/events"];
exports.modules = {

/***/ "(api-node)/./lib/prisma.js":
/*!***********************!*\
  !*** ./lib/prisma.js ***!
  \***********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Shared Prisma client to avoid creating/disconnecting clients per-request\n\nconst { PrismaClient } = __webpack_require__(/*! @prisma/client */ \"@prisma/client\");\n// Use Node's global object for compatibility with ESLint environments\nconst globalForPrisma = global;\nlet prisma;\nif (!globalForPrisma.__prisma) {\n    globalForPrisma.__prisma = new PrismaClient();\n}\nprisma = globalForPrisma.__prisma;\nmodule.exports = prisma;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uL2xpYi9wcmlzbWEuanMiLCJtYXBwaW5ncyI6IkFBQUEsMkVBQTJFOztBQUMzRSxNQUFNLEVBQUVBLFlBQVksRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQyxzQ0FBZ0I7QUFFakQsc0VBQXNFO0FBQ3RFLE1BQU1DLGtCQUFrQkM7QUFFeEIsSUFBSUM7QUFDSixJQUFJLENBQUNGLGdCQUFnQkcsUUFBUSxFQUFFO0lBQzdCSCxnQkFBZ0JHLFFBQVEsR0FBRyxJQUFJTDtBQUNqQztBQUVBSSxTQUFTRixnQkFBZ0JHLFFBQVE7QUFFakNDLE9BQU9DLE9BQU8sR0FBR0giLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcdW5pdmVyc2l0eS1wbGFubmVyXFxsaWJcXHByaXNtYS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTaGFyZWQgUHJpc21hIGNsaWVudCB0byBhdm9pZCBjcmVhdGluZy9kaXNjb25uZWN0aW5nIGNsaWVudHMgcGVyLXJlcXVlc3RcclxuY29uc3QgeyBQcmlzbWFDbGllbnQgfSA9IHJlcXVpcmUoJ0BwcmlzbWEvY2xpZW50Jyk7XHJcblxyXG4vLyBVc2UgTm9kZSdzIGdsb2JhbCBvYmplY3QgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBFU0xpbnQgZW52aXJvbm1lbnRzXHJcbmNvbnN0IGdsb2JhbEZvclByaXNtYSA9IGdsb2JhbDtcclxuXHJcbmxldCBwcmlzbWE7XHJcbmlmICghZ2xvYmFsRm9yUHJpc21hLl9fcHJpc21hKSB7XHJcbiAgZ2xvYmFsRm9yUHJpc21hLl9fcHJpc21hID0gbmV3IFByaXNtYUNsaWVudCgpO1xyXG59XHJcblxyXG5wcmlzbWEgPSBnbG9iYWxGb3JQcmlzbWEuX19wcmlzbWE7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHByaXNtYTtcclxuIl0sIm5hbWVzIjpbIlByaXNtYUNsaWVudCIsInJlcXVpcmUiLCJnbG9iYWxGb3JQcmlzbWEiLCJnbG9iYWwiLCJwcmlzbWEiLCJfX3ByaXNtYSIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api-node)/./lib/prisma.js\n");

/***/ }),

/***/ "(api-node)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fevents&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cevents%5Cindex.js&middlewareConfigBase64=e30%3D!":
/*!**************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fevents&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cevents%5Cindex.js&middlewareConfigBase64=e30%3D! ***!
  \**************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   handler: () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_api_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/api-utils */ \"(api-node)/./node_modules/next/dist/server/api-utils/index.js\");\n/* harmony import */ var next_dist_server_api_utils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_api_utils__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/route-kind */ \"(api-node)/./node_modules/next/dist/server/route-kind.js\");\n/* harmony import */ var next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/route-modules/pages-api/module.compiled */ \"(api-node)/./node_modules/next/dist/server/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api-node)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _pages_api_events_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pages\\api\\events\\index.js */ \"(api-node)/./pages/api/events/index.js\");\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/dist/server/lib/trace/tracer */ \"(api-node)/./node_modules/next/dist/server/lib/trace/tracer.js\");\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/dist/server/lib/trace/constants */ \"(api-node)/./node_modules/next/dist/server/lib/trace/constants.js\");\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_6__);\n\n\n\n\n// Import the userland code.\n\n\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_3__.hoist)(_pages_api_events_index_js__WEBPACK_IMPORTED_MODULE_4__, 'default'));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_3__.hoist)(_pages_api_events_index_js__WEBPACK_IMPORTED_MODULE_4__, 'config');\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_2__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/events\",\n        pathname: \"/api/events\",\n        // The following aren't used in production.\n        bundlePath: '',\n        filename: ''\n    },\n    userland: _pages_api_events_index_js__WEBPACK_IMPORTED_MODULE_4__,\n    distDir: \".next\" || 0,\n    relativeProjectDir:  false || ''\n});\nasync function handler(req, res, ctx) {\n    let srcPage = \"/api/events\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (false) {}\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return;\n    }\n    const { query, params, prerenderManifest, routerServerContext } = prepareResult;\n    try {\n        const method = req.method || 'GET';\n        const tracer = (0,next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_5__.getTracer)();\n        const activeSpan = tracer.getActiveScopeSpan();\n        const onRequestError = routeModule.instrumentationOnRequestError.bind(routeModule);\n        const invokeRouteModule = async (span)=>routeModule.render(req, res, {\n                query: {\n                    ...query,\n                    ...params\n                },\n                params,\n                allowedRevalidateHeaderKeys: [],\n                multiZoneDraftMode: Boolean(false),\n                trustHostHeader: false,\n                // TODO: get this from from runtime env so manifest\n                // doesn't need to load\n                previewProps: prerenderManifest.preview,\n                propagateError: false,\n                dev: routeModule.isDev,\n                page: \"/api/events\",\n                internalRevalidate: routerServerContext == null ? void 0 : routerServerContext.revalidate,\n                onError: (...args)=>onRequestError(req, ...args)\n            }).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_6__.BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${req.url}`);\n                }\n            });\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await invokeRouteModule(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_6__.BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${req.url}`,\n                    kind: next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_5__.SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, invokeRouteModule));\n        }\n    } catch (err) {\n        // we re-throw in dev to show the error overlay\n        if (routeModule.isDev) {\n            throw err;\n        }\n        // this is technically an invariant as error handling\n        // should be done inside of api-resolver onError\n        (0,next_dist_server_api_utils__WEBPACK_IMPORTED_MODULE_0__.sendError)(res, 500, 'Internal Server Error');\n    } finally{\n        // We don't allow any waitUntil work in pages API routes currently\n        // so if callback is present return with resolved promise since no\n        // pending work\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n    }\n}\n\n//# sourceMappingURL=pages-api.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtcm91dGUtbG9hZGVyL2luZGV4LmpzP2tpbmQ9UEFHRVNfQVBJJnBhZ2U9JTJGYXBpJTJGZXZlbnRzJnByZWZlcnJlZFJlZ2lvbj0mYWJzb2x1dGVQYWdlUGF0aD0uJTJGcGFnZXMlNUNhcGklNUNldmVudHMlNUNpbmRleC5qcyZtaWRkbGV3YXJlQ29uZmlnQmFzZTY0PWUzMCUzRCEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUQ7QUFDQztBQUN1QztBQUNyQztBQUMxRDtBQUMyRDtBQUNhO0FBQ0Y7QUFDdEU7QUFDQSxpRUFBZSx3RUFBSyxDQUFDLHVEQUFRLFlBQVksRUFBQztBQUMxQztBQUNPLGVBQWUsd0VBQUssQ0FBQyx1REFBUTtBQUNwQztBQUNBLHdCQUF3Qix5R0FBbUI7QUFDM0M7QUFDQSxjQUFjLGtFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWTtBQUNaLGFBQWEsT0FBb0MsSUFBSSxDQUFFO0FBQ3ZELHdCQUF3QixNQUF1QztBQUMvRCxDQUFDO0FBQ007QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBcUIsRUFBRSxFQUUxQjtBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3REFBd0Q7QUFDcEU7QUFDQTtBQUNBLHVCQUF1Qiw0RUFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSw2Q0FBNkMsRUFBNkM7QUFDMUYsNENBQTRDLEtBQXdDO0FBQ3BGLGlDQUFpQyxLQUFvQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsZ0ZBQWM7QUFDL0UsK0RBQStELHlDQUF5QztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRLEVBQUUsTUFBTTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGtCQUFrQjtBQUNsQix1Q0FBdUMsUUFBUSxFQUFFLFFBQVE7QUFDekQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNkVBQTZFLGdGQUFjO0FBQzNGLGlDQUFpQyxRQUFRLEVBQUUsUUFBUTtBQUNuRCwwQkFBMEIsdUVBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxxRUFBUztBQUNqQixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2VuZEVycm9yIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvYXBpLXV0aWxzXCI7XG5pbXBvcnQgeyBSb3V0ZUtpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBQYWdlc0FQSVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvcm91dGUtbW9kdWxlcy9wYWdlcy1hcGkvbW9kdWxlLmNvbXBpbGVkXCI7XG5pbXBvcnQgeyBob2lzdCB9IGZyb20gXCJuZXh0L2Rpc3QvYnVpbGQvdGVtcGxhdGVzL2hlbHBlcnNcIjtcbi8vIEltcG9ydCB0aGUgdXNlcmxhbmQgY29kZS5cbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCIuL3BhZ2VzXFxcXGFwaVxcXFxldmVudHNcXFxcaW5kZXguanNcIjtcbmltcG9ydCB7IGdldFRyYWNlciwgU3BhbktpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvdHJhY2UvdHJhY2VyXCI7XG5pbXBvcnQgeyBCYXNlU2VydmVyU3BhbiB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi90cmFjZS9jb25zdGFudHNcIjtcbi8vIFJlLWV4cG9ydCB0aGUgaGFuZGxlciAoc2hvdWxkIGJlIHRoZSBkZWZhdWx0IGV4cG9ydCkuXG5leHBvcnQgZGVmYXVsdCBob2lzdCh1c2VybGFuZCwgJ2RlZmF1bHQnKTtcbi8vIFJlLWV4cG9ydCBjb25maWcuXG5leHBvcnQgY29uc3QgY29uZmlnID0gaG9pc3QodXNlcmxhbmQsICdjb25maWcnKTtcbi8vIENyZWF0ZSBhbmQgZXhwb3J0IHRoZSByb3V0ZSBtb2R1bGUgdGhhdCB3aWxsIGJlIGNvbnN1bWVkLlxuY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgUGFnZXNBUElSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuUEFHRVNfQVBJLFxuICAgICAgICBwYWdlOiBcIi9hcGkvZXZlbnRzXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvZXZlbnRzXCIsXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgYXJlbid0IHVzZWQgaW4gcHJvZHVjdGlvbi5cbiAgICAgICAgYnVuZGxlUGF0aDogJycsXG4gICAgICAgIGZpbGVuYW1lOiAnJ1xuICAgIH0sXG4gICAgdXNlcmxhbmQsXG4gICAgZGlzdERpcjogcHJvY2Vzcy5lbnYuX19ORVhUX1JFTEFUSVZFX0RJU1RfRElSIHx8ICcnLFxuICAgIHJlbGF0aXZlUHJvamVjdERpcjogcHJvY2Vzcy5lbnYuX19ORVhUX1JFTEFUSVZFX1BST0pFQ1RfRElSIHx8ICcnXG59KTtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoYW5kbGVyKHJlcSwgcmVzLCBjdHgpIHtcbiAgICBsZXQgc3JjUGFnZSA9IFwiL2FwaS9ldmVudHNcIjtcbiAgICAvLyB0dXJib3BhY2sgZG9lc24ndCBub3JtYWxpemUgYC9pbmRleGAgaW4gdGhlIHBhZ2UgbmFtZVxuICAgIC8vIHNvIHdlIG5lZWQgdG8gdG8gcHJvY2VzcyBkeW5hbWljIHJvdXRlcyBwcm9wZXJseVxuICAgIC8vIFRPRE86IGZpeCB0dXJib3BhY2sgcHJvdmlkaW5nIGRpZmZlcmluZyB2YWx1ZSBmcm9tIHdlYnBhY2tcbiAgICBpZiAocHJvY2Vzcy5lbnYuVFVSQk9QQUNLKSB7XG4gICAgICAgIHNyY1BhZ2UgPSBzcmNQYWdlLnJlcGxhY2UoL1xcL2luZGV4JC8sICcnKSB8fCAnLyc7XG4gICAgfVxuICAgIGNvbnN0IHByZXBhcmVSZXN1bHQgPSBhd2FpdCByb3V0ZU1vZHVsZS5wcmVwYXJlKHJlcSwgcmVzLCB7XG4gICAgICAgIHNyY1BhZ2VcbiAgICB9KTtcbiAgICBpZiAoIXByZXBhcmVSZXN1bHQpIHtcbiAgICAgICAgcmVzLnN0YXR1c0NvZGUgPSA0MDA7XG4gICAgICAgIHJlcy5lbmQoJ0JhZCBSZXF1ZXN0Jyk7XG4gICAgICAgIGN0eC53YWl0VW50aWwgPT0gbnVsbCA/IHZvaWQgMCA6IGN0eC53YWl0VW50aWwuY2FsbChjdHgsIFByb21pc2UucmVzb2x2ZSgpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IHF1ZXJ5LCBwYXJhbXMsIHByZXJlbmRlck1hbmlmZXN0LCByb3V0ZXJTZXJ2ZXJDb250ZXh0IH0gPSBwcmVwYXJlUmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IHJlcS5tZXRob2QgfHwgJ0dFVCc7XG4gICAgICAgIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcigpO1xuICAgICAgICBjb25zdCBhY3RpdmVTcGFuID0gdHJhY2VyLmdldEFjdGl2ZVNjb3BlU3BhbigpO1xuICAgICAgICBjb25zdCBvblJlcXVlc3RFcnJvciA9IHJvdXRlTW9kdWxlLmluc3RydW1lbnRhdGlvbk9uUmVxdWVzdEVycm9yLmJpbmQocm91dGVNb2R1bGUpO1xuICAgICAgICBjb25zdCBpbnZva2VSb3V0ZU1vZHVsZSA9IGFzeW5jIChzcGFuKT0+cm91dGVNb2R1bGUucmVuZGVyKHJlcSwgcmVzLCB7XG4gICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ucXVlcnksXG4gICAgICAgICAgICAgICAgICAgIC4uLnBhcmFtc1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgICAgIGFsbG93ZWRSZXZhbGlkYXRlSGVhZGVyS2V5czogcHJvY2Vzcy5lbnYuX19ORVhUX0FMTE9XRURfUkVWQUxJREFURV9IRUFERVJTLFxuICAgICAgICAgICAgICAgIG11bHRpWm9uZURyYWZ0TW9kZTogQm9vbGVhbihwcm9jZXNzLmVudi5fX05FWFRfTVVMVElfWk9ORV9EUkFGVF9NT0RFKSxcbiAgICAgICAgICAgICAgICB0cnVzdEhvc3RIZWFkZXI6IHByb2Nlc3MuZW52Ll9fTkVYVF9UUlVTVF9IT1NUX0hFQURFUixcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBnZXQgdGhpcyBmcm9tIGZyb20gcnVudGltZSBlbnYgc28gbWFuaWZlc3RcbiAgICAgICAgICAgICAgICAvLyBkb2Vzbid0IG5lZWQgdG8gbG9hZFxuICAgICAgICAgICAgICAgIHByZXZpZXdQcm9wczogcHJlcmVuZGVyTWFuaWZlc3QucHJldmlldyxcbiAgICAgICAgICAgICAgICBwcm9wYWdhdGVFcnJvcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGV2OiByb3V0ZU1vZHVsZS5pc0RldixcbiAgICAgICAgICAgICAgICBwYWdlOiBcIi9hcGkvZXZlbnRzXCIsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxSZXZhbGlkYXRlOiByb3V0ZXJTZXJ2ZXJDb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiByb3V0ZXJTZXJ2ZXJDb250ZXh0LnJldmFsaWRhdGUsXG4gICAgICAgICAgICAgICAgb25FcnJvcjogKC4uLmFyZ3MpPT5vblJlcXVlc3RFcnJvcihyZXEsIC4uLmFyZ3MpXG4gICAgICAgICAgICB9KS5maW5hbGx5KCgpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFzcGFuKSByZXR1cm47XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHAuc3RhdHVzX2NvZGUnOiByZXMuc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgJ25leHQucnNjJzogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByb290U3BhbkF0dHJpYnV0ZXMgPSB0cmFjZXIuZ2V0Um9vdFNwYW5BdHRyaWJ1dGVzKCk7XG4gICAgICAgICAgICAgICAgLy8gV2Ugd2VyZSB1bmFibGUgdG8gZ2V0IGF0dHJpYnV0ZXMsIHByb2JhYmx5IE9URUwgaXMgbm90IGVuYWJsZWRcbiAgICAgICAgICAgICAgICBpZiAoIXJvb3RTcGFuQXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyb290U3BhbkF0dHJpYnV0ZXMuZ2V0KCduZXh0LnNwYW5fdHlwZScpICE9PSBCYXNlU2VydmVyU3Bhbi5oYW5kbGVSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5leHBlY3RlZCByb290IHNwYW4gdHlwZSAnJHtyb290U3BhbkF0dHJpYnV0ZXMuZ2V0KCduZXh0LnNwYW5fdHlwZScpfScuIFBsZWFzZSByZXBvcnQgdGhpcyBOZXh0LmpzIGlzc3VlIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qc2ApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlID0gcm9vdFNwYW5BdHRyaWJ1dGVzLmdldCgnbmV4dC5yb3V0ZScpO1xuICAgICAgICAgICAgICAgIGlmIChyb3V0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYCR7bWV0aG9kfSAke3JvdXRlfWA7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbmV4dC5yb3V0ZSc6IHJvdXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHAucm91dGUnOiByb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICduZXh0LnNwYW5fbmFtZSc6IG5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4udXBkYXRlTmFtZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzcGFuLnVwZGF0ZU5hbWUoYCR7bWV0aG9kfSAke3JlcS51cmx9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIC8vIFRPRE86IGFjdGl2ZVNwYW4gY29kZSBwYXRoIGlzIGZvciB3aGVuIHdyYXBwZWQgYnlcbiAgICAgICAgLy8gbmV4dC1zZXJ2ZXIgY2FuIGJlIHJlbW92ZWQgd2hlbiB0aGlzIGlzIG5vIGxvbmdlciB1c2VkXG4gICAgICAgIGlmIChhY3RpdmVTcGFuKSB7XG4gICAgICAgICAgICBhd2FpdCBpbnZva2VSb3V0ZU1vZHVsZShhY3RpdmVTcGFuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRyYWNlci53aXRoUHJvcGFnYXRlZENvbnRleHQocmVxLmhlYWRlcnMsICgpPT50cmFjZXIudHJhY2UoQmFzZVNlcnZlclNwYW4uaGFuZGxlUmVxdWVzdCwge1xuICAgICAgICAgICAgICAgICAgICBzcGFuTmFtZTogYCR7bWV0aG9kfSAke3JlcS51cmx9YCxcbiAgICAgICAgICAgICAgICAgICAga2luZDogU3BhbktpbmQuU0VSVkVSLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaHR0cC5tZXRob2QnOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaHR0cC50YXJnZXQnOiByZXEudXJsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBpbnZva2VSb3V0ZU1vZHVsZSkpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIHdlIHJlLXRocm93IGluIGRldiB0byBzaG93IHRoZSBlcnJvciBvdmVybGF5XG4gICAgICAgIGlmIChyb3V0ZU1vZHVsZS5pc0Rldikge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMgaXMgdGVjaG5pY2FsbHkgYW4gaW52YXJpYW50IGFzIGVycm9yIGhhbmRsaW5nXG4gICAgICAgIC8vIHNob3VsZCBiZSBkb25lIGluc2lkZSBvZiBhcGktcmVzb2x2ZXIgb25FcnJvclxuICAgICAgICBzZW5kRXJyb3IocmVzLCA1MDAsICdJbnRlcm5hbCBTZXJ2ZXIgRXJyb3InKTtcbiAgICB9IGZpbmFsbHl7XG4gICAgICAgIC8vIFdlIGRvbid0IGFsbG93IGFueSB3YWl0VW50aWwgd29yayBpbiBwYWdlcyBBUEkgcm91dGVzIGN1cnJlbnRseVxuICAgICAgICAvLyBzbyBpZiBjYWxsYmFjayBpcyBwcmVzZW50IHJldHVybiB3aXRoIHJlc29sdmVkIHByb21pc2Ugc2luY2Ugbm9cbiAgICAgICAgLy8gcGVuZGluZyB3b3JrXG4gICAgICAgIGN0eC53YWl0VW50aWwgPT0gbnVsbCA/IHZvaWQgMCA6IGN0eC53YWl0VW50aWwuY2FsbChjdHgsIFByb21pc2UucmVzb2x2ZSgpKTtcbiAgICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhZ2VzLWFwaS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api-node)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fevents&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cevents%5Cindex.js&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api-node)/./pages/api/events/index.js":
/*!***********************************!*\
  !*** ./pages/api/events/index.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\nconst prisma = __webpack_require__(/*! ../../../lib/prisma */ \"(api-node)/./lib/prisma.js\");\n// Helper: treat date-only strings (YYYY-MM-DD) as a date without local-midnight\n// to avoid timezone shifts when parsed by `new Date(string)`.\nfunction isDateOnly(value) {\n    return typeof value === 'string' && /^\\d{4}-\\d{2}-\\d{2}$/.test(value);\n}\nfunction localDateOnlyString(d) {\n    if (!d) return null;\n    const dt = Object.prototype.toString.call(d) === '[object Date]' ? d : new Date(String(d));\n    if (isNaN(dt.getTime())) return null;\n    const y = dt.getFullYear();\n    const m = String(dt.getMonth() + 1).padStart(2, '0');\n    const day = String(dt.getDate()).padStart(2, '0');\n    return `${y}-${m}-${day}`;\n}\nfunction parseDateForStorage(value) {\n    if (!value) return new Date();\n    if (Object.prototype.toString.call(value) === '[object Date]') return value;\n    const s = String(value);\n    // If it's a pure date like 2025-09-21, anchor it to local midnight to avoid\n    // timezone offsets that could move it to the previous/next day.\n    if (isDateOnly(s)) return new Date(s + 'T00:00:00');\n    const parsed = new Date(s);\n    return isNaN(parsed.getTime()) ? new Date() : parsed;\n}\nfunction isBeforeTodayLocal(date) {\n    if (!date) return false;\n    const d = Object.prototype.toString.call(date) === '[object Date]' ? date : new Date(String(date));\n    if (isNaN(d.getTime())) return false;\n    const now = new Date();\n    const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n    // If the provided date's y/m/d is strictly less than today's y/m/d, it's before today\n    const providedStart = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n    return providedStart < todayStart;\n}\n// Detect common Prisma/DB error messages that indicate the `meta` field\n// is not present/understood by the current schema. Messages vary by\n// driver/version, so be permissive: missing-column messages and the\n// Prisma \"Unknown argument `meta`\" style errors are both handled.\nfunction isPrismaMetaError(msg) {\n    const m = String(msg || '').toLowerCase();\n    if (!m) return false;\n    if (m.includes('does not exist') || m.includes('no such column')) return true;\n    if (m.includes('unknown argument') || m.includes('unknown arg')) return true;\n    // additional safeguard for messages that mention `meta` specifically\n    if (/unknown.*meta/.test(m)) return true;\n    return false;\n}\nasync function handler(req, res) {\n    // Support OPTIONS for simple CORS checks or preflight from tools\n    if (req.method === 'OPTIONS') {\n        res.setHeader('Allow', 'GET,POST,OPTIONS');\n        return res.status(204).end();\n    }\n    // Allow GET to fetch events for a user (used by the client)\n    if (req.method === 'GET') {\n        try {\n            // Prefer server-side auth token user id when available to ensure isolation.\n            // In development, allow a query param for testing. In production, require a valid token.\n            const { getToken } = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! next-auth/jwt */ \"next-auth/jwt\", 23));\n            const token = await getToken({\n                req,\n                secret: process.env.NEXTAUTH_SECRET || 'dev-nextauth-secret'\n            });\n            const tokenUserId = token && token.userId ? token.userId : null;\n            let userId = null;\n            if (tokenUserId) {\n                userId = tokenUserId;\n            } else if ( true && req.query && req.query.userId) {\n                userId = String(req.query.userId);\n            } else {\n                return res.status(401).json({\n                    error: 'Unauthorized'\n                });\n            }\n            // Some local databases may not have the `meta` column (older schema).\n            // Attempt the normal query, but if Prisma complains about a missing column,\n            // retry by explicitly selecting all fields except `meta` so the query succeeds.\n            let events;\n            try {\n                events = await prisma.event.findMany({\n                    where: {\n                        user_id: userId\n                    },\n                    orderBy: {\n                        date: 'desc'\n                    }\n                });\n            } catch (e) {\n                // Detect a missing `meta` field or unknown-argument error and retry\n                // with an explicit select that does not reference meta.\n                const msg = e && e.message ? String(e.message) : '';\n                if (isPrismaMetaError(msg)) {\n                    console.warn('[api/events] retrying findMany without `meta` due to DB schema mismatch');\n                    // Explicitly select fields we know exist (mirror Event model without meta)\n                    events = await prisma.event.findMany({\n                        where: {\n                            user_id: userId\n                        },\n                        orderBy: {\n                            date: 'desc'\n                        },\n                        select: {\n                            id: true,\n                            title: true,\n                            type: true,\n                            location: true,\n                            archived: true,\n                            course_id: true,\n                            template_id: true,\n                            date: true,\n                            time: true,\n                            end_date: true,\n                            description: true,\n                            completed: true,\n                            user_id: true,\n                            created_at: true,\n                            updated_at: true\n                        }\n                    });\n                } else {\n                    throw e;\n                }\n            }\n            // Normalize date fields to local YYYY-MM-DD strings to avoid client-side timezone shifts\n            const normalized = events.map((ev)=>({\n                    ...ev,\n                    date: localDateOnlyString(ev.date)\n                }));\n            return res.status(200).json({\n                events: normalized\n            });\n        } catch (err) {\n            console.error('GET /api/events error', err);\n            return res.status(500).json({\n                error: 'Failed to fetch events'\n            });\n        }\n    }\n    if (req.method === 'POST') {\n        try {\n            const { title, type, courseId, date, time, description, notes, subtasks, attachments, durationMinutes, repeatOption } = req.body;\n            // Debug: log truncated incoming body to help diagnose missing materialize/template flags\n            try {\n                const safeBody = JSON.stringify(req.body, Object.keys(req.body).slice(0, 30)).slice(0, 2000);\n                console.info('[api/events] incoming POST body (truncated):', safeBody);\n            } catch (e) {\n            // ignore stringify errors\n            }\n            // Prefer token-derived user id; otherwise accept provided userId only in development for testing\n            const { getToken } = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! next-auth/jwt */ \"next-auth/jwt\", 23));\n            const token = await getToken({\n                req,\n                secret: process.env.NEXTAUTH_SECRET || 'dev-nextauth-secret'\n            });\n            const tokenUserId = token && token.userId ? token.userId : null;\n            const suppliedUserId = req.body && req.body.userId ? String(req.body.userId) : null;\n            const incomingLocation = req.body && (req.body.location || req.body.room) ? req.body.location || req.body.room : null;\n            console.info('[api/events] POST payload:', JSON.stringify({\n                title,\n                type,\n                courseId,\n                date,\n                time,\n                description,\n                durationMinutes,\n                location: incomingLocation\n            }));\n            const dt = parseDateForStorage(date);\n            // normalize room -> location\n            const location = req.body && (req.body.location || req.body.room) ? req.body.location || req.body.room : null;\n            if (date && isBeforeTodayLocal(dt)) {\n                return res.status(400).json({\n                    code: 'PAST_DATE',\n                    message: 'Cannot create events before today'\n                });\n            }\n            // Resolve user id strictly from token; in development allow supplied userId for testing\n            let resolvedUserId = null;\n            if (tokenUserId) {\n                resolvedUserId = tokenUserId;\n            } else if ( true && suppliedUserId) {\n                const u = await prisma.user.findUnique({\n                    where: {\n                        id: suppliedUserId\n                    }\n                });\n                if (u) resolvedUserId = u.id;\n                else console.warn('[api/events] POST supplied userId not found in development');\n            }\n            if (!resolvedUserId) {\n                return res.status(401).json({\n                    error: 'Unauthorized'\n                });\n            }\n            console.info('[api/events] resolvedUserId:', resolvedUserId);\n            // Persist notes/subtasks/attachments by serializing into description when provided\n            let finalDescription = description || null;\n            if (!finalDescription && notes) finalDescription = String(notes);\n            // If there are structured extras (subtasks/attachments) append them as JSON under a marker\n            const extras = {};\n            if (subtasks) extras.subtasks = subtasks;\n            if (attachments) extras.attachments = attachments;\n            if (Object.keys(extras).length > 0) {\n                try {\n                    const jsonExtras = JSON.stringify(extras);\n                    finalDescription = finalDescription ? finalDescription + '\\n\\n' + jsonExtras : jsonExtras;\n                } catch (e) {}\n            }\n            // Persist meta object if provided (meta is sent separately by clients)\n            const metaToStore = req.body && req.body.meta ? req.body.meta : null;\n            // If the client intended to create a timetable template (a collection of modules)\n            // they can send `isTemplate: true` or `templateModules` in the body. In that case\n            // we should store the template payload and NOT materialize individual Event rows.\n            // Existing behavior when `repeatOption` is provided without `isTemplate` is preserved\n            // (create a template + materialize occurrences as before).\n            let created = null;\n            const isTemplate = !!(req.body && (req.body.isTemplate || Array.isArray(req.body.templateModules)));\n            if (isTemplate) {\n                // Persist the provided modules/config as a JSON payload on EventTemplate\n                const payload = req.body.templateModules || req.body.templatePayload || null;\n                const tplData = {\n                    title: title || null,\n                    course_id: courseId || null,\n                    repeat_option: repeatOption || null,\n                    start_date: dt || null,\n                    payload: payload,\n                    user_id: resolvedUserId\n                };\n                const tpl = await prisma.eventTemplate.create({\n                    data: tplData\n                });\n                created = {\n                    template_id: tpl.id,\n                    template: tpl\n                };\n            } else if (repeatOption) {\n                // New behavior: materialize occurrences only when explicitly requested.\n                const materialize = !!req.body.materialize;\n                const materializeCount = Number.isFinite(Number(req.body.materializeCount)) ? Number(req.body.materializeCount) : null;\n                const materializeUntil = req.body.materializeUntil ? String(req.body.materializeUntil) : null;\n                // If no explicit materialization or template flag provided, refuse to implicitly create a template.\n                // Templates must be created explicitly by the client (isTemplate: true) so templates remain\n                // authoritative and empty by default unless the user chooses to populate them.\n                if (!materialize && !materializeCount && !materializeUntil && !isTemplate) {\n                    return res.status(400).json({\n                        code: 'MUST_SPECIFY_TEMPLATE_OR_MATERIALIZE',\n                        message: 'When creating repeating schedules you must either set isTemplate=true to save a timetable template, or set materialize/materializeCount/materializeUntil to materialize occurrences.'\n                    });\n                }\n                // If we reach here and materialization flags are present, proceed to materialize occurrences.\n                if (materialize || materializeCount || materializeUntil) {\n                    // Helper to compute occurrences (same logic as client-side generateOccurrences)\n                    // Enhanced computeOccurrences: supports optional `byDays` (array of weekday numbers 0-6)\n                    // and `interval` (number of weeks between repeats) supplied by the client in req.body.\n                    // This lets callers request e.g. two instances per week (Mon+Wed) by sending\n                    // { repeatOption: 'weekly', byDays: [1,3], interval: 1, materializeUntil: '2026-01-15' }\n                    const computeOccurrences = (startDate, opt, maxCount = 40)=>{\n                        const out = [];\n                        const start = new Date(startDate);\n                        const year = start.getFullYear();\n                        let end = new Date(year, 0, 15);\n                        if (end <= start) end = new Date(year + 1, 0, 15);\n                        // Allow client to supply an explicit 'until' bound via materializeUntil; caller filters later.\n                        // Interval in weeks (default 1)\n                        const intervalWeeks = Number.isFinite(Number(req.body && req.body.interval)) && Number(req.body.interval) > 0 ? Number(req.body.interval) : 1;\n                        // byDays: optional array of numbers 0 (Sun) .. 6 (Sat)\n                        const byDays = Array.isArray(req.body && req.body.byDays) && req.body.byDays.length > 0 ? req.body.byDays.map((d)=>Number(d)).filter((d)=>Number.isFinite(d) && d >= 0 && d <= 6) : null;\n                        let cursor = new Date(start);\n                        let count = 0;\n                        const pushIf = (d)=>{\n                            if (d <= end && count < maxCount) {\n                                out.push(new Date(d));\n                                count += 1;\n                            }\n                        };\n                        if (opt === 'every-2-3-4') {\n                            while(cursor <= end && count < maxCount){\n                                pushIf(new Date(cursor));\n                                cursor.setDate(cursor.getDate() + 14);\n                            }\n                            return out;\n                        }\n                        // If byDays is provided, iterate day-by-day and select matching weekdays.\n                        if (byDays && byDays.length > 0) {\n                            // We use a week-index to support multi-week intervals: include a day only when\n                            // Math.floor(daysSinceStart/7) % intervalWeeks === 0\n                            const startTime = start.getTime();\n                            let safeGuard = 0;\n                            while(cursor <= end && count < maxCount && safeGuard < 10000){\n                                const daysSinceStart = Math.floor((cursor.getTime() - startTime) / (1000 * 60 * 60 * 24));\n                                const weekIndex = Math.floor(daysSinceStart / 7);\n                                const weekday = cursor.getDay();\n                                if (byDays.includes(weekday) && weekIndex % intervalWeeks === 0) {\n                                    pushIf(new Date(cursor));\n                                }\n                                cursor.setDate(cursor.getDate() + 1);\n                                safeGuard += 1;\n                            }\n                            return out;\n                        }\n                        // Default: weekly stepping by intervalWeeks\n                        let safeGuard = 0;\n                        while(cursor <= end && count < maxCount && safeGuard < 10000){\n                            pushIf(new Date(cursor));\n                            cursor.setDate(cursor.getDate() + 7 * intervalWeeks);\n                            safeGuard += 1;\n                        }\n                        return out;\n                    };\n                    // compute occurrences: respect materializeCount or materializeUntil when provided\n                    const occDates = (()=>{\n                        if (materializeCount && materializeCount > 0) return computeOccurrences(dt, repeatOption, materializeCount);\n                        if (materializeUntil) {\n                            const until = parseDateForStorage(materializeUntil);\n                            const all = computeOccurrences(dt, repeatOption, 365);\n                            return all.filter((d)=>new Date(d).getTime() <= new Date(until).getTime());\n                        }\n                        return computeOccurrences(dt, repeatOption, 40);\n                    })();\n                    // Create template record first and materialize events in a transaction\n                    const templateData = {\n                        title: title || null,\n                        course_id: courseId || null,\n                        repeat_option: repeatOption || null,\n                        start_date: dt,\n                        user_id: resolvedUserId\n                    };\n                    const result = await prisma.$transaction(async (tx)=>{\n                        const tpl = await tx.eventTemplate.create({\n                            data: templateData\n                        });\n                        const createdEvents = [];\n                        for (const d of occDates){\n                            // Attempt to create event including meta; if the DB/schema rejects the column,\n                            // retry without meta so older databases continue to work.\n                            try {\n                                const createData = {\n                                    title: title || '',\n                                    type: type || 'assignment',\n                                    course_id: courseId || null,\n                                    date: d,\n                                    time: time || null,\n                                    description: finalDescription,\n                                    location: location,\n                                    user_id: resolvedUserId ? String(resolvedUserId) : null,\n                                    template_id: tpl.id\n                                };\n                                if (metaToStore !== null) createData.meta = metaToStore;\n                                try {\n                                    console.info('[api/events] creating materialized event for template with data:', JSON.stringify({\n                                        ...createData,\n                                        meta: undefined\n                                    }).slice(0, 2000));\n                                } catch (e) {}\n                                const ev = await tx.event.create({\n                                    data: createData\n                                });\n                                createdEvents.push(ev);\n                            } catch (ee) {\n                                const mmsg = ee && ee.message ? String(ee.message) : '';\n                                if (isPrismaMetaError(mmsg)) {\n                                    // retry without meta\n                                    const ev2 = await tx.event.create({\n                                        data: {\n                                            title: title || '',\n                                            type: type || 'assignment',\n                                            course_id: courseId || null,\n                                            date: d,\n                                            time: time || null,\n                                            description: finalDescription,\n                                            location: location,\n                                            user_id: resolvedUserId ? String(resolvedUserId) : null,\n                                            template_id: tpl.id\n                                        }\n                                    });\n                                    createdEvents.push(ev2);\n                                } else {\n                                    throw ee;\n                                }\n                            }\n                        }\n                        return {\n                            template: tpl,\n                            events: createdEvents\n                        };\n                    });\n                    const materialized = result.events || [];\n                    created = materialized.length ? materialized[0] : null;\n                    if (created) {\n                        created.template_id = result.template.id;\n                        // Do not attach the full materialized array directly to the returned object\n                        // as it will include the `created` item itself and produce circular JSON.\n                        // Instead expose a safe summary: count and a small preview of ids/dates.\n                        try {\n                            created._materialized_count = materialized.length;\n                            created._materialized_preview = materialized.slice(0, 5).map((ev)=>({\n                                    id: ev.id,\n                                    date: localDateOnlyString(ev.date)\n                                }));\n                        } catch (e) {\n                        // ignore preview failures\n                        }\n                    }\n                }\n            } else {\n                // compute end_date from provided endDate or durationMinutes\n                let endDateToStore = null;\n                if (req.body && req.body.endDate) {\n                    endDateToStore = parseDateForStorage(req.body.endDate);\n                } else if (typeof durationMinutes !== 'undefined' && durationMinutes !== null) {\n                    endDateToStore = new Date(parseDateForStorage(date).getTime() + Number(durationMinutes) * 60000);\n                }\n                try {\n                    const createData = {\n                        title,\n                        type: type || 'assignment',\n                        course_id: courseId || null,\n                        date: dt,\n                        time: time || null,\n                        end_date: endDateToStore,\n                        description: finalDescription,\n                        location: location,\n                        user_id: resolvedUserId ? String(resolvedUserId) : null\n                    };\n                    if (metaToStore !== null) createData.meta = metaToStore;\n                    try {\n                        console.info('[api/events] creating single event with data:', JSON.stringify({\n                            ...createData,\n                            meta: undefined\n                        }).slice(0, 2000));\n                    } catch (e) {}\n                    created = await prisma.event.create({\n                        data: createData\n                    });\n                } catch (ee) {\n                    const mmsg = ee && ee.message ? String(ee.message) : '';\n                    if (isPrismaMetaError(mmsg)) {\n                        console.warn('[api/events] retrying create without `meta` due to DB schema mismatch');\n                        created = await prisma.event.create({\n                            data: {\n                                title,\n                                type: type || 'assignment',\n                                course_id: courseId || null,\n                                date: dt,\n                                time: time || null,\n                                end_date: endDateToStore,\n                                description: finalDescription,\n                                location: location,\n                                user_id: resolvedUserId ? String(resolvedUserId) : null\n                            }\n                        });\n                    } else {\n                        throw ee;\n                    }\n                }\n            }\n            // Only persist attachment metadata when we've created an Event (not when creating a template)\n            if (!isTemplate && attachments && Array.isArray(attachments) && attachments.length > 0) {\n                try {\n                    for (const a of attachments){\n                        try {\n                            const safeName = a.name ? String(a.name).replace(/[^\\w.\\-]/g, '_') : 'file-' + Date.now();\n                            await prisma.attachment.create({\n                                data: {\n                                    filename: safeName,\n                                    path: null,\n                                    mime: a.type || null,\n                                    size: a.size || null,\n                                    event_id: created.id\n                                }\n                            });\n                        } catch (e) {\n                            console.warn('attachment meta create failed', e);\n                        }\n                    }\n                } catch (e) {\n                    console.warn('attachments handling failed', e);\n                }\n            }\n            // Return created entity. If we created a template, return it under `template`.\n            try {\n                if (isTemplate && created && created.template) {\n                    return res.status(201).json({\n                        template: created.template\n                    });\n                }\n                const ret = {\n                    ...created,\n                    durationMinutes: typeof durationMinutes !== 'undefined' ? durationMinutes : null\n                };\n                // normalize date to local date-only string\n                if (ret && ret.date) ret.date = localDateOnlyString(ret.date);\n                return res.status(201).json({\n                    event: ret\n                });\n            } catch (e) {\n                if (isTemplate && created && created.template) return res.status(201).json({\n                    template: created.template\n                });\n                return res.status(201).json({\n                    event: {\n                        ...created,\n                        durationMinutes: typeof durationMinutes !== 'undefined' ? durationMinutes : null\n                    }\n                });\n            }\n        } catch (err) {\n            // Log full error with stack for debugging\n            try {\n                console.error('[api/events] POST error:', err && err.stack ? err.stack : err);\n            } catch (e) {\n                console.error('[api/events] POST error (failed to stringify):', err);\n            }\n            // In development, return error details to help debug client-side\n            if (true) {\n                const details = err && (err.message || err.toString()) ? err.message || String(err) : 'unknown error';\n                return res.status(500).json({\n                    error: 'Failed to create event',\n                    details\n                });\n            }\n            return res.status(500).json({\n                error: 'Failed to create event'\n            });\n        }\n    }\n    res.setHeader('Allow', 'GET,POST,OPTIONS');\n    res.status(405).end();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LENBQUMsS0FBS1csSUFBSSxDQUFDO2dCQUFFQyxPQUFPO1lBQXlCO1FBQ2hFO0lBQ0Y7SUFDQWYsSUFBSUUsU0FBUyxDQUFDLFNBQVM7SUFDdkJGLElBQUlHLE1BQU0sQ0FBQyxLQUFLQyxHQUFHO0FBQ3JCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXHVuaXZlcnNpdHktcGxhbm5lclxccGFnZXNcXGFwaVxcZXZlbnRzXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBwcmlzbWEgPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvcHJpc21hJyk7XHJcblxyXG4vLyBIZWxwZXI6IHRyZWF0IGRhdGUtb25seSBzdHJpbmdzIChZWVlZLU1NLUREKSBhcyBhIGRhdGUgd2l0aG91dCBsb2NhbC1taWRuaWdodFxyXG4vLyB0byBhdm9pZCB0aW1lem9uZSBzaGlmdHMgd2hlbiBwYXJzZWQgYnkgYG5ldyBEYXRlKHN0cmluZylgLlxyXG5mdW5jdGlvbiBpc0RhdGVPbmx5KHZhbHVlKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgL15cXGR7NH0tXFxkezJ9LVxcZHsyfSQvLnRlc3QodmFsdWUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBsb2NhbERhdGVPbmx5U3RyaW5nKGQpIHtcclxuICBpZiAoIWQpIHJldHVybiBudWxsO1xyXG4gIGNvbnN0IGR0ID0gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nKSA/IGQgOiBuZXcgRGF0ZShTdHJpbmcoZCkpO1xyXG4gIGlmIChpc05hTihkdC5nZXRUaW1lKCkpKSByZXR1cm4gbnVsbDtcclxuICBjb25zdCB5ID0gZHQuZ2V0RnVsbFllYXIoKTtcclxuICBjb25zdCBtID0gU3RyaW5nKGR0LmdldE1vbnRoKCkgKyAxKS5wYWRTdGFydCgyLCAnMCcpO1xyXG4gIGNvbnN0IGRheSA9IFN0cmluZyhkdC5nZXREYXRlKCkpLnBhZFN0YXJ0KDIsICcwJyk7XHJcbiAgcmV0dXJuIGAke3l9LSR7bX0tJHtkYXl9YDtcclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VEYXRlRm9yU3RvcmFnZSh2YWx1ZSkge1xyXG4gIGlmICghdmFsdWUpIHJldHVybiBuZXcgRGF0ZSgpO1xyXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBEYXRlXScpIHJldHVybiB2YWx1ZTtcclxuICBjb25zdCBzID0gU3RyaW5nKHZhbHVlKTtcclxuICAvLyBJZiBpdCdzIGEgcHVyZSBkYXRlIGxpa2UgMjAyNS0wOS0yMSwgYW5jaG9yIGl0IHRvIGxvY2FsIG1pZG5pZ2h0IHRvIGF2b2lkXHJcbiAgLy8gdGltZXpvbmUgb2Zmc2V0cyB0aGF0IGNvdWxkIG1vdmUgaXQgdG8gdGhlIHByZXZpb3VzL25leHQgZGF5LlxyXG4gIGlmIChpc0RhdGVPbmx5KHMpKSByZXR1cm4gbmV3IERhdGUocyArICdUMDA6MDA6MDAnKTtcclxuICBjb25zdCBwYXJzZWQgPSBuZXcgRGF0ZShzKTtcclxuICByZXR1cm4gaXNOYU4ocGFyc2VkLmdldFRpbWUoKSkgPyBuZXcgRGF0ZSgpIDogcGFyc2VkO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0JlZm9yZVRvZGF5TG9jYWwoZGF0ZSkge1xyXG4gIGlmICghZGF0ZSkgcmV0dXJuIGZhbHNlO1xyXG4gIGNvbnN0IGQgPSAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGUpID09PSAnW29iamVjdCBEYXRlXScpID8gZGF0ZSA6IG5ldyBEYXRlKFN0cmluZyhkYXRlKSk7XHJcbiAgaWYgKGlzTmFOKGQuZ2V0VGltZSgpKSkgcmV0dXJuIGZhbHNlO1xyXG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XHJcbiAgY29uc3QgdG9kYXlTdGFydCA9IG5ldyBEYXRlKG5vdy5nZXRGdWxsWWVhcigpLCBub3cuZ2V0TW9udGgoKSwgbm93LmdldERhdGUoKSk7XHJcbiAgLy8gSWYgdGhlIHByb3ZpZGVkIGRhdGUncyB5L20vZCBpcyBzdHJpY3RseSBsZXNzIHRoYW4gdG9kYXkncyB5L20vZCwgaXQncyBiZWZvcmUgdG9kYXlcclxuICBjb25zdCBwcm92aWRlZFN0YXJ0ID0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCBkLmdldE1vbnRoKCksIGQuZ2V0RGF0ZSgpKTtcclxuICByZXR1cm4gcHJvdmlkZWRTdGFydCA8IHRvZGF5U3RhcnQ7XHJcbn1cclxuXHJcbi8vIERldGVjdCBjb21tb24gUHJpc21hL0RCIGVycm9yIG1lc3NhZ2VzIHRoYXQgaW5kaWNhdGUgdGhlIGBtZXRhYCBmaWVsZFxyXG4vLyBpcyBub3QgcHJlc2VudC91bmRlcnN0b29kIGJ5IHRoZSBjdXJyZW50IHNjaGVtYS4gTWVzc2FnZXMgdmFyeSBieVxyXG4vLyBkcml2ZXIvdmVyc2lvbiwgc28gYmUgcGVybWlzc2l2ZTogbWlzc2luZy1jb2x1bW4gbWVzc2FnZXMgYW5kIHRoZVxyXG4vLyBQcmlzbWEgXCJVbmtub3duIGFyZ3VtZW50IGBtZXRhYFwiIHN0eWxlIGVycm9ycyBhcmUgYm90aCBoYW5kbGVkLlxyXG5mdW5jdGlvbiBpc1ByaXNtYU1ldGFFcnJvcihtc2cpIHtcclxuICBjb25zdCBtID0gU3RyaW5nKG1zZyB8fCAnJykudG9Mb3dlckNhc2UoKTtcclxuICBpZiAoIW0pIHJldHVybiBmYWxzZTtcclxuICBpZiAobS5pbmNsdWRlcygnZG9lcyBub3QgZXhpc3QnKSB8fCBtLmluY2x1ZGVzKCdubyBzdWNoIGNvbHVtbicpKSByZXR1cm4gdHJ1ZTtcclxuICBpZiAobS5pbmNsdWRlcygndW5rbm93biBhcmd1bWVudCcpIHx8IG0uaW5jbHVkZXMoJ3Vua25vd24gYXJnJykpIHJldHVybiB0cnVlO1xyXG4gIC8vIGFkZGl0aW9uYWwgc2FmZWd1YXJkIGZvciBtZXNzYWdlcyB0aGF0IG1lbnRpb24gYG1ldGFgIHNwZWNpZmljYWxseVxyXG4gIGlmICgvdW5rbm93bi4qbWV0YS8udGVzdChtKSkgcmV0dXJuIHRydWU7XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBoYW5kbGVyKHJlcSwgcmVzKSB7XHJcbiAgLy8gU3VwcG9ydCBPUFRJT05TIGZvciBzaW1wbGUgQ09SUyBjaGVja3Mgb3IgcHJlZmxpZ2h0IGZyb20gdG9vbHNcclxuICBpZiAocmVxLm1ldGhvZCA9PT0gJ09QVElPTlMnKSB7XHJcbiAgICByZXMuc2V0SGVhZGVyKCdBbGxvdycsICdHRVQsUE9TVCxPUFRJT05TJyk7XHJcbiAgICByZXR1cm4gcmVzLnN0YXR1cygyMDQpLmVuZCgpO1xyXG4gIH1cclxuXHJcbiAgLy8gQWxsb3cgR0VUIHRvIGZldGNoIGV2ZW50cyBmb3IgYSB1c2VyICh1c2VkIGJ5IHRoZSBjbGllbnQpXHJcbiAgaWYgKHJlcS5tZXRob2QgPT09ICdHRVQnKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBQcmVmZXIgc2VydmVyLXNpZGUgYXV0aCB0b2tlbiB1c2VyIGlkIHdoZW4gYXZhaWxhYmxlIHRvIGVuc3VyZSBpc29sYXRpb24uXHJcbiAgICAgIC8vIEluIGRldmVsb3BtZW50LCBhbGxvdyBhIHF1ZXJ5IHBhcmFtIGZvciB0ZXN0aW5nLiBJbiBwcm9kdWN0aW9uLCByZXF1aXJlIGEgdmFsaWQgdG9rZW4uXHJcbiAgICAgIGNvbnN0IHsgZ2V0VG9rZW4gfSA9IGF3YWl0IGltcG9ydCgnbmV4dC1hdXRoL2p3dCcpO1xyXG4gICAgICBjb25zdCB0b2tlbiA9IGF3YWl0IGdldFRva2VuKHsgcmVxLCBzZWNyZXQ6IHByb2Nlc3MuZW52Lk5FWFRBVVRIX1NFQ1JFVCB8fCAnZGV2LW5leHRhdXRoLXNlY3JldCcgfSk7XHJcbiAgICAgIGNvbnN0IHRva2VuVXNlcklkID0gdG9rZW4gJiYgdG9rZW4udXNlcklkID8gdG9rZW4udXNlcklkIDogbnVsbDtcclxuICAgICAgbGV0IHVzZXJJZCA9IG51bGw7XHJcbiAgICAgIGlmICh0b2tlblVzZXJJZCkge1xyXG4gICAgICAgIHVzZXJJZCA9IHRva2VuVXNlcklkO1xyXG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmIHJlcS5xdWVyeSAmJiByZXEucXVlcnkudXNlcklkKSB7XHJcbiAgICAgICAgdXNlcklkID0gU3RyaW5nKHJlcS5xdWVyeS51c2VySWQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwMSkuanNvbih7IGVycm9yOiAnVW5hdXRob3JpemVkJyB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU29tZSBsb2NhbCBkYXRhYmFzZXMgbWF5IG5vdCBoYXZlIHRoZSBgbWV0YWAgY29sdW1uIChvbGRlciBzY2hlbWEpLlxyXG4gICAgICAvLyBBdHRlbXB0IHRoZSBub3JtYWwgcXVlcnksIGJ1dCBpZiBQcmlzbWEgY29tcGxhaW5zIGFib3V0IGEgbWlzc2luZyBjb2x1bW4sXHJcbiAgICAgIC8vIHJldHJ5IGJ5IGV4cGxpY2l0bHkgc2VsZWN0aW5nIGFsbCBmaWVsZHMgZXhjZXB0IGBtZXRhYCBzbyB0aGUgcXVlcnkgc3VjY2VlZHMuXHJcbiAgICAgIGxldCBldmVudHM7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgZXZlbnRzID0gYXdhaXQgcHJpc21hLmV2ZW50LmZpbmRNYW55KHsgd2hlcmU6IHsgdXNlcl9pZDogdXNlcklkIH0sIG9yZGVyQnk6IHsgZGF0ZTogJ2Rlc2MnIH0gfSk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAvLyBEZXRlY3QgYSBtaXNzaW5nIGBtZXRhYCBmaWVsZCBvciB1bmtub3duLWFyZ3VtZW50IGVycm9yIGFuZCByZXRyeVxyXG4gICAgICAgIC8vIHdpdGggYW4gZXhwbGljaXQgc2VsZWN0IHRoYXQgZG9lcyBub3QgcmVmZXJlbmNlIG1ldGEuXHJcbiAgICAgICAgY29uc3QgbXNnID0gZSAmJiBlLm1lc3NhZ2UgPyBTdHJpbmcoZS5tZXNzYWdlKSA6ICcnO1xyXG4gICAgICAgIGlmIChpc1ByaXNtYU1ldGFFcnJvcihtc2cpKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1thcGkvZXZlbnRzXSByZXRyeWluZyBmaW5kTWFueSB3aXRob3V0IGBtZXRhYCBkdWUgdG8gREIgc2NoZW1hIG1pc21hdGNoJyk7XHJcbiAgICAgICAgICAvLyBFeHBsaWNpdGx5IHNlbGVjdCBmaWVsZHMgd2Uga25vdyBleGlzdCAobWlycm9yIEV2ZW50IG1vZGVsIHdpdGhvdXQgbWV0YSlcclxuICAgICAgICAgIGV2ZW50cyA9IGF3YWl0IHByaXNtYS5ldmVudC5maW5kTWFueSh7XHJcbiAgICAgICAgICAgIHdoZXJlOiB7IHVzZXJfaWQ6IHVzZXJJZCB9LFxyXG4gICAgICAgICAgICBvcmRlckJ5OiB7IGRhdGU6ICdkZXNjJyB9LFxyXG4gICAgICAgICAgICBzZWxlY3Q6IHtcclxuICAgICAgICAgICAgICBpZDogdHJ1ZSxcclxuICAgICAgICAgICAgICB0aXRsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICB0eXBlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIGxvY2F0aW9uOiB0cnVlLFxyXG4gICAgICAgICAgICAgIGFyY2hpdmVkOiB0cnVlLFxyXG4gICAgICAgICAgICAgIGNvdXJzZV9pZDogdHJ1ZSxcclxuICAgICAgICAgICAgICB0ZW1wbGF0ZV9pZDogdHJ1ZSxcclxuICAgICAgICAgICAgICBkYXRlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIHRpbWU6IHRydWUsXHJcbiAgICAgICAgICAgICAgZW5kX2RhdGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHRydWUsXHJcbiAgICAgICAgICAgICAgY29tcGxldGVkOiB0cnVlLFxyXG4gICAgICAgICAgICAgIHVzZXJfaWQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgY3JlYXRlZF9hdDogdHJ1ZSxcclxuICAgICAgICAgICAgICB1cGRhdGVkX2F0OiB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvLyBOb3JtYWxpemUgZGF0ZSBmaWVsZHMgdG8gbG9jYWwgWVlZWS1NTS1ERCBzdHJpbmdzIHRvIGF2b2lkIGNsaWVudC1zaWRlIHRpbWV6b25lIHNoaWZ0c1xyXG4gICAgICBjb25zdCBub3JtYWxpemVkID0gZXZlbnRzLm1hcChldiA9PiAoeyAuLi5ldiwgZGF0ZTogbG9jYWxEYXRlT25seVN0cmluZyhldi5kYXRlKSB9KSk7XHJcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDIwMCkuanNvbih7IGV2ZW50czogbm9ybWFsaXplZCB9KTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdHRVQgL2FwaS9ldmVudHMgZXJyb3InLCBlcnIpO1xyXG4gICAgICByZXR1cm4gcmVzLnN0YXR1cyg1MDApLmpzb24oeyBlcnJvcjogJ0ZhaWxlZCB0byBmZXRjaCBldmVudHMnIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAocmVxLm1ldGhvZCA9PT0gJ1BPU1QnKSB7XHJcbiAgICB0cnkge1xyXG4gIGNvbnN0IHsgdGl0bGUsIHR5cGUsIGNvdXJzZUlkLCBkYXRlLCB0aW1lLCBkZXNjcmlwdGlvbiwgbm90ZXMsIHN1YnRhc2tzLCBhdHRhY2htZW50cywgZHVyYXRpb25NaW51dGVzLCByZXBlYXRPcHRpb24gfSA9IHJlcS5ib2R5O1xyXG4gIC8vIERlYnVnOiBsb2cgdHJ1bmNhdGVkIGluY29taW5nIGJvZHkgdG8gaGVscCBkaWFnbm9zZSBtaXNzaW5nIG1hdGVyaWFsaXplL3RlbXBsYXRlIGZsYWdzXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHNhZmVCb2R5ID0gSlNPTi5zdHJpbmdpZnkocmVxLmJvZHksIE9iamVjdC5rZXlzKHJlcS5ib2R5KS5zbGljZSgwLCAzMCkpLnNsaWNlKDAsIDIwMDApO1xyXG4gICAgY29uc29sZS5pbmZvKCdbYXBpL2V2ZW50c10gaW5jb21pbmcgUE9TVCBib2R5ICh0cnVuY2F0ZWQpOicsIHNhZmVCb2R5KTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICAvLyBpZ25vcmUgc3RyaW5naWZ5IGVycm9yc1xyXG4gIH1cclxuICAgICAgLy8gUHJlZmVyIHRva2VuLWRlcml2ZWQgdXNlciBpZDsgb3RoZXJ3aXNlIGFjY2VwdCBwcm92aWRlZCB1c2VySWQgb25seSBpbiBkZXZlbG9wbWVudCBmb3IgdGVzdGluZ1xyXG4gICAgICBjb25zdCB7IGdldFRva2VuIH0gPSBhd2FpdCBpbXBvcnQoJ25leHQtYXV0aC9qd3QnKTtcclxuICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCBnZXRUb2tlbih7IHJlcSwgc2VjcmV0OiBwcm9jZXNzLmVudi5ORVhUQVVUSF9TRUNSRVQgfHwgJ2Rldi1uZXh0YXV0aC1zZWNyZXQnIH0pO1xyXG4gICAgICBjb25zdCB0b2tlblVzZXJJZCA9IHRva2VuICYmIHRva2VuLnVzZXJJZCA/IHRva2VuLnVzZXJJZCA6IG51bGw7XHJcbiAgICAgIGNvbnN0IHN1cHBsaWVkVXNlcklkID0gcmVxLmJvZHkgJiYgcmVxLmJvZHkudXNlcklkID8gU3RyaW5nKHJlcS5ib2R5LnVzZXJJZCkgOiBudWxsO1xyXG4gIGNvbnN0IGluY29taW5nTG9jYXRpb24gPSByZXEuYm9keSAmJiAocmVxLmJvZHkubG9jYXRpb24gfHwgcmVxLmJvZHkucm9vbSkgPyAocmVxLmJvZHkubG9jYXRpb24gfHwgcmVxLmJvZHkucm9vbSkgOiBudWxsO1xyXG4gIGNvbnNvbGUuaW5mbygnW2FwaS9ldmVudHNdIFBPU1QgcGF5bG9hZDonLCBKU09OLnN0cmluZ2lmeSh7IHRpdGxlLCB0eXBlLCBjb3Vyc2VJZCwgZGF0ZSwgdGltZSwgZGVzY3JpcHRpb24sIGR1cmF0aW9uTWludXRlcywgbG9jYXRpb246IGluY29taW5nTG9jYXRpb24gfSkpO1xyXG4gIGNvbnN0IGR0ID0gcGFyc2VEYXRlRm9yU3RvcmFnZShkYXRlKTtcclxuICAvLyBub3JtYWxpemUgcm9vbSAtPiBsb2NhdGlvblxyXG4gIGNvbnN0IGxvY2F0aW9uID0gcmVxLmJvZHkgJiYgKHJlcS5ib2R5LmxvY2F0aW9uIHx8IHJlcS5ib2R5LnJvb20pID8gKHJlcS5ib2R5LmxvY2F0aW9uIHx8IHJlcS5ib2R5LnJvb20pIDogbnVsbDtcclxuICAgICAgaWYgKGRhdGUgJiYgaXNCZWZvcmVUb2RheUxvY2FsKGR0KSkge1xyXG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7IGNvZGU6ICdQQVNUX0RBVEUnLCBtZXNzYWdlOiAnQ2Fubm90IGNyZWF0ZSBldmVudHMgYmVmb3JlIHRvZGF5JyB9KTtcclxuICAgICAgfVxyXG4gIC8vIFJlc29sdmUgdXNlciBpZCBzdHJpY3RseSBmcm9tIHRva2VuOyBpbiBkZXZlbG9wbWVudCBhbGxvdyBzdXBwbGllZCB1c2VySWQgZm9yIHRlc3RpbmdcclxuICAgICAgbGV0IHJlc29sdmVkVXNlcklkID0gbnVsbDtcclxuICAgICAgaWYgKHRva2VuVXNlcklkKSB7XHJcbiAgICAgICAgcmVzb2x2ZWRVc2VySWQgPSB0b2tlblVzZXJJZDtcclxuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiBzdXBwbGllZFVzZXJJZCkge1xyXG4gICAgICAgIGNvbnN0IHUgPSBhd2FpdCBwcmlzbWEudXNlci5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IHN1cHBsaWVkVXNlcklkIH0gfSk7XHJcbiAgICAgICAgaWYgKHUpIHJlc29sdmVkVXNlcklkID0gdS5pZDtcclxuICAgICAgICBlbHNlIGNvbnNvbGUud2FybignW2FwaS9ldmVudHNdIFBPU1Qgc3VwcGxpZWQgdXNlcklkIG5vdCBmb3VuZCBpbiBkZXZlbG9wbWVudCcpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghcmVzb2x2ZWRVc2VySWQpIHtcclxuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDEpLmpzb24oeyBlcnJvcjogJ1VuYXV0aG9yaXplZCcgfSk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc29sZS5pbmZvKCdbYXBpL2V2ZW50c10gcmVzb2x2ZWRVc2VySWQ6JywgcmVzb2x2ZWRVc2VySWQpO1xyXG5cclxuICAgICAgLy8gUGVyc2lzdCBub3Rlcy9zdWJ0YXNrcy9hdHRhY2htZW50cyBieSBzZXJpYWxpemluZyBpbnRvIGRlc2NyaXB0aW9uIHdoZW4gcHJvdmlkZWRcclxuICAgICAgbGV0IGZpbmFsRGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbiB8fCBudWxsO1xyXG4gICAgICBpZiAoIWZpbmFsRGVzY3JpcHRpb24gJiYgbm90ZXMpIGZpbmFsRGVzY3JpcHRpb24gPSBTdHJpbmcobm90ZXMpO1xyXG4gICAgICAvLyBJZiB0aGVyZSBhcmUgc3RydWN0dXJlZCBleHRyYXMgKHN1YnRhc2tzL2F0dGFjaG1lbnRzKSBhcHBlbmQgdGhlbSBhcyBKU09OIHVuZGVyIGEgbWFya2VyXHJcbiAgICAgIGNvbnN0IGV4dHJhcyA9IHt9O1xyXG4gICAgICBpZiAoc3VidGFza3MpIGV4dHJhcy5zdWJ0YXNrcyA9IHN1YnRhc2tzO1xyXG4gICAgICBpZiAoYXR0YWNobWVudHMpIGV4dHJhcy5hdHRhY2htZW50cyA9IGF0dGFjaG1lbnRzO1xyXG4gICAgICBpZiAoT2JqZWN0LmtleXMoZXh0cmFzKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IGpzb25FeHRyYXMgPSBKU09OLnN0cmluZ2lmeShleHRyYXMpO1xyXG4gICAgICAgICAgZmluYWxEZXNjcmlwdGlvbiA9IGZpbmFsRGVzY3JpcHRpb24gPyBmaW5hbERlc2NyaXB0aW9uICsgJ1xcblxcbicgKyBqc29uRXh0cmFzIDoganNvbkV4dHJhcztcclxuICAgICAgICB9IGNhdGNoIChlKSB7IC8qIGlnbm9yZSBzZXJpYWxpemF0aW9uIGVycm9ycyAqLyB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFBlcnNpc3QgbWV0YSBvYmplY3QgaWYgcHJvdmlkZWQgKG1ldGEgaXMgc2VudCBzZXBhcmF0ZWx5IGJ5IGNsaWVudHMpXHJcbiAgICAgIGNvbnN0IG1ldGFUb1N0b3JlID0gcmVxLmJvZHkgJiYgcmVxLmJvZHkubWV0YSA/IHJlcS5ib2R5Lm1ldGEgOiBudWxsO1xyXG5cclxuICAgICAgLy8gSWYgdGhlIGNsaWVudCBpbnRlbmRlZCB0byBjcmVhdGUgYSB0aW1ldGFibGUgdGVtcGxhdGUgKGEgY29sbGVjdGlvbiBvZiBtb2R1bGVzKVxyXG4gICAgICAvLyB0aGV5IGNhbiBzZW5kIGBpc1RlbXBsYXRlOiB0cnVlYCBvciBgdGVtcGxhdGVNb2R1bGVzYCBpbiB0aGUgYm9keS4gSW4gdGhhdCBjYXNlXHJcbiAgICAgIC8vIHdlIHNob3VsZCBzdG9yZSB0aGUgdGVtcGxhdGUgcGF5bG9hZCBhbmQgTk9UIG1hdGVyaWFsaXplIGluZGl2aWR1YWwgRXZlbnQgcm93cy5cclxuICAgICAgLy8gRXhpc3RpbmcgYmVoYXZpb3Igd2hlbiBgcmVwZWF0T3B0aW9uYCBpcyBwcm92aWRlZCB3aXRob3V0IGBpc1RlbXBsYXRlYCBpcyBwcmVzZXJ2ZWRcclxuICAgICAgLy8gKGNyZWF0ZSBhIHRlbXBsYXRlICsgbWF0ZXJpYWxpemUgb2NjdXJyZW5jZXMgYXMgYmVmb3JlKS5cclxuICAgICAgbGV0IGNyZWF0ZWQgPSBudWxsO1xyXG4gICAgICBjb25zdCBpc1RlbXBsYXRlID0gISEocmVxLmJvZHkgJiYgKHJlcS5ib2R5LmlzVGVtcGxhdGUgfHwgQXJyYXkuaXNBcnJheShyZXEuYm9keS50ZW1wbGF0ZU1vZHVsZXMpKSk7XHJcbiAgICAgIGlmIChpc1RlbXBsYXRlKSB7XHJcbiAgICAgICAgLy8gUGVyc2lzdCB0aGUgcHJvdmlkZWQgbW9kdWxlcy9jb25maWcgYXMgYSBKU09OIHBheWxvYWQgb24gRXZlbnRUZW1wbGF0ZVxyXG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSByZXEuYm9keS50ZW1wbGF0ZU1vZHVsZXMgfHwgcmVxLmJvZHkudGVtcGxhdGVQYXlsb2FkIHx8IG51bGw7XHJcbiAgICAgICAgY29uc3QgdHBsRGF0YSA9IHtcclxuICAgICAgICAgIHRpdGxlOiB0aXRsZSB8fCBudWxsLFxyXG4gICAgICAgICAgY291cnNlX2lkOiBjb3Vyc2VJZCB8fCBudWxsLFxyXG4gICAgICAgICAgcmVwZWF0X29wdGlvbjogcmVwZWF0T3B0aW9uIHx8IG51bGwsXHJcbiAgICAgICAgICBzdGFydF9kYXRlOiBkdCB8fCBudWxsLFxyXG4gICAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcclxuICAgICAgICAgIHVzZXJfaWQ6IHJlc29sdmVkVXNlcklkXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCB0cGwgPSBhd2FpdCBwcmlzbWEuZXZlbnRUZW1wbGF0ZS5jcmVhdGUoeyBkYXRhOiB0cGxEYXRhIH0pO1xyXG4gICAgICAgIGNyZWF0ZWQgPSB7IHRlbXBsYXRlX2lkOiB0cGwuaWQsIHRlbXBsYXRlOiB0cGwgfTtcclxuICAgICAgfSBlbHNlIGlmIChyZXBlYXRPcHRpb24pIHtcclxuICAgICAgICAvLyBOZXcgYmVoYXZpb3I6IG1hdGVyaWFsaXplIG9jY3VycmVuY2VzIG9ubHkgd2hlbiBleHBsaWNpdGx5IHJlcXVlc3RlZC5cclxuICAgICAgICBjb25zdCBtYXRlcmlhbGl6ZSA9ICEhcmVxLmJvZHkubWF0ZXJpYWxpemU7XHJcbiAgICAgICAgY29uc3QgbWF0ZXJpYWxpemVDb3VudCA9IE51bWJlci5pc0Zpbml0ZShOdW1iZXIocmVxLmJvZHkubWF0ZXJpYWxpemVDb3VudCkpID8gTnVtYmVyKHJlcS5ib2R5Lm1hdGVyaWFsaXplQ291bnQpIDogbnVsbDtcclxuICAgICAgICBjb25zdCBtYXRlcmlhbGl6ZVVudGlsID0gcmVxLmJvZHkubWF0ZXJpYWxpemVVbnRpbCA/IFN0cmluZyhyZXEuYm9keS5tYXRlcmlhbGl6ZVVudGlsKSA6IG51bGw7XHJcbiAgICAgICAgLy8gSWYgbm8gZXhwbGljaXQgbWF0ZXJpYWxpemF0aW9uIG9yIHRlbXBsYXRlIGZsYWcgcHJvdmlkZWQsIHJlZnVzZSB0byBpbXBsaWNpdGx5IGNyZWF0ZSBhIHRlbXBsYXRlLlxyXG4gICAgICAgIC8vIFRlbXBsYXRlcyBtdXN0IGJlIGNyZWF0ZWQgZXhwbGljaXRseSBieSB0aGUgY2xpZW50IChpc1RlbXBsYXRlOiB0cnVlKSBzbyB0ZW1wbGF0ZXMgcmVtYWluXHJcbiAgICAgICAgLy8gYXV0aG9yaXRhdGl2ZSBhbmQgZW1wdHkgYnkgZGVmYXVsdCB1bmxlc3MgdGhlIHVzZXIgY2hvb3NlcyB0byBwb3B1bGF0ZSB0aGVtLlxyXG4gICAgICAgIGlmICghbWF0ZXJpYWxpemUgJiYgIW1hdGVyaWFsaXplQ291bnQgJiYgIW1hdGVyaWFsaXplVW50aWwgJiYgIWlzVGVtcGxhdGUpIHtcclxuICAgICAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7IGNvZGU6ICdNVVNUX1NQRUNJRllfVEVNUExBVEVfT1JfTUFURVJJQUxJWkUnLCBtZXNzYWdlOiAnV2hlbiBjcmVhdGluZyByZXBlYXRpbmcgc2NoZWR1bGVzIHlvdSBtdXN0IGVpdGhlciBzZXQgaXNUZW1wbGF0ZT10cnVlIHRvIHNhdmUgYSB0aW1ldGFibGUgdGVtcGxhdGUsIG9yIHNldCBtYXRlcmlhbGl6ZS9tYXRlcmlhbGl6ZUNvdW50L21hdGVyaWFsaXplVW50aWwgdG8gbWF0ZXJpYWxpemUgb2NjdXJyZW5jZXMuJyB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElmIHdlIHJlYWNoIGhlcmUgYW5kIG1hdGVyaWFsaXphdGlvbiBmbGFncyBhcmUgcHJlc2VudCwgcHJvY2VlZCB0byBtYXRlcmlhbGl6ZSBvY2N1cnJlbmNlcy5cclxuICBpZiAobWF0ZXJpYWxpemUgfHwgbWF0ZXJpYWxpemVDb3VudCB8fCBtYXRlcmlhbGl6ZVVudGlsKSB7XHJcbiAgICAgICAgICAvLyBIZWxwZXIgdG8gY29tcHV0ZSBvY2N1cnJlbmNlcyAoc2FtZSBsb2dpYyBhcyBjbGllbnQtc2lkZSBnZW5lcmF0ZU9jY3VycmVuY2VzKVxyXG4gICAgICAgICAgLy8gRW5oYW5jZWQgY29tcHV0ZU9jY3VycmVuY2VzOiBzdXBwb3J0cyBvcHRpb25hbCBgYnlEYXlzYCAoYXJyYXkgb2Ygd2Vla2RheSBudW1iZXJzIDAtNilcclxuICAgICAgICAgIC8vIGFuZCBgaW50ZXJ2YWxgIChudW1iZXIgb2Ygd2Vla3MgYmV0d2VlbiByZXBlYXRzKSBzdXBwbGllZCBieSB0aGUgY2xpZW50IGluIHJlcS5ib2R5LlxyXG4gICAgICAgICAgLy8gVGhpcyBsZXRzIGNhbGxlcnMgcmVxdWVzdCBlLmcuIHR3byBpbnN0YW5jZXMgcGVyIHdlZWsgKE1vbitXZWQpIGJ5IHNlbmRpbmdcclxuICAgICAgICAgIC8vIHsgcmVwZWF0T3B0aW9uOiAnd2Vla2x5JywgYnlEYXlzOiBbMSwzXSwgaW50ZXJ2YWw6IDEsIG1hdGVyaWFsaXplVW50aWw6ICcyMDI2LTAxLTE1JyB9XHJcbiAgICAgICAgICBjb25zdCBjb21wdXRlT2NjdXJyZW5jZXMgPSAoc3RhcnREYXRlLCBvcHQsIG1heENvdW50ID0gNDApID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgb3V0ID0gW107XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gbmV3IERhdGUoc3RhcnREYXRlKTtcclxuICAgICAgICAgICAgY29uc3QgeWVhciA9IHN0YXJ0LmdldEZ1bGxZZWFyKCk7XHJcbiAgICAgICAgICAgIGxldCBlbmQgPSBuZXcgRGF0ZSh5ZWFyLCAwLCAxNSk7XHJcbiAgICAgICAgICAgIGlmIChlbmQgPD0gc3RhcnQpIGVuZCA9IG5ldyBEYXRlKHllYXIgKyAxLCAwLCAxNSk7XHJcblxyXG4gICAgICAgICAgICAvLyBBbGxvdyBjbGllbnQgdG8gc3VwcGx5IGFuIGV4cGxpY2l0ICd1bnRpbCcgYm91bmQgdmlhIG1hdGVyaWFsaXplVW50aWw7IGNhbGxlciBmaWx0ZXJzIGxhdGVyLlxyXG4gICAgICAgICAgICAvLyBJbnRlcnZhbCBpbiB3ZWVrcyAoZGVmYXVsdCAxKVxyXG4gICAgICAgICAgICBjb25zdCBpbnRlcnZhbFdlZWtzID0gTnVtYmVyLmlzRmluaXRlKE51bWJlcihyZXEuYm9keSAmJiByZXEuYm9keS5pbnRlcnZhbCkpICYmIE51bWJlcihyZXEuYm9keS5pbnRlcnZhbCkgPiAwID8gTnVtYmVyKHJlcS5ib2R5LmludGVydmFsKSA6IDE7XHJcbiAgICAgICAgICAgIC8vIGJ5RGF5czogb3B0aW9uYWwgYXJyYXkgb2YgbnVtYmVycyAwIChTdW4pIC4uIDYgKFNhdClcclxuICAgICAgICAgICAgY29uc3QgYnlEYXlzID0gQXJyYXkuaXNBcnJheShyZXEuYm9keSAmJiByZXEuYm9keS5ieURheXMpICYmIHJlcS5ib2R5LmJ5RGF5cy5sZW5ndGggPiAwID8gKHJlcS5ib2R5LmJ5RGF5cy5tYXAoZCA9PiBOdW1iZXIoZCkpLmZpbHRlcihkID0+IE51bWJlci5pc0Zpbml0ZShkKSAmJiBkID49IDAgJiYgZCA8PSA2KSkgOiBudWxsO1xyXG5cclxuICAgICAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBEYXRlKHN0YXJ0KTtcclxuICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHB1c2hJZiA9IChkKSA9PiB7IGlmIChkIDw9IGVuZCAmJiBjb3VudCA8IG1heENvdW50KSB7IG91dC5wdXNoKG5ldyBEYXRlKGQpKTsgY291bnQgKz0gMTsgfSB9O1xyXG5cclxuICAgICAgICAgICAgaWYgKG9wdCA9PT0gJ2V2ZXJ5LTItMy00Jykge1xyXG4gICAgICAgICAgICAgIHdoaWxlIChjdXJzb3IgPD0gZW5kICYmIGNvdW50IDwgbWF4Q291bnQpIHsgcHVzaElmKG5ldyBEYXRlKGN1cnNvcikpOyBjdXJzb3Iuc2V0RGF0ZShjdXJzb3IuZ2V0RGF0ZSgpICsgMTQpOyB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuIG91dDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYgYnlEYXlzIGlzIHByb3ZpZGVkLCBpdGVyYXRlIGRheS1ieS1kYXkgYW5kIHNlbGVjdCBtYXRjaGluZyB3ZWVrZGF5cy5cclxuICAgICAgICAgICAgaWYgKGJ5RGF5cyAmJiBieURheXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHdlZWstaW5kZXggdG8gc3VwcG9ydCBtdWx0aS13ZWVrIGludGVydmFsczogaW5jbHVkZSBhIGRheSBvbmx5IHdoZW5cclxuICAgICAgICAgICAgICAvLyBNYXRoLmZsb29yKGRheXNTaW5jZVN0YXJ0LzcpICUgaW50ZXJ2YWxXZWVrcyA9PT0gMFxyXG4gICAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHN0YXJ0LmdldFRpbWUoKTtcclxuICAgICAgICAgICAgICBsZXQgc2FmZUd1YXJkID0gMDtcclxuICAgICAgICAgICAgICB3aGlsZSAoY3Vyc29yIDw9IGVuZCAmJiBjb3VudCA8IG1heENvdW50ICYmIHNhZmVHdWFyZCA8IDEwMDAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXlzU2luY2VTdGFydCA9IE1hdGguZmxvb3IoKGN1cnNvci5nZXRUaW1lKCkgLSBzdGFydFRpbWUpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHdlZWtJbmRleCA9IE1hdGguZmxvb3IoZGF5c1NpbmNlU3RhcnQgLyA3KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHdlZWtkYXkgPSBjdXJzb3IuZ2V0RGF5KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnlEYXlzLmluY2x1ZGVzKHdlZWtkYXkpICYmICh3ZWVrSW5kZXggJSBpbnRlcnZhbFdlZWtzKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICBwdXNoSWYobmV3IERhdGUoY3Vyc29yKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdXJzb3Iuc2V0RGF0ZShjdXJzb3IuZ2V0RGF0ZSgpICsgMSk7XHJcbiAgICAgICAgICAgICAgICBzYWZlR3VhcmQgKz0gMTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuIG91dDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRGVmYXVsdDogd2Vla2x5IHN0ZXBwaW5nIGJ5IGludGVydmFsV2Vla3NcclxuICAgICAgICAgICAgbGV0IHNhZmVHdWFyZCA9IDA7XHJcbiAgICAgICAgICAgIHdoaWxlIChjdXJzb3IgPD0gZW5kICYmIGNvdW50IDwgbWF4Q291bnQgJiYgc2FmZUd1YXJkIDwgMTAwMDApIHtcclxuICAgICAgICAgICAgICBwdXNoSWYobmV3IERhdGUoY3Vyc29yKSk7XHJcbiAgICAgICAgICAgICAgY3Vyc29yLnNldERhdGUoY3Vyc29yLmdldERhdGUoKSArIDcgKiBpbnRlcnZhbFdlZWtzKTtcclxuICAgICAgICAgICAgICBzYWZlR3VhcmQgKz0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAvLyBjb21wdXRlIG9jY3VycmVuY2VzOiByZXNwZWN0IG1hdGVyaWFsaXplQ291bnQgb3IgbWF0ZXJpYWxpemVVbnRpbCB3aGVuIHByb3ZpZGVkXHJcbiAgICAgICAgICBjb25zdCBvY2NEYXRlcyA9ICgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChtYXRlcmlhbGl6ZUNvdW50ICYmIG1hdGVyaWFsaXplQ291bnQgPiAwKSByZXR1cm4gY29tcHV0ZU9jY3VycmVuY2VzKGR0LCByZXBlYXRPcHRpb24sIG1hdGVyaWFsaXplQ291bnQpO1xyXG4gICAgICAgICAgICBpZiAobWF0ZXJpYWxpemVVbnRpbCkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHVudGlsID0gcGFyc2VEYXRlRm9yU3RvcmFnZShtYXRlcmlhbGl6ZVVudGlsKTtcclxuICAgICAgICAgICAgICBjb25zdCBhbGwgPSBjb21wdXRlT2NjdXJyZW5jZXMoZHQsIHJlcGVhdE9wdGlvbiwgMzY1KTtcclxuICAgICAgICAgICAgICByZXR1cm4gYWxsLmZpbHRlcihkID0+IG5ldyBEYXRlKGQpLmdldFRpbWUoKSA8PSBuZXcgRGF0ZSh1bnRpbCkuZ2V0VGltZSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY29tcHV0ZU9jY3VycmVuY2VzKGR0LCByZXBlYXRPcHRpb24sIDQwKTtcclxuICAgICAgICAgIH0pKCk7XHJcblxyXG4gICAgICAgICAgLy8gQ3JlYXRlIHRlbXBsYXRlIHJlY29yZCBmaXJzdCBhbmQgbWF0ZXJpYWxpemUgZXZlbnRzIGluIGEgdHJhbnNhY3Rpb25cclxuICAgICAgICAgIGNvbnN0IHRlbXBsYXRlRGF0YSA9IHtcclxuICAgICAgICAgICAgdGl0bGU6IHRpdGxlIHx8IG51bGwsXHJcbiAgICAgICAgICAgIGNvdXJzZV9pZDogY291cnNlSWQgfHwgbnVsbCxcclxuICAgICAgICAgICAgcmVwZWF0X29wdGlvbjogcmVwZWF0T3B0aW9uIHx8IG51bGwsXHJcbiAgICAgICAgICAgIHN0YXJ0X2RhdGU6IGR0LFxyXG4gICAgICAgICAgICB1c2VyX2lkOiByZXNvbHZlZFVzZXJJZFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByaXNtYS4kdHJhbnNhY3Rpb24oYXN5bmMgKHR4KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRwbCA9IGF3YWl0IHR4LmV2ZW50VGVtcGxhdGUuY3JlYXRlKHsgZGF0YTogdGVtcGxhdGVEYXRhIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBjcmVhdGVkRXZlbnRzID0gW107XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZCBvZiBvY2NEYXRlcykge1xyXG4gICAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gY3JlYXRlIGV2ZW50IGluY2x1ZGluZyBtZXRhOyBpZiB0aGUgREIvc2NoZW1hIHJlamVjdHMgdGhlIGNvbHVtbixcclxuICAgICAgICAgICAgICAvLyByZXRyeSB3aXRob3V0IG1ldGEgc28gb2xkZXIgZGF0YWJhc2VzIGNvbnRpbnVlIHRvIHdvcmsuXHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3JlYXRlRGF0YSA9IHtcclxuICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlIHx8ICcnLFxyXG4gICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlIHx8ICdhc3NpZ25tZW50JyxcclxuICAgICAgICAgICAgICAgICAgY291cnNlX2lkOiBjb3Vyc2VJZCB8fCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICBkYXRlOiBkLFxyXG4gICAgICAgICAgICAgICAgICB0aW1lOiB0aW1lIHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBmaW5hbERlc2NyaXB0aW9uLFxyXG4gICAgICAgICAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXHJcbiAgICAgICAgICAgICAgICAgIHVzZXJfaWQ6IHJlc29sdmVkVXNlcklkID8gU3RyaW5nKHJlc29sdmVkVXNlcklkKSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgIHRlbXBsYXRlX2lkOiB0cGwuaWRcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpZiAobWV0YVRvU3RvcmUgIT09IG51bGwpIGNyZWF0ZURhdGEubWV0YSA9IG1ldGFUb1N0b3JlO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHsgY29uc29sZS5pbmZvKCdbYXBpL2V2ZW50c10gY3JlYXRpbmcgbWF0ZXJpYWxpemVkIGV2ZW50IGZvciB0ZW1wbGF0ZSB3aXRoIGRhdGE6JywgSlNPTi5zdHJpbmdpZnkoeyAuLi5jcmVhdGVEYXRhLCBtZXRhOiB1bmRlZmluZWQgfSkuc2xpY2UoMCwyMDAwKSk7IH0gY2F0Y2goZSkge31cclxuICAgICAgICAgICAgICAgIGNvbnN0IGV2ID0gYXdhaXQgdHguZXZlbnQuY3JlYXRlKHsgZGF0YTogY3JlYXRlRGF0YSB9KTtcclxuICAgICAgICAgICAgICAgIGNyZWF0ZWRFdmVudHMucHVzaChldik7XHJcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1tc2cgPSBlZSAmJiBlZS5tZXNzYWdlID8gU3RyaW5nKGVlLm1lc3NhZ2UpIDogJyc7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmlzbWFNZXRhRXJyb3IobW1zZykpIHtcclxuICAgICAgICAgICAgICAgICAgLy8gcmV0cnkgd2l0aG91dCBtZXRhXHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGV2MiA9IGF3YWl0IHR4LmV2ZW50LmNyZWF0ZSh7IGRhdGE6IHtcclxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGUgfHwgJycsXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSB8fCAnYXNzaWdubWVudCcsXHJcbiAgICAgICAgICAgICAgICAgICAgY291cnNlX2lkOiBjb3Vyc2VJZCB8fCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGU6IGQsXHJcbiAgICAgICAgICAgICAgICAgICAgdGltZTogdGltZSB8fCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBmaW5hbERlc2NyaXB0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICB1c2VyX2lkOiByZXNvbHZlZFVzZXJJZCA/IFN0cmluZyhyZXNvbHZlZFVzZXJJZCkgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlX2lkOiB0cGwuaWRcclxuICAgICAgICAgICAgICAgICAgfX0pO1xyXG4gICAgICAgICAgICAgICAgICBjcmVhdGVkRXZlbnRzLnB1c2goZXYyKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIHRocm93IGVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4geyB0ZW1wbGF0ZTogdHBsLCBldmVudHM6IGNyZWF0ZWRFdmVudHMgfTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgY29uc3QgbWF0ZXJpYWxpemVkID0gcmVzdWx0LmV2ZW50cyB8fCBbXTtcclxuICAgICAgICAgIGNyZWF0ZWQgPSBtYXRlcmlhbGl6ZWQubGVuZ3RoID8gbWF0ZXJpYWxpemVkWzBdIDogbnVsbDtcclxuICAgICAgICAgIGlmIChjcmVhdGVkKSB7XHJcbiAgICAgICAgICAgIGNyZWF0ZWQudGVtcGxhdGVfaWQgPSByZXN1bHQudGVtcGxhdGUuaWQ7XHJcbiAgICAgICAgICAgIC8vIERvIG5vdCBhdHRhY2ggdGhlIGZ1bGwgbWF0ZXJpYWxpemVkIGFycmF5IGRpcmVjdGx5IHRvIHRoZSByZXR1cm5lZCBvYmplY3RcclxuICAgICAgICAgICAgLy8gYXMgaXQgd2lsbCBpbmNsdWRlIHRoZSBgY3JlYXRlZGAgaXRlbSBpdHNlbGYgYW5kIHByb2R1Y2UgY2lyY3VsYXIgSlNPTi5cclxuICAgICAgICAgICAgLy8gSW5zdGVhZCBleHBvc2UgYSBzYWZlIHN1bW1hcnk6IGNvdW50IGFuZCBhIHNtYWxsIHByZXZpZXcgb2YgaWRzL2RhdGVzLlxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGNyZWF0ZWQuX21hdGVyaWFsaXplZF9jb3VudCA9IG1hdGVyaWFsaXplZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgY3JlYXRlZC5fbWF0ZXJpYWxpemVkX3ByZXZpZXcgPSBtYXRlcmlhbGl6ZWQuc2xpY2UoMCwgNSkubWFwKGV2ID0+ICh7IGlkOiBldi5pZCwgZGF0ZTogbG9jYWxEYXRlT25seVN0cmluZyhldi5kYXRlKSB9KSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAvLyBpZ25vcmUgcHJldmlldyBmYWlsdXJlc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gY29tcHV0ZSBlbmRfZGF0ZSBmcm9tIHByb3ZpZGVkIGVuZERhdGUgb3IgZHVyYXRpb25NaW51dGVzXHJcbiAgICAgICAgbGV0IGVuZERhdGVUb1N0b3JlID0gbnVsbDtcclxuICAgICAgICBpZiAocmVxLmJvZHkgJiYgcmVxLmJvZHkuZW5kRGF0ZSkge1xyXG4gICAgICAgICAgZW5kRGF0ZVRvU3RvcmUgPSBwYXJzZURhdGVGb3JTdG9yYWdlKHJlcS5ib2R5LmVuZERhdGUpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGR1cmF0aW9uTWludXRlcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZHVyYXRpb25NaW51dGVzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICBlbmREYXRlVG9TdG9yZSA9IG5ldyBEYXRlKChwYXJzZURhdGVGb3JTdG9yYWdlKGRhdGUpKS5nZXRUaW1lKCkgKyBOdW1iZXIoZHVyYXRpb25NaW51dGVzKSAqIDYwMDAwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCBjcmVhdGVEYXRhID0ge1xyXG4gICAgICAgICAgICB0aXRsZSxcclxuICAgICAgICAgICAgdHlwZTogdHlwZSB8fCAnYXNzaWdubWVudCcsXHJcbiAgICAgICAgICAgIGNvdXJzZV9pZDogY291cnNlSWQgfHwgbnVsbCxcclxuICAgICAgICAgICAgZGF0ZTogZHQsXHJcbiAgICAgICAgICAgIHRpbWU6IHRpbWUgfHwgbnVsbCxcclxuICAgICAgICAgICAgZW5kX2RhdGU6IGVuZERhdGVUb1N0b3JlLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogZmluYWxEZXNjcmlwdGlvbixcclxuICAgICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxyXG4gICAgICAgICAgICB1c2VyX2lkOiByZXNvbHZlZFVzZXJJZCA/IFN0cmluZyhyZXNvbHZlZFVzZXJJZCkgOiBudWxsXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgaWYgKG1ldGFUb1N0b3JlICE9PSBudWxsKSBjcmVhdGVEYXRhLm1ldGEgPSBtZXRhVG9TdG9yZTtcclxuICAgICAgICAgIHRyeSB7IGNvbnNvbGUuaW5mbygnW2FwaS9ldmVudHNdIGNyZWF0aW5nIHNpbmdsZSBldmVudCB3aXRoIGRhdGE6JywgSlNPTi5zdHJpbmdpZnkoeyAuLi5jcmVhdGVEYXRhLCBtZXRhOiB1bmRlZmluZWQgfSkuc2xpY2UoMCwyMDAwKSk7IH0gY2F0Y2goZSkge31cclxuICAgICAgICAgIGNyZWF0ZWQgPSBhd2FpdCBwcmlzbWEuZXZlbnQuY3JlYXRlKHsgZGF0YTogY3JlYXRlRGF0YSB9KTtcclxuICAgICAgICB9IGNhdGNoIChlZSkge1xyXG4gICAgICAgICAgY29uc3QgbW1zZyA9IGVlICYmIGVlLm1lc3NhZ2UgPyBTdHJpbmcoZWUubWVzc2FnZSkgOiAnJztcclxuICAgICAgICAgIGlmIChpc1ByaXNtYU1ldGFFcnJvcihtbXNnKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1thcGkvZXZlbnRzXSByZXRyeWluZyBjcmVhdGUgd2l0aG91dCBgbWV0YWAgZHVlIHRvIERCIHNjaGVtYSBtaXNtYXRjaCcpO1xyXG4gICAgICAgICAgICBjcmVhdGVkID0gYXdhaXQgcHJpc21hLmV2ZW50LmNyZWF0ZSh7IGRhdGE6IHtcclxuICAgICAgICAgICAgICB0aXRsZSxcclxuICAgICAgICAgICAgICB0eXBlOiB0eXBlIHx8ICdhc3NpZ25tZW50JyxcclxuICAgICAgICAgICAgICBjb3Vyc2VfaWQ6IGNvdXJzZUlkIHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgZGF0ZTogZHQsXHJcbiAgICAgICAgICAgICAgdGltZTogdGltZSB8fCBudWxsLFxyXG4gICAgICAgICAgICAgIGVuZF9kYXRlOiBlbmREYXRlVG9TdG9yZSxcclxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogZmluYWxEZXNjcmlwdGlvbixcclxuICAgICAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXHJcbiAgICAgICAgICAgICAgdXNlcl9pZDogcmVzb2x2ZWRVc2VySWQgPyBTdHJpbmcocmVzb2x2ZWRVc2VySWQpIDogbnVsbFxyXG4gICAgICAgICAgICB9fSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBlZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE9ubHkgcGVyc2lzdCBhdHRhY2htZW50IG1ldGFkYXRhIHdoZW4gd2UndmUgY3JlYXRlZCBhbiBFdmVudCAobm90IHdoZW4gY3JlYXRpbmcgYSB0ZW1wbGF0ZSlcclxuICAgICAgaWYgKCFpc1RlbXBsYXRlICYmIGF0dGFjaG1lbnRzICYmIEFycmF5LmlzQXJyYXkoYXR0YWNobWVudHMpICYmIGF0dGFjaG1lbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgZm9yIChjb25zdCBhIG9mIGF0dGFjaG1lbnRzKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgY29uc3Qgc2FmZU5hbWUgPSBhLm5hbWUgPyBTdHJpbmcoYS5uYW1lKS5yZXBsYWNlKC9bXlxcdy5cXC1dL2csICdfJykgOiAoJ2ZpbGUtJyArIERhdGUubm93KCkpO1xyXG4gICAgICAgICAgICAgIGF3YWl0IHByaXNtYS5hdHRhY2htZW50LmNyZWF0ZSh7IGRhdGE6IHtcclxuICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBzYWZlTmFtZSxcclxuICAgICAgICAgICAgICAgIHBhdGg6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBtaW1lOiBhLnR5cGUgfHwgbnVsbCxcclxuICAgICAgICAgICAgICAgIHNpemU6IGEuc2l6ZSB8fCBudWxsLFxyXG4gICAgICAgICAgICAgICAgZXZlbnRfaWQ6IGNyZWF0ZWQuaWRcclxuICAgICAgICAgICAgICB9fSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgY29uc29sZS53YXJuKCdhdHRhY2htZW50IG1ldGEgY3JlYXRlIGZhaWxlZCcsIGUpOyB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBjb25zb2xlLndhcm4oJ2F0dGFjaG1lbnRzIGhhbmRsaW5nIGZhaWxlZCcsIGUpOyB9XHJcbiAgICAgIH1cclxuXHJcbiAgLy8gUmV0dXJuIGNyZWF0ZWQgZW50aXR5LiBJZiB3ZSBjcmVhdGVkIGEgdGVtcGxhdGUsIHJldHVybiBpdCB1bmRlciBgdGVtcGxhdGVgLlxyXG4gIHRyeSB7XHJcbiAgICBpZiAoaXNUZW1wbGF0ZSAmJiBjcmVhdGVkICYmIGNyZWF0ZWQudGVtcGxhdGUpIHtcclxuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoMjAxKS5qc29uKHsgdGVtcGxhdGU6IGNyZWF0ZWQudGVtcGxhdGUgfSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXQgPSB7IC4uLmNyZWF0ZWQsIGR1cmF0aW9uTWludXRlczogdHlwZW9mIGR1cmF0aW9uTWludXRlcyAhPT0gJ3VuZGVmaW5lZCcgPyBkdXJhdGlvbk1pbnV0ZXMgOiBudWxsIH07XHJcbiAgICAvLyBub3JtYWxpemUgZGF0ZSB0byBsb2NhbCBkYXRlLW9ubHkgc3RyaW5nXHJcbiAgICBpZiAocmV0ICYmIHJldC5kYXRlKSByZXQuZGF0ZSA9IGxvY2FsRGF0ZU9ubHlTdHJpbmcocmV0LmRhdGUpO1xyXG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoMjAxKS5qc29uKHsgZXZlbnQ6IHJldCB9KTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICBpZiAoaXNUZW1wbGF0ZSAmJiBjcmVhdGVkICYmIGNyZWF0ZWQudGVtcGxhdGUpIHJldHVybiByZXMuc3RhdHVzKDIwMSkuanNvbih7IHRlbXBsYXRlOiBjcmVhdGVkLnRlbXBsYXRlIH0pO1xyXG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoMjAxKS5qc29uKHsgZXZlbnQ6IHsgLi4uY3JlYXRlZCwgZHVyYXRpb25NaW51dGVzOiB0eXBlb2YgZHVyYXRpb25NaW51dGVzICE9PSAndW5kZWZpbmVkJyA/IGR1cmF0aW9uTWludXRlcyA6IG51bGwgfSB9KTtcclxuICB9XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgLy8gTG9nIGZ1bGwgZXJyb3Igd2l0aCBzdGFjayBmb3IgZGVidWdnaW5nXHJcbiAgICAgIHRyeSB7IGNvbnNvbGUuZXJyb3IoJ1thcGkvZXZlbnRzXSBQT1NUIGVycm9yOicsIGVyciAmJiBlcnIuc3RhY2sgPyBlcnIuc3RhY2sgOiBlcnIpOyB9IGNhdGNoIChlKSB7IGNvbnNvbGUuZXJyb3IoJ1thcGkvZXZlbnRzXSBQT1NUIGVycm9yIChmYWlsZWQgdG8gc3RyaW5naWZ5KTonLCBlcnIpOyB9XHJcbiAgICAgIC8vIEluIGRldmVsb3BtZW50LCByZXR1cm4gZXJyb3IgZGV0YWlscyB0byBoZWxwIGRlYnVnIGNsaWVudC1zaWRlXHJcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xyXG4gICAgICAgIGNvbnN0IGRldGFpbHMgPSBlcnIgJiYgKGVyci5tZXNzYWdlIHx8IGVyci50b1N0cmluZygpKSA/IChlcnIubWVzc2FnZSB8fCBTdHJpbmcoZXJyKSkgOiAndW5rbm93biBlcnJvcic7XHJcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNTAwKS5qc29uKHsgZXJyb3I6ICdGYWlsZWQgdG8gY3JlYXRlIGV2ZW50JywgZGV0YWlscyB9KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzLnN0YXR1cyg1MDApLmpzb24oeyBlcnJvcjogJ0ZhaWxlZCB0byBjcmVhdGUgZXZlbnQnIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXMuc2V0SGVhZGVyKCdBbGxvdycsICdHRVQsUE9TVCxPUFRJT05TJyk7XHJcbiAgcmVzLnN0YXR1cyg0MDUpLmVuZCgpO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJwcmlzbWEiLCJyZXF1aXJlIiwiaXNEYXRlT25seSIsInZhbHVlIiwidGVzdCIsImxvY2FsRGF0ZU9ubHlTdHJpbmciLCJkIiwiZHQiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJEYXRlIiwiU3RyaW5nIiwiaXNOYU4iLCJnZXRUaW1lIiwieSIsImdldEZ1bGxZZWFyIiwibSIsImdldE1vbnRoIiwicGFkU3RhcnQiLCJkYXkiLCJnZXREYXRlIiwicGFyc2VEYXRlRm9yU3RvcmFnZSIsInMiLCJwYXJzZWQiLCJpc0JlZm9yZVRvZGF5TG9jYWwiLCJkYXRlIiwibm93IiwidG9kYXlTdGFydCIsInByb3ZpZGVkU3RhcnQiLCJpc1ByaXNtYU1ldGFFcnJvciIsIm1zZyIsInRvTG93ZXJDYXNlIiwiaW5jbHVkZXMiLCJoYW5kbGVyIiwicmVxIiwicmVzIiwibWV0aG9kIiwic2V0SGVhZGVyIiwic3RhdHVzIiwiZW5kIiwiZ2V0VG9rZW4iLCJ0b2tlbiIsInNlY3JldCIsInByb2Nlc3MiLCJlbnYiLCJORVhUQVVUSF9TRUNSRVQiLCJ0b2tlblVzZXJJZCIsInVzZXJJZCIsInF1ZXJ5IiwianNvbiIsImVycm9yIiwiZXZlbnRzIiwiZXZlbnQiLCJmaW5kTWFueSIsIndoZXJlIiwidXNlcl9pZCIsIm9yZGVyQnkiLCJlIiwibWVzc2FnZSIsImNvbnNvbGUiLCJ3YXJuIiwic2VsZWN0IiwiaWQiLCJ0aXRsZSIsInR5cGUiLCJsb2NhdGlvbiIsImFyY2hpdmVkIiwiY291cnNlX2lkIiwidGVtcGxhdGVfaWQiLCJ0aW1lIiwiZW5kX2RhdGUiLCJkZXNjcmlwdGlvbiIsImNvbXBsZXRlZCIsImNyZWF0ZWRfYXQiLCJ1cGRhdGVkX2F0Iiwibm9ybWFsaXplZCIsIm1hcCIsImV2IiwiZXJyIiwiY291cnNlSWQiLCJub3RlcyIsInN1YnRhc2tzIiwiYXR0YWNobWVudHMiLCJkdXJhdGlvbk1pbnV0ZXMiLCJyZXBlYXRPcHRpb24iLCJib2R5Iiwic2FmZUJvZHkiLCJKU09OIiwic3RyaW5naWZ5Iiwia2V5cyIsInNsaWNlIiwiaW5mbyIsInN1cHBsaWVkVXNlcklkIiwiaW5jb21pbmdMb2NhdGlvbiIsInJvb20iLCJjb2RlIiwicmVzb2x2ZWRVc2VySWQiLCJ1IiwidXNlciIsImZpbmRVbmlxdWUiLCJmaW5hbERlc2NyaXB0aW9uIiwiZXh0cmFzIiwibGVuZ3RoIiwianNvbkV4dHJhcyIsIm1ldGFUb1N0b3JlIiwibWV0YSIsImNyZWF0ZWQiLCJpc1RlbXBsYXRlIiwiQXJyYXkiLCJpc0FycmF5IiwidGVtcGxhdGVNb2R1bGVzIiwicGF5bG9hZCIsInRlbXBsYXRlUGF5bG9hZCIsInRwbERhdGEiLCJyZXBlYXRfb3B0aW9uIiwic3RhcnRfZGF0ZSIsInRwbCIsImV2ZW50VGVtcGxhdGUiLCJjcmVhdGUiLCJkYXRhIiwidGVtcGxhdGUiLCJtYXRlcmlhbGl6ZSIsIm1hdGVyaWFsaXplQ291bnQiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIm1hdGVyaWFsaXplVW50aWwiLCJjb21wdXRlT2NjdXJyZW5jZXMiLCJzdGFydERhdGUiLCJvcHQiLCJtYXhDb3VudCIsIm91dCIsInN0YXJ0IiwieWVhciIsImludGVydmFsV2Vla3MiLCJpbnRlcnZhbCIsImJ5RGF5cyIsImZpbHRlciIsImN1cnNvciIsImNvdW50IiwicHVzaElmIiwicHVzaCIsInNldERhdGUiLCJzdGFydFRpbWUiLCJzYWZlR3VhcmQiLCJkYXlzU2luY2VTdGFydCIsIk1hdGgiLCJmbG9vciIsIndlZWtJbmRleCIsIndlZWtkYXkiLCJnZXREYXkiLCJvY2NEYXRlcyIsInVudGlsIiwiYWxsIiwidGVtcGxhdGVEYXRhIiwicmVzdWx0IiwiJHRyYW5zYWN0aW9uIiwidHgiLCJjcmVhdGVkRXZlbnRzIiwiY3JlYXRlRGF0YSIsInVuZGVmaW5lZCIsImVlIiwibW1zZyIsImV2MiIsIm1hdGVyaWFsaXplZCIsIl9tYXRlcmlhbGl6ZWRfY291bnQiLCJfbWF0ZXJpYWxpemVkX3ByZXZpZXciLCJlbmREYXRlVG9TdG9yZSIsImVuZERhdGUiLCJhIiwic2FmZU5hbWUiLCJuYW1lIiwicmVwbGFjZSIsImF0dGFjaG1lbnQiLCJmaWxlbmFtZSIsInBhdGgiLCJtaW1lIiwic2l6ZSIsImV2ZW50X2lkIiwicmV0Iiwic3RhY2siLCJkZXRhaWxzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api-node)/./pages/api/events/index.js\n");

/***/ }),

/***/ "@prisma/client":
/*!*********************************!*\
  !*** external "@prisma/client" ***!
  \*********************************/
/***/ ((module) => {

module.exports = require("@prisma/client");

/***/ }),

/***/ "next-auth/jwt":
/*!********************************!*\
  !*** external "next-auth/jwt" ***!
  \********************************/
/***/ ((module) => {

module.exports = require("next-auth/jwt");

/***/ }),

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api-node)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fevents&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cevents%5Cindex.js&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();