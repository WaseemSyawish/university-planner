"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/events/[id]";
exports.ids = ["pages/api/events/[id]"];
exports.modules = {

/***/ "(api-node)/./lib/config.js":
/*!***********************!*\
  !*** ./lib/config.js ***!
  \***********************/
/***/ ((module) => {

eval("// Shared runtime config for client & server\n// Use a single source of truth for the minimum scheduling offset so client and server can't drift.\n\nconst MIN_SCHEDULE_OFFSET_MS = 4 * 60 * 1000; // 4 minutes (a bit more lenient than 4.5)\nconst MIN_SCHEDULE_OFFSET_LABEL = '4 minutes';\nmodule.exports = {\n    MIN_SCHEDULE_OFFSET_MS,\n    MIN_SCHEDULE_OFFSET_LABEL\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uL2xpYi9jb25maWcuanMiLCJtYXBwaW5ncyI6IkFBQUEsNENBQTRDO0FBQzVDLG1HQUFtRzs7QUFFbkcsTUFBTUEseUJBQXlCLElBQUksS0FBSyxNQUFNLDBDQUEwQztBQUN4RixNQUFNQyw0QkFBNEI7QUFFbENDLE9BQU9DLE9BQU8sR0FBRztJQUNmSDtJQUNBQztBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXHVuaXZlcnNpdHktcGxhbm5lclxcbGliXFxjb25maWcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU2hhcmVkIHJ1bnRpbWUgY29uZmlnIGZvciBjbGllbnQgJiBzZXJ2ZXJcclxuLy8gVXNlIGEgc2luZ2xlIHNvdXJjZSBvZiB0cnV0aCBmb3IgdGhlIG1pbmltdW0gc2NoZWR1bGluZyBvZmZzZXQgc28gY2xpZW50IGFuZCBzZXJ2ZXIgY2FuJ3QgZHJpZnQuXHJcblxyXG5jb25zdCBNSU5fU0NIRURVTEVfT0ZGU0VUX01TID0gNCAqIDYwICogMTAwMDsgLy8gNCBtaW51dGVzIChhIGJpdCBtb3JlIGxlbmllbnQgdGhhbiA0LjUpXHJcbmNvbnN0IE1JTl9TQ0hFRFVMRV9PRkZTRVRfTEFCRUwgPSAnNCBtaW51dGVzJztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gIE1JTl9TQ0hFRFVMRV9PRkZTRVRfTVMsXHJcbiAgTUlOX1NDSEVEVUxFX09GRlNFVF9MQUJFTFxyXG59O1xyXG4iXSwibmFtZXMiOlsiTUlOX1NDSEVEVUxFX09GRlNFVF9NUyIsIk1JTl9TQ0hFRFVMRV9PRkZTRVRfTEFCRUwiLCJtb2R1bGUiLCJleHBvcnRzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api-node)/./lib/config.js\n");

/***/ }),

/***/ "(api-node)/./lib/eventsFallback.js":
/*!*******************************!*\
  !*** ./lib/eventsFallback.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst dataFile = path.join(process.cwd(), 'data', 'events.json');\nfunction ensureFile() {\n    const dir = path.dirname(dataFile);\n    if (!fs.existsSync(dir)) fs.mkdirSync(dir, {\n        recursive: true\n    });\n    if (!fs.existsSync(dataFile)) fs.writeFileSync(dataFile, JSON.stringify({\n        events: [],\n        nextId: 1\n    }, null, 2));\n}\nfunction read() {\n    ensureFile();\n    return JSON.parse(fs.readFileSync(dataFile, 'utf8'));\n}\nfunction write(obj) {\n    fs.writeFileSync(dataFile, JSON.stringify(obj, null, 2));\n}\nmodule.exports = {\n    list (showArchived = false) {\n        const obj = read();\n        if (showArchived) return obj.events;\n        return obj.events.filter((e)=>!e.archived);\n    },\n    create (payload) {\n        const obj = read();\n        const id = String(Date.now());\n        const ev = {\n            id,\n            ...payload,\n            archived: !!payload.archived,\n            created_at: new Date().toISOString(),\n            updated_at: new Date().toISOString()\n        };\n        obj.events.push(ev);\n        obj.nextId = (obj.nextId || 0) + 1;\n        write(obj);\n        return ev;\n    },\n    find (id) {\n        const obj = read();\n        return obj.events.find((e)=>e.id === id);\n    },\n    update (id, payload) {\n        const obj = read();\n        const idx = obj.events.findIndex((e)=>e.id === id);\n        if (idx === -1) return null;\n        obj.events[idx] = {\n            ...obj.events[idx],\n            ...payload,\n            archived: payload.archived !== undefined ? !!payload.archived : obj.events[idx].archived,\n            updated_at: new Date().toISOString()\n        };\n        write(obj);\n        return obj.events[idx];\n    },\n    delete (id) {\n        const obj = read();\n        const idx = obj.events.findIndex((e)=>e.id === id);\n        if (idx === -1) return null;\n        const [deleted] = obj.events.splice(idx, 1);\n        write(obj);\n        return deleted;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUd6QixJQUFJTixNQUFNLENBQUNnQyxNQUFNLENBQUNMLEtBQUs7UUFDekN0QixNQUFNQztRQUNOLE9BQU95QjtJQUNUO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcdW5pdmVyc2l0eS1wbGFubmVyXFxsaWJcXGV2ZW50c0ZhbGxiYWNrLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcclxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcclxuXHJcbmNvbnN0IGRhdGFGaWxlID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdkYXRhJywgJ2V2ZW50cy5qc29uJyk7XHJcblxyXG5mdW5jdGlvbiBlbnN1cmVGaWxlKCkge1xyXG4gIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShkYXRhRmlsZSk7XHJcbiAgaWYgKCFmcy5leGlzdHNTeW5jKGRpcikpIGZzLm1rZGlyU3luYyhkaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xyXG4gIGlmICghZnMuZXhpc3RzU3luYyhkYXRhRmlsZSkpIGZzLndyaXRlRmlsZVN5bmMoZGF0YUZpbGUsIEpTT04uc3RyaW5naWZ5KHsgZXZlbnRzOiBbXSwgbmV4dElkOiAxIH0sIG51bGwsIDIpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZCgpIHtcclxuICBlbnN1cmVGaWxlKCk7XHJcbiAgcmV0dXJuIEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKGRhdGFGaWxlLCAndXRmOCcpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gd3JpdGUob2JqKSB7XHJcbiAgZnMud3JpdGVGaWxlU3luYyhkYXRhRmlsZSwgSlNPTi5zdHJpbmdpZnkob2JqLCBudWxsLCAyKSk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gIGxpc3Qoc2hvd0FyY2hpdmVkID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IG9iaiA9IHJlYWQoKTtcclxuICAgIGlmIChzaG93QXJjaGl2ZWQpIHJldHVybiBvYmouZXZlbnRzO1xyXG4gICAgcmV0dXJuIG9iai5ldmVudHMuZmlsdGVyKGUgPT4gIWUuYXJjaGl2ZWQpO1xyXG4gIH0sXHJcbiAgY3JlYXRlKHBheWxvYWQpIHtcclxuICAgIGNvbnN0IG9iaiA9IHJlYWQoKTtcclxuICAgIGNvbnN0IGlkID0gU3RyaW5nKERhdGUubm93KCkpO1xyXG4gICAgY29uc3QgZXYgPSB7IGlkLCAuLi5wYXlsb2FkLCBhcmNoaXZlZDogISFwYXlsb2FkLmFyY2hpdmVkLCBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9O1xyXG4gICAgb2JqLmV2ZW50cy5wdXNoKGV2KTtcclxuICAgIG9iai5uZXh0SWQgPSAob2JqLm5leHRJZCB8fCAwKSArIDE7XHJcbiAgICB3cml0ZShvYmopO1xyXG4gICAgcmV0dXJuIGV2O1xyXG4gIH0sXHJcbiAgZmluZChpZCkge1xyXG4gICAgY29uc3Qgb2JqID0gcmVhZCgpO1xyXG4gICAgcmV0dXJuIG9iai5ldmVudHMuZmluZChlID0+IGUuaWQgPT09IGlkKTtcclxuICB9LFxyXG4gIHVwZGF0ZShpZCwgcGF5bG9hZCkge1xyXG4gICAgY29uc3Qgb2JqID0gcmVhZCgpO1xyXG4gICAgY29uc3QgaWR4ID0gb2JqLmV2ZW50cy5maW5kSW5kZXgoZSA9PiBlLmlkID09PSBpZCk7XHJcbiAgICBpZiAoaWR4ID09PSAtMSkgcmV0dXJuIG51bGw7XHJcbiAgICBvYmouZXZlbnRzW2lkeF0gPSB7IC4uLm9iai5ldmVudHNbaWR4XSwgLi4ucGF5bG9hZCwgYXJjaGl2ZWQ6IHBheWxvYWQuYXJjaGl2ZWQgIT09IHVuZGVmaW5lZCA/ICEhcGF5bG9hZC5hcmNoaXZlZCA6IG9iai5ldmVudHNbaWR4XS5hcmNoaXZlZCwgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH07XHJcbiAgICB3cml0ZShvYmopO1xyXG4gICAgcmV0dXJuIG9iai5ldmVudHNbaWR4XTtcclxuICB9LFxyXG4gIGRlbGV0ZShpZCkge1xyXG4gICAgY29uc3Qgb2JqID0gcmVhZCgpO1xyXG4gICAgY29uc3QgaWR4ID0gb2JqLmV2ZW50cy5maW5kSW5kZXgoZSA9PiBlLmlkID09PSBpZCk7XHJcbiAgICBpZiAoaWR4ID09PSAtMSkgcmV0dXJuIG51bGw7XHJcbiAgICBjb25zdCBbZGVsZXRlZF0gPSBvYmouZXZlbnRzLnNwbGljZShpZHgsIDEpO1xyXG4gICAgd3JpdGUob2JqKTtcclxuICAgIHJldHVybiBkZWxldGVkO1xyXG4gIH1cclxufTtcclxuIl0sIm5hbWVzIjpbImZzIiwicmVxdWlyZSIsInBhdGgiLCJkYXRhRmlsZSIsImpvaW4iLCJwcm9jZXNzIiwiY3dkIiwiZW5zdXJlRmlsZSIsImRpciIsImRpcm5hbWUiLCJleGlzdHNTeW5jIiwibWtkaXJTeW5jIiwicmVjdXJzaXZlIiwid3JpdGVGaWxlU3luYyIsIkpTT04iLCJzdHJpbmdpZnkiLCJldmVudHMiLCJuZXh0SWQiLCJyZWFkIiwicGFyc2UiLCJyZWFkRmlsZVN5bmMiLCJ3cml0ZSIsIm9iaiIsIm1vZHVsZSIsImV4cG9ydHMiLCJsaXN0Iiwic2hvd0FyY2hpdmVkIiwiZmlsdGVyIiwiZSIsImFyY2hpdmVkIiwiY3JlYXRlIiwicGF5bG9hZCIsImlkIiwiU3RyaW5nIiwiRGF0ZSIsIm5vdyIsImV2IiwiY3JlYXRlZF9hdCIsInRvSVNPU3RyaW5nIiwidXBkYXRlZF9hdCIsInB1c2giLCJmaW5kIiwidXBkYXRlIiwiaWR4IiwiZmluZEluZGV4IiwidW5kZWZpbmVkIiwiZGVsZXRlIiwiZGVsZXRlZCIsInNwbGljZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api-node)/./lib/eventsFallback.js\n");

/***/ }),

/***/ "(api-node)/./lib/prisma.js":
/*!***********************!*\
  !*** ./lib/prisma.js ***!
  \***********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Shared Prisma client to avoid creating/disconnecting clients per-request\n\nconst { PrismaClient } = __webpack_require__(/*! @prisma/client */ \"@prisma/client\");\n// Use Node's global object for compatibility with ESLint environments\nconst globalForPrisma = global;\nlet prisma;\nif (!globalForPrisma.__prisma) {\n    globalForPrisma.__prisma = new PrismaClient();\n}\nprisma = globalForPrisma.__prisma;\nmodule.exports = prisma;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uL2xpYi9wcmlzbWEuanMiLCJtYXBwaW5ncyI6IkFBQUEsMkVBQTJFOztBQUMzRSxNQUFNLEVBQUVBLFlBQVksRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQyxzQ0FBZ0I7QUFFakQsc0VBQXNFO0FBQ3RFLE1BQU1DLGtCQUFrQkM7QUFFeEIsSUFBSUM7QUFDSixJQUFJLENBQUNGLGdCQUFnQkcsUUFBUSxFQUFFO0lBQzdCSCxnQkFBZ0JHLFFBQVEsR0FBRyxJQUFJTDtBQUNqQztBQUVBSSxTQUFTRixnQkFBZ0JHLFFBQVE7QUFFakNDLE9BQU9DLE9BQU8sR0FBR0giLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcdW5pdmVyc2l0eS1wbGFubmVyXFxsaWJcXHByaXNtYS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTaGFyZWQgUHJpc21hIGNsaWVudCB0byBhdm9pZCBjcmVhdGluZy9kaXNjb25uZWN0aW5nIGNsaWVudHMgcGVyLXJlcXVlc3RcclxuY29uc3QgeyBQcmlzbWFDbGllbnQgfSA9IHJlcXVpcmUoJ0BwcmlzbWEvY2xpZW50Jyk7XHJcblxyXG4vLyBVc2UgTm9kZSdzIGdsb2JhbCBvYmplY3QgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBFU0xpbnQgZW52aXJvbm1lbnRzXHJcbmNvbnN0IGdsb2JhbEZvclByaXNtYSA9IGdsb2JhbDtcclxuXHJcbmxldCBwcmlzbWE7XHJcbmlmICghZ2xvYmFsRm9yUHJpc21hLl9fcHJpc21hKSB7XHJcbiAgZ2xvYmFsRm9yUHJpc21hLl9fcHJpc21hID0gbmV3IFByaXNtYUNsaWVudCgpO1xyXG59XHJcblxyXG5wcmlzbWEgPSBnbG9iYWxGb3JQcmlzbWEuX19wcmlzbWE7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHByaXNtYTtcclxuIl0sIm5hbWVzIjpbIlByaXNtYUNsaWVudCIsInJlcXVpcmUiLCJnbG9iYWxGb3JQcmlzbWEiLCJnbG9iYWwiLCJwcmlzbWEiLCJfX3ByaXNtYSIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api-node)/./lib/prisma.js\n");

/***/ }),

/***/ "(api-node)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fevents%2F%5Bid%5D&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cevents%5C%5Bid%5D.js&middlewareConfigBase64=e30%3D!":
/*!****************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fevents%2F%5Bid%5D&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cevents%5C%5Bid%5D.js&middlewareConfigBase64=e30%3D! ***!
  \****************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   handler: () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_api_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/api-utils */ \"(api-node)/./node_modules/next/dist/server/api-utils/index.js\");\n/* harmony import */ var next_dist_server_api_utils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_api_utils__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/route-kind */ \"(api-node)/./node_modules/next/dist/server/route-kind.js\");\n/* harmony import */ var next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/route-modules/pages-api/module.compiled */ \"(api-node)/./node_modules/next/dist/server/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api-node)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _pages_api_events_id_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pages\\api\\events\\[id].js */ \"(api-node)/./pages/api/events/[id].js\");\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/dist/server/lib/trace/tracer */ \"(api-node)/./node_modules/next/dist/server/lib/trace/tracer.js\");\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/dist/server/lib/trace/constants */ \"(api-node)/./node_modules/next/dist/server/lib/trace/constants.js\");\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_6__);\n\n\n\n\n// Import the userland code.\n\n\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_3__.hoist)(_pages_api_events_id_js__WEBPACK_IMPORTED_MODULE_4__, 'default'));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_3__.hoist)(_pages_api_events_id_js__WEBPACK_IMPORTED_MODULE_4__, 'config');\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_2__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/events/[id]\",\n        pathname: \"/api/events/[id]\",\n        // The following aren't used in production.\n        bundlePath: '',\n        filename: ''\n    },\n    userland: _pages_api_events_id_js__WEBPACK_IMPORTED_MODULE_4__,\n    distDir: \".next\" || 0,\n    relativeProjectDir:  false || ''\n});\nasync function handler(req, res, ctx) {\n    let srcPage = \"/api/events/[id]\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (false) {}\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return;\n    }\n    const { query, params, prerenderManifest, routerServerContext } = prepareResult;\n    try {\n        const method = req.method || 'GET';\n        const tracer = (0,next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_5__.getTracer)();\n        const activeSpan = tracer.getActiveScopeSpan();\n        const onRequestError = routeModule.instrumentationOnRequestError.bind(routeModule);\n        const invokeRouteModule = async (span)=>routeModule.render(req, res, {\n                query: {\n                    ...query,\n                    ...params\n                },\n                params,\n                allowedRevalidateHeaderKeys: [],\n                multiZoneDraftMode: Boolean(false),\n                trustHostHeader: false,\n                // TODO: get this from from runtime env so manifest\n                // doesn't need to load\n                previewProps: prerenderManifest.preview,\n                propagateError: false,\n                dev: routeModule.isDev,\n                page: \"/api/events/[id]\",\n                internalRevalidate: routerServerContext == null ? void 0 : routerServerContext.revalidate,\n                onError: (...args)=>onRequestError(req, ...args)\n            }).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_6__.BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${req.url}`);\n                }\n            });\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await invokeRouteModule(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_6__.BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${req.url}`,\n                    kind: next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_5__.SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, invokeRouteModule));\n        }\n    } catch (err) {\n        // we re-throw in dev to show the error overlay\n        if (routeModule.isDev) {\n            throw err;\n        }\n        // this is technically an invariant as error handling\n        // should be done inside of api-resolver onError\n        (0,next_dist_server_api_utils__WEBPACK_IMPORTED_MODULE_0__.sendError)(res, 500, 'Internal Server Error');\n    } finally{\n        // We don't allow any waitUntil work in pages API routes currently\n        // so if callback is present return with resolved promise since no\n        // pending work\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n    }\n}\n\n//# sourceMappingURL=pages-api.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtcm91dGUtbG9hZGVyL2luZGV4LmpzP2tpbmQ9UEFHRVNfQVBJJnBhZ2U9JTJGYXBpJTJGZXZlbnRzJTJGJTVCaWQlNUQmcHJlZmVycmVkUmVnaW9uPSZhYnNvbHV0ZVBhZ2VQYXRoPS4lMkZwYWdlcyU1Q2FwaSU1Q2V2ZW50cyU1QyU1QmlkJTVELmpzJm1pZGRsZXdhcmVDb25maWdCYXNlNjQ9ZTMwJTNEISIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUF1RDtBQUNDO0FBQ3VDO0FBQ3JDO0FBQzFEO0FBQzBEO0FBQ2M7QUFDRjtBQUN0RTtBQUNBLGlFQUFlLHdFQUFLLENBQUMsb0RBQVEsWUFBWSxFQUFDO0FBQzFDO0FBQ08sZUFBZSx3RUFBSyxDQUFDLG9EQUFRO0FBQ3BDO0FBQ0Esd0JBQXdCLHlHQUFtQjtBQUMzQztBQUNBLGNBQWMsa0VBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZO0FBQ1osYUFBYSxPQUFvQyxJQUFJLENBQUU7QUFDdkQsd0JBQXdCLE1BQXVDO0FBQy9ELENBQUM7QUFDTTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFxQixFQUFFLEVBRTFCO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdEQUF3RDtBQUNwRTtBQUNBO0FBQ0EsdUJBQXVCLDRFQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLDZDQUE2QyxFQUE2QztBQUMxRiw0Q0FBNEMsS0FBd0M7QUFDcEYsaUNBQWlDLEtBQW9DO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxnRkFBYztBQUMvRSwrREFBK0QseUNBQXlDO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVEsRUFBRSxNQUFNO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0Esa0JBQWtCO0FBQ2xCLHVDQUF1QyxRQUFRLEVBQUUsUUFBUTtBQUN6RDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw2RUFBNkUsZ0ZBQWM7QUFDM0YsaUNBQWlDLFFBQVEsRUFBRSxRQUFRO0FBQ25ELDBCQUEwQix1RUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFFQUFTO0FBQ2pCLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzZW5kRXJyb3IgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9hcGktdXRpbHNcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IFBhZ2VzQVBJUm91dGVNb2R1bGUgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9yb3V0ZS1tb2R1bGVzL3BhZ2VzLWFwaS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IGhvaXN0IH0gZnJvbSBcIm5leHQvZGlzdC9idWlsZC90ZW1wbGF0ZXMvaGVscGVyc1wiO1xuLy8gSW1wb3J0IHRoZSB1c2VybGFuZCBjb2RlLlxuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIi4vcGFnZXNcXFxcYXBpXFxcXGV2ZW50c1xcXFxbaWRdLmpzXCI7XG5pbXBvcnQgeyBnZXRUcmFjZXIsIFNwYW5LaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL3RyYWNlL3RyYWNlclwiO1xuaW1wb3J0IHsgQmFzZVNlcnZlclNwYW4gfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvdHJhY2UvY29uc3RhbnRzXCI7XG4vLyBSZS1leHBvcnQgdGhlIGhhbmRsZXIgKHNob3VsZCBiZSB0aGUgZGVmYXVsdCBleHBvcnQpLlxuZXhwb3J0IGRlZmF1bHQgaG9pc3QodXNlcmxhbmQsICdkZWZhdWx0Jyk7XG4vLyBSZS1leHBvcnQgY29uZmlnLlxuZXhwb3J0IGNvbnN0IGNvbmZpZyA9IGhvaXN0KHVzZXJsYW5kLCAnY29uZmlnJyk7XG4vLyBDcmVhdGUgYW5kIGV4cG9ydCB0aGUgcm91dGUgbW9kdWxlIHRoYXQgd2lsbCBiZSBjb25zdW1lZC5cbmNvbnN0IHJvdXRlTW9kdWxlID0gbmV3IFBhZ2VzQVBJUm91dGVNb2R1bGUoe1xuICAgIGRlZmluaXRpb246IHtcbiAgICAgICAga2luZDogUm91dGVLaW5kLlBBR0VTX0FQSSxcbiAgICAgICAgcGFnZTogXCIvYXBpL2V2ZW50cy9baWRdXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvZXZlbnRzL1tpZF1cIixcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBhcmVuJ3QgdXNlZCBpbiBwcm9kdWN0aW9uLlxuICAgICAgICBidW5kbGVQYXRoOiAnJyxcbiAgICAgICAgZmlsZW5hbWU6ICcnXG4gICAgfSxcbiAgICB1c2VybGFuZCxcbiAgICBkaXN0RGlyOiBwcm9jZXNzLmVudi5fX05FWFRfUkVMQVRJVkVfRElTVF9ESVIgfHwgJycsXG4gICAgcmVsYXRpdmVQcm9qZWN0RGlyOiBwcm9jZXNzLmVudi5fX05FWFRfUkVMQVRJVkVfUFJPSkVDVF9ESVIgfHwgJydcbn0pO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZXIocmVxLCByZXMsIGN0eCkge1xuICAgIGxldCBzcmNQYWdlID0gXCIvYXBpL2V2ZW50cy9baWRdXCI7XG4gICAgLy8gdHVyYm9wYWNrIGRvZXNuJ3Qgbm9ybWFsaXplIGAvaW5kZXhgIGluIHRoZSBwYWdlIG5hbWVcbiAgICAvLyBzbyB3ZSBuZWVkIHRvIHRvIHByb2Nlc3MgZHluYW1pYyByb3V0ZXMgcHJvcGVybHlcbiAgICAvLyBUT0RPOiBmaXggdHVyYm9wYWNrIHByb3ZpZGluZyBkaWZmZXJpbmcgdmFsdWUgZnJvbSB3ZWJwYWNrXG4gICAgaWYgKHByb2Nlc3MuZW52LlRVUkJPUEFDSykge1xuICAgICAgICBzcmNQYWdlID0gc3JjUGFnZS5yZXBsYWNlKC9cXC9pbmRleCQvLCAnJykgfHwgJy8nO1xuICAgIH1cbiAgICBjb25zdCBwcmVwYXJlUmVzdWx0ID0gYXdhaXQgcm91dGVNb2R1bGUucHJlcGFyZShyZXEsIHJlcywge1xuICAgICAgICBzcmNQYWdlXG4gICAgfSk7XG4gICAgaWYgKCFwcmVwYXJlUmVzdWx0KSB7XG4gICAgICAgIHJlcy5zdGF0dXNDb2RlID0gNDAwO1xuICAgICAgICByZXMuZW5kKCdCYWQgUmVxdWVzdCcpO1xuICAgICAgICBjdHgud2FpdFVudGlsID09IG51bGwgPyB2b2lkIDAgOiBjdHgud2FpdFVudGlsLmNhbGwoY3R4LCBQcm9taXNlLnJlc29sdmUoKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBxdWVyeSwgcGFyYW1zLCBwcmVyZW5kZXJNYW5pZmVzdCwgcm91dGVyU2VydmVyQ29udGV4dCB9ID0gcHJlcGFyZVJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBtZXRob2QgPSByZXEubWV0aG9kIHx8ICdHRVQnO1xuICAgICAgICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIoKTtcbiAgICAgICAgY29uc3QgYWN0aXZlU3BhbiA9IHRyYWNlci5nZXRBY3RpdmVTY29wZVNwYW4oKTtcbiAgICAgICAgY29uc3Qgb25SZXF1ZXN0RXJyb3IgPSByb3V0ZU1vZHVsZS5pbnN0cnVtZW50YXRpb25PblJlcXVlc3RFcnJvci5iaW5kKHJvdXRlTW9kdWxlKTtcbiAgICAgICAgY29uc3QgaW52b2tlUm91dGVNb2R1bGUgPSBhc3luYyAoc3Bhbik9PnJvdXRlTW9kdWxlLnJlbmRlcihyZXEsIHJlcywge1xuICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAuLi5wYXJhbXNcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgICAgICBhbGxvd2VkUmV2YWxpZGF0ZUhlYWRlcktleXM6IHByb2Nlc3MuZW52Ll9fTkVYVF9BTExPV0VEX1JFVkFMSURBVEVfSEVBREVSUyxcbiAgICAgICAgICAgICAgICBtdWx0aVpvbmVEcmFmdE1vZGU6IEJvb2xlYW4ocHJvY2Vzcy5lbnYuX19ORVhUX01VTFRJX1pPTkVfRFJBRlRfTU9ERSksXG4gICAgICAgICAgICAgICAgdHJ1c3RIb3N0SGVhZGVyOiBwcm9jZXNzLmVudi5fX05FWFRfVFJVU1RfSE9TVF9IRUFERVIsXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogZ2V0IHRoaXMgZnJvbSBmcm9tIHJ1bnRpbWUgZW52IHNvIG1hbmlmZXN0XG4gICAgICAgICAgICAgICAgLy8gZG9lc24ndCBuZWVkIHRvIGxvYWRcbiAgICAgICAgICAgICAgICBwcmV2aWV3UHJvcHM6IHByZXJlbmRlck1hbmlmZXN0LnByZXZpZXcsXG4gICAgICAgICAgICAgICAgcHJvcGFnYXRlRXJyb3I6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGRldjogcm91dGVNb2R1bGUuaXNEZXYsXG4gICAgICAgICAgICAgICAgcGFnZTogXCIvYXBpL2V2ZW50cy9baWRdXCIsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxSZXZhbGlkYXRlOiByb3V0ZXJTZXJ2ZXJDb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiByb3V0ZXJTZXJ2ZXJDb250ZXh0LnJldmFsaWRhdGUsXG4gICAgICAgICAgICAgICAgb25FcnJvcjogKC4uLmFyZ3MpPT5vblJlcXVlc3RFcnJvcihyZXEsIC4uLmFyZ3MpXG4gICAgICAgICAgICB9KS5maW5hbGx5KCgpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFzcGFuKSByZXR1cm47XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHAuc3RhdHVzX2NvZGUnOiByZXMuc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgJ25leHQucnNjJzogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByb290U3BhbkF0dHJpYnV0ZXMgPSB0cmFjZXIuZ2V0Um9vdFNwYW5BdHRyaWJ1dGVzKCk7XG4gICAgICAgICAgICAgICAgLy8gV2Ugd2VyZSB1bmFibGUgdG8gZ2V0IGF0dHJpYnV0ZXMsIHByb2JhYmx5IE9URUwgaXMgbm90IGVuYWJsZWRcbiAgICAgICAgICAgICAgICBpZiAoIXJvb3RTcGFuQXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyb290U3BhbkF0dHJpYnV0ZXMuZ2V0KCduZXh0LnNwYW5fdHlwZScpICE9PSBCYXNlU2VydmVyU3Bhbi5oYW5kbGVSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5leHBlY3RlZCByb290IHNwYW4gdHlwZSAnJHtyb290U3BhbkF0dHJpYnV0ZXMuZ2V0KCduZXh0LnNwYW5fdHlwZScpfScuIFBsZWFzZSByZXBvcnQgdGhpcyBOZXh0LmpzIGlzc3VlIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qc2ApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlID0gcm9vdFNwYW5BdHRyaWJ1dGVzLmdldCgnbmV4dC5yb3V0ZScpO1xuICAgICAgICAgICAgICAgIGlmIChyb3V0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYCR7bWV0aG9kfSAke3JvdXRlfWA7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbmV4dC5yb3V0ZSc6IHJvdXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHAucm91dGUnOiByb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICduZXh0LnNwYW5fbmFtZSc6IG5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4udXBkYXRlTmFtZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzcGFuLnVwZGF0ZU5hbWUoYCR7bWV0aG9kfSAke3JlcS51cmx9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIC8vIFRPRE86IGFjdGl2ZVNwYW4gY29kZSBwYXRoIGlzIGZvciB3aGVuIHdyYXBwZWQgYnlcbiAgICAgICAgLy8gbmV4dC1zZXJ2ZXIgY2FuIGJlIHJlbW92ZWQgd2hlbiB0aGlzIGlzIG5vIGxvbmdlciB1c2VkXG4gICAgICAgIGlmIChhY3RpdmVTcGFuKSB7XG4gICAgICAgICAgICBhd2FpdCBpbnZva2VSb3V0ZU1vZHVsZShhY3RpdmVTcGFuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRyYWNlci53aXRoUHJvcGFnYXRlZENvbnRleHQocmVxLmhlYWRlcnMsICgpPT50cmFjZXIudHJhY2UoQmFzZVNlcnZlclNwYW4uaGFuZGxlUmVxdWVzdCwge1xuICAgICAgICAgICAgICAgICAgICBzcGFuTmFtZTogYCR7bWV0aG9kfSAke3JlcS51cmx9YCxcbiAgICAgICAgICAgICAgICAgICAga2luZDogU3BhbktpbmQuU0VSVkVSLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaHR0cC5tZXRob2QnOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaHR0cC50YXJnZXQnOiByZXEudXJsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBpbnZva2VSb3V0ZU1vZHVsZSkpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIHdlIHJlLXRocm93IGluIGRldiB0byBzaG93IHRoZSBlcnJvciBvdmVybGF5XG4gICAgICAgIGlmIChyb3V0ZU1vZHVsZS5pc0Rldikge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMgaXMgdGVjaG5pY2FsbHkgYW4gaW52YXJpYW50IGFzIGVycm9yIGhhbmRsaW5nXG4gICAgICAgIC8vIHNob3VsZCBiZSBkb25lIGluc2lkZSBvZiBhcGktcmVzb2x2ZXIgb25FcnJvclxuICAgICAgICBzZW5kRXJyb3IocmVzLCA1MDAsICdJbnRlcm5hbCBTZXJ2ZXIgRXJyb3InKTtcbiAgICB9IGZpbmFsbHl7XG4gICAgICAgIC8vIFdlIGRvbid0IGFsbG93IGFueSB3YWl0VW50aWwgd29yayBpbiBwYWdlcyBBUEkgcm91dGVzIGN1cnJlbnRseVxuICAgICAgICAvLyBzbyBpZiBjYWxsYmFjayBpcyBwcmVzZW50IHJldHVybiB3aXRoIHJlc29sdmVkIHByb21pc2Ugc2luY2Ugbm9cbiAgICAgICAgLy8gcGVuZGluZyB3b3JrXG4gICAgICAgIGN0eC53YWl0VW50aWwgPT0gbnVsbCA/IHZvaWQgMCA6IGN0eC53YWl0VW50aWwuY2FsbChjdHgsIFByb21pc2UucmVzb2x2ZSgpKTtcbiAgICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhZ2VzLWFwaS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api-node)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fevents%2F%5Bid%5D&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cevents%5C%5Bid%5D.js&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api-node)/./pages/api/events/[id].js":
/*!**********************************!*\
  !*** ./pages/api/events/[id].js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n// pages/api/events/[id].js\nconst prisma = __webpack_require__(/*! ../../../lib/prisma */ \"(api-node)/./lib/prisma.js\");\nconst fallback = __webpack_require__(/*! ../../../lib/eventsFallback */ \"(api-node)/./lib/eventsFallback.js\");\nconst { MIN_SCHEDULE_OFFSET_MS, MIN_SCHEDULE_OFFSET_LABEL } = __webpack_require__(/*! ../../../lib/config */ \"(api-node)/./lib/config.js\");\nfunction isDateOnly(value) {\n    return typeof value === 'string' && /^\\d{4}-\\d{2}-\\d{2}$/.test(value);\n}\nfunction parseDateForStorage(value) {\n    if (!value) return null;\n    if (Object.prototype.toString.call(value) === '[object Date]') return value;\n    const s = String(value);\n    // Treat date-only strings as local-midnight to avoid timezone shifting the day\n    if (isDateOnly(s)) return new Date(s + 'T00:00:00');\n    const parsed = new Date(s);\n    return isNaN(parsed.getTime()) ? null : parsed;\n}\nfunction isBeforeTodayLocal(date) {\n    if (!date) return false;\n    const d = Object.prototype.toString.call(date) === '[object Date]' ? date : new Date(String(date));\n    if (isNaN(d.getTime())) return false;\n    const now = new Date();\n    const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n    const providedStart = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n    return providedStart < todayStart;\n}\nasync function handler(req, res) {\n    const { method } = req;\n    const { id } = req.query;\n    if (!id) {\n        return res.status(400).json({\n            code: 'MISSING_ID',\n            message: 'Event ID is required'\n        });\n    }\n    try {\n        // Helper: detect missing-column or unknown-argument DB/Prisma errors\n        const isMissingColumnError = (err)=>{\n            if (!err) return false;\n            const m = err && err.message ? String(err.message).toLowerCase() : '';\n            if (!m) return false;\n            if (m.includes('does not exist') || m.includes('no such column')) return true;\n            if (m.includes('unknown argument') || m.includes('unknown arg')) return true;\n            if (/unknown.*meta/.test(m)) return true;\n            return false;\n        };\n        // Helper: safely find an event by id, retrying without selecting `meta` if needed\n        const safeFindEvent = async (evtId, includeCourses = false)=>{\n            try {\n                if (includeCourses) return await prisma.event.findUnique({\n                    where: {\n                        id: evtId\n                    },\n                    include: {\n                        courses: true\n                    }\n                });\n                return await prisma.event.findUnique({\n                    where: {\n                        id: evtId\n                    }\n                });\n            } catch (e) {\n                if (!isMissingColumnError(e)) throw e;\n                // Retry by explicitly selecting known fields (exclude meta) and include relations if requested\n                const baseSelect = {\n                    id: true,\n                    title: true,\n                    type: true,\n                    location: true,\n                    archived: true,\n                    course_id: true,\n                    template_id: true,\n                    date: true,\n                    time: true,\n                    end_date: true,\n                    description: true,\n                    completed: true,\n                    user_id: true,\n                    created_at: true,\n                    updated_at: true\n                };\n                if (includeCourses) baseSelect.courses = true;\n                return await prisma.event.findUnique({\n                    where: {\n                        id: evtId\n                    },\n                    select: baseSelect\n                });\n            }\n        };\n        // Helper: safely update event; if missing-column error occurs, retry after removing `meta` from data\n        const safeUpdateEvent = async (evtId, data, includeCourses = false)=>{\n            try {\n                return await prisma.event.update({\n                    where: {\n                        id: evtId\n                    },\n                    data,\n                    include: includeCourses ? {\n                        courses: true\n                    } : undefined\n                });\n            } catch (e) {\n                if (!isMissingColumnError(e)) throw e;\n                console.warn('[events/:id] retrying update without `meta` due to DB schema mismatch');\n                const copy = {\n                    ...data\n                };\n                if (Object.prototype.hasOwnProperty.call(copy, 'meta')) delete copy.meta;\n                return await prisma.event.update({\n                    where: {\n                        id: evtId\n                    },\n                    data: copy,\n                    include: includeCourses ? {\n                        courses: true\n                    } : undefined\n                });\n            }\n        };\n        // Helper: safely create event; retry without meta if necessary\n        const safeCreateEvent = async (data, includeCourses = false)=>{\n            try {\n                return await prisma.event.create({\n                    data,\n                    include: includeCourses ? {\n                        courses: true\n                    } : undefined\n                });\n            } catch (e) {\n                if (!isMissingColumnError(e)) throw e;\n                console.warn('[events/:id] retrying create without `meta` due to DB schema mismatch');\n                const copy = {\n                    ...data\n                };\n                if (Object.prototype.hasOwnProperty.call(copy, 'meta')) delete copy.meta;\n                return await prisma.event.create({\n                    data: copy,\n                    include: includeCourses ? {\n                        courses: true\n                    } : undefined\n                });\n            }\n        };\n        switch(method){\n            case 'GET':\n                {\n                    try {\n                        const event = await safeFindEvent(id, true);\n                        if (!event) {\n                            return res.status(404).json({\n                                code: 'NOT_FOUND',\n                                message: 'Event not found'\n                            });\n                        }\n                        return res.status(200).json({\n                            success: true,\n                            event\n                        });\n                    } catch (err) {\n                        console.error(`[events/:id] GET prisma error for id=${id}:`, err && err.message ? err.message : err);\n                        // Prisma unreachable -> fallback to file store\n                        if (err && (err.code === 'P1001' || String(err.message || '').includes(\"Can't reach database\"))) {\n                            try {\n                                const local = fallback.find(id);\n                                if (!local) return res.status(404).json({\n                                    code: 'NOT_FOUND',\n                                    message: 'Event not found'\n                                });\n                                return res.status(200).json({\n                                    success: true,\n                                    event: local\n                                });\n                            } catch (fe) {\n                                console.error('[events/:id] fallback.find error:', fe && fe.message ? fe.message : fe);\n                            }\n                        }\n                        throw err;\n                    }\n                }\n            case 'PATCH':\n                {\n                    const updateData = {\n                        ...req.body\n                    } || {};\n                    console.log(`[events/:id] PATCH payload for id=${id}:`, JSON.stringify(updateData));\n                    // Normalize common client-side field names to DB column names\n                    if (Object.prototype.hasOwnProperty.call(updateData, 'courseId')) {\n                        updateData.course_id = updateData.courseId;\n                        delete updateData.courseId;\n                    }\n                    // normalize room -> location for backwards compatibility\n                    if (Object.prototype.hasOwnProperty.call(updateData, 'room') && !Object.prototype.hasOwnProperty.call(updateData, 'location')) {\n                        updateData.location = updateData.room;\n                        delete updateData.room;\n                    }\n                    if (Object.prototype.hasOwnProperty.call(updateData, 'userId')) {\n                        updateData.user_id = updateData.userId;\n                        delete updateData.userId;\n                    }\n                    // Convert date strings to Date objects for Prisma where appropriate\n                    if (updateData.date) {\n                        const parsed = parseDateForStorage(updateData.date);\n                        if (parsed) {\n                            // Reject updates that set the event date to before today (local)\n                            if (isBeforeTodayLocal(parsed)) return res.status(400).json({\n                                code: 'PAST_DATE',\n                                message: 'Cannot set event date before today'\n                            });\n                            updateData.date = parsed;\n                        }\n                    }\n                    // Convert endDate/end_date to Date object if present\n                    if (updateData.endDate || updateData.end_date) {\n                        const endVal = updateData.endDate || updateData.end_date;\n                        const parsedEnd = parseDateForStorage(endVal);\n                        if (parsedEnd) updateData.end_date = parsedEnd;\n                        delete updateData.endDate;\n                    }\n                    // Remove fields that shouldn't be updated\n                    delete updateData.id;\n                    delete updateData.created_at;\n                    delete updateData.user_id;\n                    // Normalize incoming meta field (allow client to send structured JSON meta)\n                    if (Object.prototype.hasOwnProperty.call(updateData, 'meta')) {\n                    // leave as-is; persisted below via pickPrismaFields\n                    }\n                    const wantsArchived = Object.prototype.hasOwnProperty.call(updateData, 'archived') ? !!updateData.archived : undefined;\n                    if (Object.prototype.hasOwnProperty.call(updateData, 'completed')) {\n                        updateData.completed = !!updateData.completed;\n                    }\n                    // If archiving/unarchiving requested, move between tables\n                    if (wantsArchived === true) {\n                        // Move from Event -> ArchivedEvent\n                        const existing = await safeFindEvent(id, false);\n                        if (!existing) return res.status(404).json({\n                            code: 'NOT_FOUND',\n                            message: 'Event not found'\n                        });\n                        const created = await prisma.archivedEvent.create({\n                            data: {\n                                original_event_id: existing.id,\n                                title: updateData.title || existing.title,\n                                type: updateData.type || existing.type,\n                                course_id: updateData.course_id ?? existing.course_id,\n                                date: updateData.date ? parseDateForStorage(updateData.date) : existing.date,\n                                time: updateData.time ?? existing.time,\n                                description: updateData.description ?? existing.description,\n                                meta: updateData.meta ?? existing.meta ?? null,\n                                location: updateData.location ?? existing.location,\n                                completed: updateData.completed ?? existing.completed,\n                                user_id: existing.user_id\n                            },\n                            include: {\n                                courses: true\n                            }\n                        });\n                        // Delete original\n                        await prisma.event.delete({\n                            where: {\n                                id\n                            }\n                        });\n                        return res.status(200).json({\n                            success: true,\n                            event: created\n                        });\n                    }\n                    if (wantsArchived === false) {\n                        // If an active event already exists with this id, just update it (clear archived flag).\n                        // Only when no active event is present do we attempt to restore from archived_events.\n                        const maybeActive = await safeFindEvent(id, false);\n                        if (maybeActive) {\n                            const dataToApply = {\n                                ...updateData,\n                                archived: false\n                            };\n                            // Ensure we don't try to overwrite immutable fields\n                            delete dataToApply.id;\n                            delete dataToApply.created_at;\n                            delete dataToApply.user_id;\n                            const updated = await safeUpdateEvent(id, dataToApply, true);\n                            return res.status(200).json({\n                                success: true,\n                                event: updated\n                            });\n                        }\n                        // Move from ArchivedEvent -> Event\n                        // The archived table may be keyed either by original_event_id or its own id depending on how\n                        // records were created/migrated. Try both lookups so unarchive succeeds regardless.\n                        let archivedRec = await prisma.archivedEvent.findUnique({\n                            where: {\n                                original_event_id: id\n                            }\n                        });\n                        let deleteKey = {\n                            original_event_id: id\n                        };\n                        if (!archivedRec) {\n                            // try fallback: the provided id might be the archivedEvent.id\n                            archivedRec = await prisma.archivedEvent.findUnique({\n                                where: {\n                                    id\n                                }\n                            });\n                            if (archivedRec) deleteKey = {\n                                id\n                            };\n                        }\n                        if (!archivedRec) {\n                            const attempted = [\n                                'original_event_id',\n                                'id'\n                            ];\n                            console.warn(`[events/:id] unarchive failed for id=${id}: archived record not found (attempted keys: ${attempted.join(',')})`);\n                            return res.status(404).json({\n                                code: 'NOT_FOUND',\n                                message: 'Archived event not found',\n                                attempted\n                            });\n                        }\n                        const created = await safeCreateEvent({\n                            title: updateData.title || archivedRec.title,\n                            type: updateData.type || archivedRec.type,\n                            course_id: updateData.course_id ?? archivedRec.course_id,\n                            date: updateData.date ? parseDateForStorage(updateData.date) : archivedRec.date,\n                            time: updateData.time ?? archivedRec.time,\n                            description: updateData.description ?? archivedRec.description,\n                            meta: updateData.meta ?? archivedRec.meta ?? null,\n                            location: updateData.location ?? archivedRec.location,\n                            completed: updateData.completed ?? archivedRec.completed,\n                            archived: false,\n                            user_id: archivedRec.user_id\n                        }, true);\n                        // Delete archived copy using the resolved key\n                        await prisma.archivedEvent.delete({\n                            where: deleteKey\n                        });\n                        return res.status(200).json({\n                            success: true,\n                            event: created\n                        });\n                    }\n                    // Otherwise, update in whichever table the event currently resides\n                    // Try Event first\n                    // Validate: enforce min scheduling offset only when a time is provided (i.e., a timed event)\n                    if (updateData.time) {\n                        try {\n                            const now = new Date();\n                            const minAllowed = new Date(now.getTime() + MIN_SCHEDULE_OFFSET_MS);\n                            // combine either provided date or existing event date with new time\n                            let baseDate = updateData.date ? new Date(updateData.date) : null;\n                            if (!baseDate) {\n                                // try to lookup current record date to combine with provided time\n                                const existing = await safeFindEvent(id, false) || await prisma.archivedEvent.findUnique({\n                                    where: {\n                                        original_event_id: id\n                                    }\n                                });\n                                baseDate = existing ? new Date(existing.date) : null;\n                            }\n                            if (!baseDate || isNaN(baseDate.getTime())) {\n                                // Instead of failing the entire update when the base date is unknown (which\n                                // can happen for migrated or partial records), log and skip the min-offset check.\n                                console.warn(`[events/:id] PATCH skipping time min-offset check: baseDate missing or invalid for id=${id}`);\n                            } else {\n                                const [hh, mm] = String(updateData.time).split(':').map(Number);\n                                const incomingDateTime = new Date(baseDate.getFullYear(), baseDate.getMonth(), baseDate.getDate(), hh || 0, mm || 0);\n                                if (isNaN(incomingDateTime.getTime())) {\n                                    console.warn(`[events/:id] PATCH invalid incomingDateTime for id=${id}, skipping min-offset check`);\n                                } else if (incomingDateTime < minAllowed) {\n                                    // Keep the existing enforcement if the computed datetime is valid\n                                    return res.status(400).json({\n                                        code: 'SCHED_MIN_OFFSET',\n                                        message: `Please schedule events at least ${MIN_SCHEDULE_OFFSET_LABEL} from now.`\n                                    });\n                                }\n                            }\n                        } catch (err) {\n                            // If anything goes wrong during this non-critical validation, log and continue\n                            console.warn(`[events/:id] PATCH time validation failed for id=${id}:`, err && err.message ? err.message : err);\n                        }\n                    }\n                    // Helper: pick only fields that exist on the Prisma Event/ArchivedEvent models\n                    const pickPrismaFields = (src)=>{\n                        const allowed = [\n                            'title',\n                            'type',\n                            'course_id',\n                            'date',\n                            'time',\n                            'end_date',\n                            'description',\n                            'completed',\n                            'archived',\n                            'location',\n                            'meta'\n                        ];\n                        const out = {};\n                        for (const k of allowed){\n                            if (Object.prototype.hasOwnProperty.call(src, k)) out[k] = src[k];\n                        }\n                        return out;\n                    };\n                    // Attempt to update in active events; if not found, try archived table explicitly\n                    try {\n                        // diagnostic: check where the record currently exists\n                        const existingEvent = await safeFindEvent(id, false);\n                        const existingArchived = await prisma.archivedEvent.findUnique({\n                            where: {\n                                original_event_id: id\n                            }\n                        });\n                        console.info(`[events/:id] update target lookup for id=${id}: event=${existingEvent ? 'found' : 'missing'}, archived=${existingArchived ? 'found' : 'missing'}`);\n                        const dataToApply = pickPrismaFields(updateData);\n                        const updated = await safeUpdateEvent(id, dataToApply, true);\n                        return res.status(200).json({\n                            success: true,\n                            event: updated\n                        });\n                    } catch (err) {\n                        console.error(`[events/:id] prisma.event.update error for id=${id}:`, err && err.message ? err.message : err);\n                        // Try the file-backed fallback for any update error so UI doesn't break when Prisma/DB is flaky\n                        try {\n                            const local = fallback.update(id, updateData);\n                            if (local) return res.status(200).json({\n                                success: true,\n                                event: local,\n                                fallback: true\n                            });\n                        } catch (fe) {\n                            console.error('[events/:id] fallback.update error:', fe && fe.message ? fe.message : fe);\n                        }\n                        // If the error is record not found in the primary table, try archivedEvent (database-side)\n                        if (err && err.code === 'P2025') {\n                            // If record wasn't found in active events, try updating archived record.\n                            // Archived rows may be keyed by original_event_id or by their own id; try both.\n                            try {\n                                const archivedUpdate = await prisma.archivedEvent.update({\n                                    where: {\n                                        original_event_id: id\n                                    },\n                                    data: pickPrismaFields(updateData),\n                                    include: {\n                                        courses: true\n                                    }\n                                });\n                                return res.status(200).json({\n                                    success: true,\n                                    event: archivedUpdate\n                                });\n                            } catch (err2) {\n                                console.info(`[events/:id] archivedEvent.update by original_event_id failed for id=${id}, trying by archived id`);\n                                try {\n                                    const archivedUpdate2 = await prisma.archivedEvent.update({\n                                        where: {\n                                            id\n                                        },\n                                        data: pickPrismaFields(updateData),\n                                        include: {\n                                            courses: true\n                                        }\n                                    });\n                                    return res.status(200).json({\n                                        success: true,\n                                        event: archivedUpdate2\n                                    });\n                                } catch (err3) {\n                                    console.error(`[events/:id] archivedEvent.update error for id=${id}:`, err3 && err3.message ? err3.message : err3);\n                                    // Add attempted keys to error for debugging\n                                    err3.attempted = [\n                                        'original_event_id',\n                                        'id'\n                                    ];\n                                    throw err3;\n                                }\n                            }\n                        }\n                        // Some Prisma errors include useful metadata - surface it in development\n                        if (err && err.message) {\n                            return res.status(500).json({\n                                code: 'PRISMA_ERROR',\n                                message: 'Database update failed',\n                                details: err.message\n                            });\n                        }\n                        // Otherwise re-throw to be handled by outer catch\n                        throw err;\n                    }\n                }\n            case 'DELETE':\n                {\n                    // If client requested deleting the entire series (all materialized occurrences),\n                    // support ?scope=all by deleting all events with the same template_id and the template record.\n                    try {\n                        const scope = req.query && req.query.scope ? String(req.query.scope) : null;\n                        if (scope === 'all') {\n                            // Find the event in active events first\n                            const ev = await safeFindEvent(id, false);\n                            let tplId = ev ? ev.template_id : null;\n                            // If not found in active events, try archived lookup\n                            if (!tplId) {\n                                const archived = await prisma.archivedEvent.findUnique({\n                                    where: {\n                                        original_event_id: id\n                                    }\n                                }) || await prisma.archivedEvent.findUnique({\n                                    where: {\n                                        id\n                                    }\n                                });\n                                tplId = archived ? archived.template_id : null;\n                            }\n                            if (!tplId) {\n                                return res.status(400).json({\n                                    code: 'NO_TEMPLATE',\n                                    message: 'Event is not part of a repeat series or template id is missing'\n                                });\n                            }\n                            // Delete all materialized events and the template in a transaction\n                            try {\n                                const result = await prisma.$transaction(async (tx)=>{\n                                    const deleted = await tx.event.deleteMany({\n                                        where: {\n                                            template_id: tplId\n                                        }\n                                    });\n                                    // Attempt to delete the template record; ignore if already removed\n                                    try {\n                                        await tx.eventTemplate.delete({\n                                            where: {\n                                                id: tplId\n                                            }\n                                        });\n                                    } catch (ignore) {\n                                    // swallow not-found errors for template deletion\n                                    }\n                                    return deleted;\n                                });\n                                return res.status(200).json({\n                                    success: true,\n                                    message: 'Series deleted',\n                                    deletedCount: result.count\n                                });\n                            } catch (txErr) {\n                                console.error(`[events/:id] DELETE series transaction error for template_id=${tplId}:`, txErr && txErr.message ? txErr.message : txErr);\n                                return res.status(500).json({\n                                    code: 'DELETE_SERIES_FAILED',\n                                    message: 'Failed to delete event series',\n                                    details: txErr && txErr.message ? txErr.message : null\n                                });\n                            }\n                        }\n                        // Otherwise fall back to single-event delete\n                        await prisma.event.delete({\n                            where: {\n                                id\n                            }\n                        });\n                        return res.status(200).json({\n                            success: true,\n                            message: 'Event deleted'\n                        });\n                    } catch (err) {\n                        console.error(`[events/:id] DELETE prisma.event.delete error for id=${id}:`, err && err.message ? err.message : err);\n                        // If DB unreachable, try file fallback\n                        if (err && (err.code === 'P1001' || String(err.message || '').includes(\"Can't reach database\"))) {\n                            try {\n                                const local = fallback.delete(id);\n                                if (local) return res.status(200).json({\n                                    success: true,\n                                    message: 'Event deleted',\n                                    event: local\n                                });\n                            } catch (fe) {\n                                console.error('[events/:id] fallback.delete error:', fe && fe.message ? fe.message : fe);\n                            }\n                        }\n                        // Try archived\n                        try {\n                            // Try delete by original_event_id first\n                            await prisma.archivedEvent.delete({\n                                where: {\n                                    original_event_id: id\n                                }\n                            });\n                            return res.status(200).json({\n                                success: true,\n                                message: 'Archived event deleted'\n                            });\n                        } catch (err2) {\n                            // If not found, attempt to delete by archived record id\n                            try {\n                                await prisma.archivedEvent.delete({\n                                    where: {\n                                        id\n                                    }\n                                });\n                                return res.status(200).json({\n                                    success: true,\n                                    message: 'Archived event deleted'\n                                });\n                            } catch (err3) {\n                                return res.status(404).json({\n                                    code: 'NOT_FOUND',\n                                    message: 'Event not found'\n                                });\n                            }\n                        }\n                    }\n                }\n            default:\n                res.setHeader('Allow', [\n                    'GET',\n                    'PATCH',\n                    'DELETE'\n                ]);\n                return res.status(405).json({\n                    success: false,\n                    error: `Method ${method} Not Allowed`\n                });\n        }\n    } catch (error) {\n        console.error('Events [id] API error:', error);\n        if (error.code === 'P2025') {\n            return res.status(404).json({\n                code: 'NOT_FOUND',\n                message: 'Event not found'\n            });\n        }\n        return res.status(500).json({\n            code: 'INTERNAL_ERROR',\n            message: 'Internal server error',\n            details: error.message\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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S0MsSUFBSSxDQUFDO29CQUMxQjJDLFNBQVM7b0JBQ1RDLE9BQU8sQ0FBQyxPQUFPLEVBQUVoRCxPQUFPLFlBQVksQ0FBQztnQkFDdkM7UUFDSjtJQUNGLEVBQUUsT0FBT2dELE9BQU87UUFDZFIsUUFBUVEsS0FBSyxDQUFDLDBCQUEwQkE7UUFFeEMsSUFBSUEsTUFBTTNDLElBQUksS0FBSyxTQUFTO1lBQzFCLE9BQU9OLElBQUlJLE1BQU0sQ0FBQyxLQUFLQyxJQUFJLENBQUM7Z0JBQUVDLE1BQU07Z0JBQWFDLFNBQVM7WUFBa0I7UUFDOUU7UUFFQSxPQUFPUCxJQUFJSSxNQUFNLENBQUMsS0FBS0MsSUFBSSxDQUFDO1lBQUVDLE1BQU07WUFBa0JDLFNBQVM7WUFBeUIwRixTQUFTaEQsTUFBTTFDLE9BQU87UUFBQztJQUNqSDtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXHVuaXZlcnNpdHktcGxhbm5lclxccGFnZXNcXGFwaVxcZXZlbnRzXFxbaWRdLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHBhZ2VzL2FwaS9ldmVudHMvW2lkXS5qc1xyXG5jb25zdCBwcmlzbWEgPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvcHJpc21hJyk7XHJcbmNvbnN0IGZhbGxiYWNrID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL2V2ZW50c0ZhbGxiYWNrJyk7XHJcbmNvbnN0IHsgTUlOX1NDSEVEVUxFX09GRlNFVF9NUywgTUlOX1NDSEVEVUxFX09GRlNFVF9MQUJFTCB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL2NvbmZpZycpO1xyXG5cclxuZnVuY3Rpb24gaXNEYXRlT25seSh2YWx1ZSkge1xyXG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIC9eXFxkezR9LVxcZHsyfS1cXGR7Mn0kLy50ZXN0KHZhbHVlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VEYXRlRm9yU3RvcmFnZSh2YWx1ZSkge1xyXG4gIGlmICghdmFsdWUpIHJldHVybiBudWxsO1xyXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBEYXRlXScpIHJldHVybiB2YWx1ZTtcclxuICBjb25zdCBzID0gU3RyaW5nKHZhbHVlKTtcclxuICAvLyBUcmVhdCBkYXRlLW9ubHkgc3RyaW5ncyBhcyBsb2NhbC1taWRuaWdodCB0byBhdm9pZCB0aW1lem9uZSBzaGlmdGluZyB0aGUgZGF5XHJcbiAgaWYgKGlzRGF0ZU9ubHkocykpIHJldHVybiBuZXcgRGF0ZShzICsgJ1QwMDowMDowMCcpO1xyXG4gIGNvbnN0IHBhcnNlZCA9IG5ldyBEYXRlKHMpO1xyXG4gIHJldHVybiBpc05hTihwYXJzZWQuZ2V0VGltZSgpKSA/IG51bGwgOiBwYXJzZWQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzQmVmb3JlVG9kYXlMb2NhbChkYXRlKSB7XHJcbiAgaWYgKCFkYXRlKSByZXR1cm4gZmFsc2U7XHJcbiAgY29uc3QgZCA9IChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0ZSkgPT09ICdbb2JqZWN0IERhdGVdJykgPyBkYXRlIDogbmV3IERhdGUoU3RyaW5nKGRhdGUpKTtcclxuICBpZiAoaXNOYU4oZC5nZXRUaW1lKCkpKSByZXR1cm4gZmFsc2U7XHJcbiAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcclxuICBjb25zdCB0b2RheVN0YXJ0ID0gbmV3IERhdGUobm93LmdldEZ1bGxZZWFyKCksIG5vdy5nZXRNb250aCgpLCBub3cuZ2V0RGF0ZSgpKTtcclxuICBjb25zdCBwcm92aWRlZFN0YXJ0ID0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCBkLmdldE1vbnRoKCksIGQuZ2V0RGF0ZSgpKTtcclxuICByZXR1cm4gcHJvdmlkZWRTdGFydCA8IHRvZGF5U3RhcnQ7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZXIocmVxLCByZXMpIHtcclxuICBjb25zdCB7IG1ldGhvZCB9ID0gcmVxO1xyXG4gIGNvbnN0IHsgaWQgfSA9IHJlcS5xdWVyeTtcclxuICBcclxuICBpZiAoIWlkKSB7XHJcbiAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDApLmpzb24oeyBjb2RlOiAnTUlTU0lOR19JRCcsIG1lc3NhZ2U6ICdFdmVudCBJRCBpcyByZXF1aXJlZCcgfSk7XHJcbiAgfVxyXG4gIFxyXG4gIHRyeSB7XHJcbiAgICAvLyBIZWxwZXI6IGRldGVjdCBtaXNzaW5nLWNvbHVtbiBvciB1bmtub3duLWFyZ3VtZW50IERCL1ByaXNtYSBlcnJvcnNcclxuICAgIGNvbnN0IGlzTWlzc2luZ0NvbHVtbkVycm9yID0gKGVycikgPT4ge1xyXG4gICAgICBpZiAoIWVycikgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBjb25zdCBtID0gZXJyICYmIGVyci5tZXNzYWdlID8gU3RyaW5nKGVyci5tZXNzYWdlKS50b0xvd2VyQ2FzZSgpIDogJyc7XHJcbiAgICAgIGlmICghbSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAobS5pbmNsdWRlcygnZG9lcyBub3QgZXhpc3QnKSB8fCBtLmluY2x1ZGVzKCdubyBzdWNoIGNvbHVtbicpKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgaWYgKG0uaW5jbHVkZXMoJ3Vua25vd24gYXJndW1lbnQnKSB8fCBtLmluY2x1ZGVzKCd1bmtub3duIGFyZycpKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgaWYgKC91bmtub3duLiptZXRhLy50ZXN0KG0pKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBIZWxwZXI6IHNhZmVseSBmaW5kIGFuIGV2ZW50IGJ5IGlkLCByZXRyeWluZyB3aXRob3V0IHNlbGVjdGluZyBgbWV0YWAgaWYgbmVlZGVkXHJcbiAgICBjb25zdCBzYWZlRmluZEV2ZW50ID0gYXN5bmMgKGV2dElkLCBpbmNsdWRlQ291cnNlcyA9IGZhbHNlKSA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKGluY2x1ZGVDb3Vyc2VzKSByZXR1cm4gYXdhaXQgcHJpc21hLmV2ZW50LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogZXZ0SWQgfSwgaW5jbHVkZTogeyBjb3Vyc2VzOiB0cnVlIH0gfSk7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHByaXNtYS5ldmVudC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IGV2dElkIH0gfSk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBpZiAoIWlzTWlzc2luZ0NvbHVtbkVycm9yKGUpKSB0aHJvdyBlO1xyXG4gICAgICAgIC8vIFJldHJ5IGJ5IGV4cGxpY2l0bHkgc2VsZWN0aW5nIGtub3duIGZpZWxkcyAoZXhjbHVkZSBtZXRhKSBhbmQgaW5jbHVkZSByZWxhdGlvbnMgaWYgcmVxdWVzdGVkXHJcbiAgICAgICAgY29uc3QgYmFzZVNlbGVjdCA9IHtcclxuICAgICAgICAgIGlkOiB0cnVlLFxyXG4gICAgICAgICAgdGl0bGU6IHRydWUsXHJcbiAgICAgICAgICB0eXBlOiB0cnVlLFxyXG4gICAgICAgICAgbG9jYXRpb246IHRydWUsXHJcbiAgICAgICAgICBhcmNoaXZlZDogdHJ1ZSxcclxuICAgICAgICAgIGNvdXJzZV9pZDogdHJ1ZSxcclxuICAgICAgICAgIHRlbXBsYXRlX2lkOiB0cnVlLFxyXG4gICAgICAgICAgZGF0ZTogdHJ1ZSxcclxuICAgICAgICAgIHRpbWU6IHRydWUsXHJcbiAgICAgICAgICBlbmRfZGF0ZTogdHJ1ZSxcclxuICAgICAgICAgIGRlc2NyaXB0aW9uOiB0cnVlLFxyXG4gICAgICAgICAgY29tcGxldGVkOiB0cnVlLFxyXG4gICAgICAgICAgdXNlcl9pZDogdHJ1ZSxcclxuICAgICAgICAgIGNyZWF0ZWRfYXQ6IHRydWUsXHJcbiAgICAgICAgICB1cGRhdGVkX2F0OiB0cnVlXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoaW5jbHVkZUNvdXJzZXMpIGJhc2VTZWxlY3QuY291cnNlcyA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHByaXNtYS5ldmVudC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IGV2dElkIH0sIHNlbGVjdDogYmFzZVNlbGVjdCB9KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBIZWxwZXI6IHNhZmVseSB1cGRhdGUgZXZlbnQ7IGlmIG1pc3NpbmctY29sdW1uIGVycm9yIG9jY3VycywgcmV0cnkgYWZ0ZXIgcmVtb3ZpbmcgYG1ldGFgIGZyb20gZGF0YVxyXG4gICAgY29uc3Qgc2FmZVVwZGF0ZUV2ZW50ID0gYXN5bmMgKGV2dElkLCBkYXRhLCBpbmNsdWRlQ291cnNlcyA9IGZhbHNlKSA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHByaXNtYS5ldmVudC51cGRhdGUoeyB3aGVyZTogeyBpZDogZXZ0SWQgfSwgZGF0YSwgaW5jbHVkZTogaW5jbHVkZUNvdXJzZXMgPyB7IGNvdXJzZXM6IHRydWUgfSA6IHVuZGVmaW5lZCB9KTtcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGlmICghaXNNaXNzaW5nQ29sdW1uRXJyb3IoZSkpIHRocm93IGU7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdbZXZlbnRzLzppZF0gcmV0cnlpbmcgdXBkYXRlIHdpdGhvdXQgYG1ldGFgIGR1ZSB0byBEQiBzY2hlbWEgbWlzbWF0Y2gnKTtcclxuICAgICAgICBjb25zdCBjb3B5ID0geyAuLi5kYXRhIH07XHJcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb3B5LCAnbWV0YScpKSBkZWxldGUgY29weS5tZXRhO1xyXG4gICAgICAgIHJldHVybiBhd2FpdCBwcmlzbWEuZXZlbnQudXBkYXRlKHsgd2hlcmU6IHsgaWQ6IGV2dElkIH0sIGRhdGE6IGNvcHksIGluY2x1ZGU6IGluY2x1ZGVDb3Vyc2VzID8geyBjb3Vyc2VzOiB0cnVlIH0gOiB1bmRlZmluZWQgfSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gSGVscGVyOiBzYWZlbHkgY3JlYXRlIGV2ZW50OyByZXRyeSB3aXRob3V0IG1ldGEgaWYgbmVjZXNzYXJ5XHJcbiAgICBjb25zdCBzYWZlQ3JlYXRlRXZlbnQgPSBhc3luYyAoZGF0YSwgaW5jbHVkZUNvdXJzZXMgPSBmYWxzZSkgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCBwcmlzbWEuZXZlbnQuY3JlYXRlKHsgZGF0YSwgaW5jbHVkZTogaW5jbHVkZUNvdXJzZXMgPyB7IGNvdXJzZXM6IHRydWUgfSA6IHVuZGVmaW5lZCB9KTtcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGlmICghaXNNaXNzaW5nQ29sdW1uRXJyb3IoZSkpIHRocm93IGU7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdbZXZlbnRzLzppZF0gcmV0cnlpbmcgY3JlYXRlIHdpdGhvdXQgYG1ldGFgIGR1ZSB0byBEQiBzY2hlbWEgbWlzbWF0Y2gnKTtcclxuICAgICAgICBjb25zdCBjb3B5ID0geyAuLi5kYXRhIH07XHJcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb3B5LCAnbWV0YScpKSBkZWxldGUgY29weS5tZXRhO1xyXG4gICAgICAgIHJldHVybiBhd2FpdCBwcmlzbWEuZXZlbnQuY3JlYXRlKHsgZGF0YTogY29weSwgaW5jbHVkZTogaW5jbHVkZUNvdXJzZXMgPyB7IGNvdXJzZXM6IHRydWUgfSA6IHVuZGVmaW5lZCB9KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHN3aXRjaCAobWV0aG9kKSB7XHJcbiAgICAgIGNhc2UgJ0dFVCc6IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgZXZlbnQgPSBhd2FpdCBzYWZlRmluZEV2ZW50KGlkLCB0cnVlKTtcclxuICAgICAgICAgIGlmICghZXZlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDA0KS5qc29uKHsgY29kZTogJ05PVF9GT1VORCcsIG1lc3NhZ2U6ICdFdmVudCBub3QgZm91bmQnIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoMjAwKS5qc29uKHsgc3VjY2VzczogdHJ1ZSwgZXZlbnQgfSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBbZXZlbnRzLzppZF0gR0VUIHByaXNtYSBlcnJvciBmb3IgaWQ9JHtpZH06YCwgZXJyICYmIGVyci5tZXNzYWdlID8gZXJyLm1lc3NhZ2UgOiBlcnIpO1xyXG4gICAgICAgICAgLy8gUHJpc21hIHVucmVhY2hhYmxlIC0+IGZhbGxiYWNrIHRvIGZpbGUgc3RvcmVcclxuICAgICAgICAgIGlmIChlcnIgJiYgKGVyci5jb2RlID09PSAnUDEwMDEnIHx8IFN0cmluZyhlcnIubWVzc2FnZSB8fCAnJykuaW5jbHVkZXMoXCJDYW4ndCByZWFjaCBkYXRhYmFzZVwiKSkpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBjb25zdCBsb2NhbCA9IGZhbGxiYWNrLmZpbmQoaWQpO1xyXG4gICAgICAgICAgICAgIGlmICghbG9jYWwpIHJldHVybiByZXMuc3RhdHVzKDQwNCkuanNvbih7IGNvZGU6ICdOT1RfRk9VTkQnLCBtZXNzYWdlOiAnRXZlbnQgbm90IGZvdW5kJyB9KTtcclxuICAgICAgICAgICAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oeyBzdWNjZXNzOiB0cnVlLCBldmVudDogbG9jYWwgfSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGZlKSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignW2V2ZW50cy86aWRdIGZhbGxiYWNrLmZpbmQgZXJyb3I6JywgZmUgJiYgZmUubWVzc2FnZSA/IGZlLm1lc3NhZ2UgOiBmZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNhc2UgJ1BBVENIJzoge1xyXG4gIGNvbnN0IHVwZGF0ZURhdGEgPSB7IC4uLnJlcS5ib2R5IH0gfHwge307XHJcbiAgICAgICAgY29uc29sZS5sb2coYFtldmVudHMvOmlkXSBQQVRDSCBwYXlsb2FkIGZvciBpZD0ke2lkfTpgLCBKU09OLnN0cmluZ2lmeSh1cGRhdGVEYXRhKSk7XHJcblxyXG4gICAgICAgIC8vIE5vcm1hbGl6ZSBjb21tb24gY2xpZW50LXNpZGUgZmllbGQgbmFtZXMgdG8gREIgY29sdW1uIG5hbWVzXHJcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh1cGRhdGVEYXRhLCAnY291cnNlSWQnKSkge1xyXG4gICAgICAgICAgdXBkYXRlRGF0YS5jb3Vyc2VfaWQgPSB1cGRhdGVEYXRhLmNvdXJzZUlkO1xyXG4gICAgICAgICAgZGVsZXRlIHVwZGF0ZURhdGEuY291cnNlSWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG5vcm1hbGl6ZSByb29tIC0+IGxvY2F0aW9uIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxyXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodXBkYXRlRGF0YSwgJ3Jvb20nKSAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHVwZGF0ZURhdGEsICdsb2NhdGlvbicpKSB7XHJcbiAgICAgICAgICB1cGRhdGVEYXRhLmxvY2F0aW9uID0gdXBkYXRlRGF0YS5yb29tO1xyXG4gICAgICAgICAgZGVsZXRlIHVwZGF0ZURhdGEucm9vbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh1cGRhdGVEYXRhLCAndXNlcklkJykpIHtcclxuICAgICAgICAgIHVwZGF0ZURhdGEudXNlcl9pZCA9IHVwZGF0ZURhdGEudXNlcklkO1xyXG4gICAgICAgICAgZGVsZXRlIHVwZGF0ZURhdGEudXNlcklkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ29udmVydCBkYXRlIHN0cmluZ3MgdG8gRGF0ZSBvYmplY3RzIGZvciBQcmlzbWEgd2hlcmUgYXBwcm9wcmlhdGVcclxuICAgICAgICBpZiAodXBkYXRlRGF0YS5kYXRlKSB7XHJcbiAgICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZURhdGVGb3JTdG9yYWdlKHVwZGF0ZURhdGEuZGF0ZSk7XHJcbiAgICAgICAgICBpZiAocGFyc2VkKSB7XHJcbiAgICAgICAgICAgIC8vIFJlamVjdCB1cGRhdGVzIHRoYXQgc2V0IHRoZSBldmVudCBkYXRlIHRvIGJlZm9yZSB0b2RheSAobG9jYWwpXHJcbiAgICAgICAgICAgIGlmIChpc0JlZm9yZVRvZGF5TG9jYWwocGFyc2VkKSkgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHsgY29kZTogJ1BBU1RfREFURScsIG1lc3NhZ2U6ICdDYW5ub3Qgc2V0IGV2ZW50IGRhdGUgYmVmb3JlIHRvZGF5JyB9KTtcclxuICAgICAgICAgICAgdXBkYXRlRGF0YS5kYXRlID0gcGFyc2VkO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDb252ZXJ0IGVuZERhdGUvZW5kX2RhdGUgdG8gRGF0ZSBvYmplY3QgaWYgcHJlc2VudFxyXG4gICAgICAgIGlmICh1cGRhdGVEYXRhLmVuZERhdGUgfHwgdXBkYXRlRGF0YS5lbmRfZGF0ZSkge1xyXG4gICAgICAgICAgY29uc3QgZW5kVmFsID0gdXBkYXRlRGF0YS5lbmREYXRlIHx8IHVwZGF0ZURhdGEuZW5kX2RhdGU7XHJcbiAgICAgICAgICBjb25zdCBwYXJzZWRFbmQgPSBwYXJzZURhdGVGb3JTdG9yYWdlKGVuZFZhbCk7XHJcbiAgICAgICAgICBpZiAocGFyc2VkRW5kKSB1cGRhdGVEYXRhLmVuZF9kYXRlID0gcGFyc2VkRW5kO1xyXG4gICAgICAgICAgZGVsZXRlIHVwZGF0ZURhdGEuZW5kRGF0ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSBmaWVsZHMgdGhhdCBzaG91bGRuJ3QgYmUgdXBkYXRlZFxyXG4gICAgICAgIGRlbGV0ZSB1cGRhdGVEYXRhLmlkO1xyXG4gICAgICAgIGRlbGV0ZSB1cGRhdGVEYXRhLmNyZWF0ZWRfYXQ7XHJcbiAgICAgICAgZGVsZXRlIHVwZGF0ZURhdGEudXNlcl9pZDtcclxuXHJcbiAgICAgICAgLy8gTm9ybWFsaXplIGluY29taW5nIG1ldGEgZmllbGQgKGFsbG93IGNsaWVudCB0byBzZW5kIHN0cnVjdHVyZWQgSlNPTiBtZXRhKVxyXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodXBkYXRlRGF0YSwgJ21ldGEnKSkge1xyXG4gICAgICAgICAgLy8gbGVhdmUgYXMtaXM7IHBlcnNpc3RlZCBiZWxvdyB2aWEgcGlja1ByaXNtYUZpZWxkc1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3Qgd2FudHNBcmNoaXZlZCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh1cGRhdGVEYXRhLCAnYXJjaGl2ZWQnKSA/ICEhdXBkYXRlRGF0YS5hcmNoaXZlZCA6IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHVwZGF0ZURhdGEsICdjb21wbGV0ZWQnKSkge1xyXG4gICAgICAgICAgdXBkYXRlRGF0YS5jb21wbGV0ZWQgPSAhIXVwZGF0ZURhdGEuY29tcGxldGVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSWYgYXJjaGl2aW5nL3VuYXJjaGl2aW5nIHJlcXVlc3RlZCwgbW92ZSBiZXR3ZWVuIHRhYmxlc1xyXG4gICAgICAgIGlmICh3YW50c0FyY2hpdmVkID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAvLyBNb3ZlIGZyb20gRXZlbnQgLT4gQXJjaGl2ZWRFdmVudFxyXG4gICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBhd2FpdCBzYWZlRmluZEV2ZW50KGlkLCBmYWxzZSk7XHJcbiAgICAgICAgICBpZiAoIWV4aXN0aW5nKSByZXR1cm4gcmVzLnN0YXR1cyg0MDQpLmpzb24oeyBjb2RlOiAnTk9UX0ZPVU5EJywgbWVzc2FnZTogJ0V2ZW50IG5vdCBmb3VuZCcgfSk7XHJcblxyXG4gICAgICAgICAgY29uc3QgY3JlYXRlZCA9IGF3YWl0IHByaXNtYS5hcmNoaXZlZEV2ZW50LmNyZWF0ZSh7XHJcbiAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICBvcmlnaW5hbF9ldmVudF9pZDogZXhpc3RpbmcuaWQsXHJcbiAgICAgICAgICAgICAgdGl0bGU6IHVwZGF0ZURhdGEudGl0bGUgfHwgZXhpc3RpbmcudGl0bGUsXHJcbiAgICAgICAgICAgICAgdHlwZTogdXBkYXRlRGF0YS50eXBlIHx8IGV4aXN0aW5nLnR5cGUsXHJcbiAgICAgICAgICAgICAgY291cnNlX2lkOiB1cGRhdGVEYXRhLmNvdXJzZV9pZCA/PyBleGlzdGluZy5jb3Vyc2VfaWQsXHJcbiAgICAgICAgICAgICAgZGF0ZTogdXBkYXRlRGF0YS5kYXRlID8gcGFyc2VEYXRlRm9yU3RvcmFnZSh1cGRhdGVEYXRhLmRhdGUpIDogZXhpc3RpbmcuZGF0ZSxcclxuICAgICAgICAgICAgICB0aW1lOiB1cGRhdGVEYXRhLnRpbWUgPz8gZXhpc3RpbmcudGltZSxcclxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogdXBkYXRlRGF0YS5kZXNjcmlwdGlvbiA/PyBleGlzdGluZy5kZXNjcmlwdGlvbixcclxuICAgICAgICAgICAgICBtZXRhOiB1cGRhdGVEYXRhLm1ldGEgPz8gZXhpc3RpbmcubWV0YSA/PyBudWxsLFxyXG4gICAgICAgICAgICAgIGxvY2F0aW9uOiB1cGRhdGVEYXRhLmxvY2F0aW9uID8/IGV4aXN0aW5nLmxvY2F0aW9uLFxyXG4gICAgICAgICAgICAgIGNvbXBsZXRlZDogdXBkYXRlRGF0YS5jb21wbGV0ZWQgPz8gZXhpc3RpbmcuY29tcGxldGVkLFxyXG4gICAgICAgICAgICAgIHVzZXJfaWQ6IGV4aXN0aW5nLnVzZXJfaWRcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaW5jbHVkZTogeyBjb3Vyc2VzOiB0cnVlIH1cclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIC8vIERlbGV0ZSBvcmlnaW5hbFxyXG4gICAgICAgICAgYXdhaXQgcHJpc21hLmV2ZW50LmRlbGV0ZSh7IHdoZXJlOiB7IGlkIH0gfSk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoMjAwKS5qc29uKHsgc3VjY2VzczogdHJ1ZSwgZXZlbnQ6IGNyZWF0ZWQgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAod2FudHNBcmNoaXZlZCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgIC8vIElmIGFuIGFjdGl2ZSBldmVudCBhbHJlYWR5IGV4aXN0cyB3aXRoIHRoaXMgaWQsIGp1c3QgdXBkYXRlIGl0IChjbGVhciBhcmNoaXZlZCBmbGFnKS5cclxuICAgICAgICAgIC8vIE9ubHkgd2hlbiBubyBhY3RpdmUgZXZlbnQgaXMgcHJlc2VudCBkbyB3ZSBhdHRlbXB0IHRvIHJlc3RvcmUgZnJvbSBhcmNoaXZlZF9ldmVudHMuXHJcbiAgICAgICAgICBjb25zdCBtYXliZUFjdGl2ZSA9IGF3YWl0IHNhZmVGaW5kRXZlbnQoaWQsIGZhbHNlKTtcclxuICAgICAgICAgIGlmIChtYXliZUFjdGl2ZSkge1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhVG9BcHBseSA9IHsgLi4udXBkYXRlRGF0YSwgYXJjaGl2ZWQ6IGZhbHNlIH07XHJcbiAgICAgICAgICAgIC8vIEVuc3VyZSB3ZSBkb24ndCB0cnkgdG8gb3ZlcndyaXRlIGltbXV0YWJsZSBmaWVsZHNcclxuICAgICAgICAgICAgZGVsZXRlIGRhdGFUb0FwcGx5LmlkOyBkZWxldGUgZGF0YVRvQXBwbHkuY3JlYXRlZF9hdDsgZGVsZXRlIGRhdGFUb0FwcGx5LnVzZXJfaWQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWQgPSBhd2FpdCBzYWZlVXBkYXRlRXZlbnQoaWQsIGRhdGFUb0FwcGx5LCB0cnVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoMjAwKS5qc29uKHsgc3VjY2VzczogdHJ1ZSwgZXZlbnQ6IHVwZGF0ZWQgfSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gTW92ZSBmcm9tIEFyY2hpdmVkRXZlbnQgLT4gRXZlbnRcclxuICAgICAgICAgIC8vIFRoZSBhcmNoaXZlZCB0YWJsZSBtYXkgYmUga2V5ZWQgZWl0aGVyIGJ5IG9yaWdpbmFsX2V2ZW50X2lkIG9yIGl0cyBvd24gaWQgZGVwZW5kaW5nIG9uIGhvd1xyXG4gICAgICAgICAgLy8gcmVjb3JkcyB3ZXJlIGNyZWF0ZWQvbWlncmF0ZWQuIFRyeSBib3RoIGxvb2t1cHMgc28gdW5hcmNoaXZlIHN1Y2NlZWRzIHJlZ2FyZGxlc3MuXHJcbiAgICAgICAgICBsZXQgYXJjaGl2ZWRSZWMgPSBhd2FpdCBwcmlzbWEuYXJjaGl2ZWRFdmVudC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgb3JpZ2luYWxfZXZlbnRfaWQ6IGlkIH0gfSk7XHJcbiAgICAgICAgICBsZXQgZGVsZXRlS2V5ID0geyBvcmlnaW5hbF9ldmVudF9pZDogaWQgfTtcclxuICAgICAgICAgIGlmICghYXJjaGl2ZWRSZWMpIHtcclxuICAgICAgICAgICAgLy8gdHJ5IGZhbGxiYWNrOiB0aGUgcHJvdmlkZWQgaWQgbWlnaHQgYmUgdGhlIGFyY2hpdmVkRXZlbnQuaWRcclxuICAgICAgICAgICAgYXJjaGl2ZWRSZWMgPSBhd2FpdCBwcmlzbWEuYXJjaGl2ZWRFdmVudC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQgfSB9KTtcclxuICAgICAgICAgICAgaWYgKGFyY2hpdmVkUmVjKSBkZWxldGVLZXkgPSB7IGlkIH07XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKCFhcmNoaXZlZFJlYykge1xyXG4gICAgICAgICAgICBjb25zdCBhdHRlbXB0ZWQgPSBbJ29yaWdpbmFsX2V2ZW50X2lkJywgJ2lkJ107XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgW2V2ZW50cy86aWRdIHVuYXJjaGl2ZSBmYWlsZWQgZm9yIGlkPSR7aWR9OiBhcmNoaXZlZCByZWNvcmQgbm90IGZvdW5kIChhdHRlbXB0ZWQga2V5czogJHthdHRlbXB0ZWQuam9pbignLCcpfSlgKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDA0KS5qc29uKHsgY29kZTogJ05PVF9GT1VORCcsIG1lc3NhZ2U6ICdBcmNoaXZlZCBldmVudCBub3QgZm91bmQnLCBhdHRlbXB0ZWQgfSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgY29uc3QgY3JlYXRlZCA9IGF3YWl0IHNhZmVDcmVhdGVFdmVudCh7XHJcbiAgICAgICAgICAgIHRpdGxlOiB1cGRhdGVEYXRhLnRpdGxlIHx8IGFyY2hpdmVkUmVjLnRpdGxlLFxyXG4gICAgICAgICAgICB0eXBlOiB1cGRhdGVEYXRhLnR5cGUgfHwgYXJjaGl2ZWRSZWMudHlwZSxcclxuICAgICAgICAgICAgY291cnNlX2lkOiB1cGRhdGVEYXRhLmNvdXJzZV9pZCA/PyBhcmNoaXZlZFJlYy5jb3Vyc2VfaWQsXHJcbiAgICAgICAgICAgIGRhdGU6IHVwZGF0ZURhdGEuZGF0ZSA/IHBhcnNlRGF0ZUZvclN0b3JhZ2UodXBkYXRlRGF0YS5kYXRlKSA6IGFyY2hpdmVkUmVjLmRhdGUsXHJcbiAgICAgICAgICAgIHRpbWU6IHVwZGF0ZURhdGEudGltZSA/PyBhcmNoaXZlZFJlYy50aW1lLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogdXBkYXRlRGF0YS5kZXNjcmlwdGlvbiA/PyBhcmNoaXZlZFJlYy5kZXNjcmlwdGlvbixcclxuICAgICAgICAgICAgbWV0YTogdXBkYXRlRGF0YS5tZXRhID8/IGFyY2hpdmVkUmVjLm1ldGEgPz8gbnVsbCxcclxuICAgICAgICAgICAgbG9jYXRpb246IHVwZGF0ZURhdGEubG9jYXRpb24gPz8gYXJjaGl2ZWRSZWMubG9jYXRpb24sXHJcbiAgICAgICAgICAgIGNvbXBsZXRlZDogdXBkYXRlRGF0YS5jb21wbGV0ZWQgPz8gYXJjaGl2ZWRSZWMuY29tcGxldGVkLFxyXG4gICAgICAgICAgICBhcmNoaXZlZDogZmFsc2UsXHJcbiAgICAgICAgICAgIHVzZXJfaWQ6IGFyY2hpdmVkUmVjLnVzZXJfaWRcclxuICAgICAgICAgIH0sIHRydWUpO1xyXG5cclxuICAgICAgICAgIC8vIERlbGV0ZSBhcmNoaXZlZCBjb3B5IHVzaW5nIHRoZSByZXNvbHZlZCBrZXlcclxuICAgICAgICAgIGF3YWl0IHByaXNtYS5hcmNoaXZlZEV2ZW50LmRlbGV0ZSh7IHdoZXJlOiBkZWxldGVLZXkgfSk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoMjAwKS5qc29uKHsgc3VjY2VzczogdHJ1ZSwgZXZlbnQ6IGNyZWF0ZWQgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAvLyBPdGhlcndpc2UsIHVwZGF0ZSBpbiB3aGljaGV2ZXIgdGFibGUgdGhlIGV2ZW50IGN1cnJlbnRseSByZXNpZGVzXHJcbiAgLy8gVHJ5IEV2ZW50IGZpcnN0XHJcbiAgICAgICAgLy8gVmFsaWRhdGU6IGVuZm9yY2UgbWluIHNjaGVkdWxpbmcgb2Zmc2V0IG9ubHkgd2hlbiBhIHRpbWUgaXMgcHJvdmlkZWQgKGkuZS4sIGEgdGltZWQgZXZlbnQpXHJcbiAgICAgICAgaWYgKHVwZGF0ZURhdGEudGltZSkge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcclxuICAgICAgICAgICAgY29uc3QgbWluQWxsb3dlZCA9IG5ldyBEYXRlKG5vdy5nZXRUaW1lKCkgKyBNSU5fU0NIRURVTEVfT0ZGU0VUX01TKTtcclxuICAgICAgICAgICAgLy8gY29tYmluZSBlaXRoZXIgcHJvdmlkZWQgZGF0ZSBvciBleGlzdGluZyBldmVudCBkYXRlIHdpdGggbmV3IHRpbWVcclxuICAgICAgICAgICAgbGV0IGJhc2VEYXRlID0gdXBkYXRlRGF0YS5kYXRlID8gbmV3IERhdGUodXBkYXRlRGF0YS5kYXRlKSA6IG51bGw7XHJcbiAgICAgICAgICAgIGlmICghYmFzZURhdGUpIHtcclxuICAgICAgICAgICAgICAvLyB0cnkgdG8gbG9va3VwIGN1cnJlbnQgcmVjb3JkIGRhdGUgdG8gY29tYmluZSB3aXRoIHByb3ZpZGVkIHRpbWVcclxuICAgICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IGF3YWl0IHNhZmVGaW5kRXZlbnQoaWQsIGZhbHNlKSB8fCBhd2FpdCBwcmlzbWEuYXJjaGl2ZWRFdmVudC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgb3JpZ2luYWxfZXZlbnRfaWQ6IGlkIH0gfSk7XHJcbiAgICAgICAgICAgICAgYmFzZURhdGUgPSBleGlzdGluZyA/IG5ldyBEYXRlKGV4aXN0aW5nLmRhdGUpIDogbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWJhc2VEYXRlIHx8IGlzTmFOKGJhc2VEYXRlLmdldFRpbWUoKSkpIHtcclxuICAgICAgICAgICAgICAvLyBJbnN0ZWFkIG9mIGZhaWxpbmcgdGhlIGVudGlyZSB1cGRhdGUgd2hlbiB0aGUgYmFzZSBkYXRlIGlzIHVua25vd24gKHdoaWNoXHJcbiAgICAgICAgICAgICAgLy8gY2FuIGhhcHBlbiBmb3IgbWlncmF0ZWQgb3IgcGFydGlhbCByZWNvcmRzKSwgbG9nIGFuZCBza2lwIHRoZSBtaW4tb2Zmc2V0IGNoZWNrLlxyXG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihgW2V2ZW50cy86aWRdIFBBVENIIHNraXBwaW5nIHRpbWUgbWluLW9mZnNldCBjaGVjazogYmFzZURhdGUgbWlzc2luZyBvciBpbnZhbGlkIGZvciBpZD0ke2lkfWApO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGNvbnN0IFtoaCwgbW1dID0gU3RyaW5nKHVwZGF0ZURhdGEudGltZSkuc3BsaXQoJzonKS5tYXAoTnVtYmVyKTtcclxuICAgICAgICAgICAgICBjb25zdCBpbmNvbWluZ0RhdGVUaW1lID0gbmV3IERhdGUoYmFzZURhdGUuZ2V0RnVsbFllYXIoKSwgYmFzZURhdGUuZ2V0TW9udGgoKSwgYmFzZURhdGUuZ2V0RGF0ZSgpLCBoaCB8fCAwLCBtbSB8fCAwKTtcclxuICAgICAgICAgICAgICBpZiAoaXNOYU4oaW5jb21pbmdEYXRlVGltZS5nZXRUaW1lKCkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFtldmVudHMvOmlkXSBQQVRDSCBpbnZhbGlkIGluY29taW5nRGF0ZVRpbWUgZm9yIGlkPSR7aWR9LCBza2lwcGluZyBtaW4tb2Zmc2V0IGNoZWNrYCk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbmNvbWluZ0RhdGVUaW1lIDwgbWluQWxsb3dlZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gS2VlcCB0aGUgZXhpc3RpbmcgZW5mb3JjZW1lbnQgaWYgdGhlIGNvbXB1dGVkIGRhdGV0aW1lIGlzIHZhbGlkXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDApLmpzb24oeyBjb2RlOiAnU0NIRURfTUlOX09GRlNFVCcsIG1lc3NhZ2U6IGBQbGVhc2Ugc2NoZWR1bGUgZXZlbnRzIGF0IGxlYXN0ICR7TUlOX1NDSEVEVUxFX09GRlNFVF9MQUJFTH0gZnJvbSBub3cuYCB9KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAvLyBJZiBhbnl0aGluZyBnb2VzIHdyb25nIGR1cmluZyB0aGlzIG5vbi1jcml0aWNhbCB2YWxpZGF0aW9uLCBsb2cgYW5kIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgW2V2ZW50cy86aWRdIFBBVENIIHRpbWUgdmFsaWRhdGlvbiBmYWlsZWQgZm9yIGlkPSR7aWR9OmAsIGVyciAmJiBlcnIubWVzc2FnZSA/IGVyci5tZXNzYWdlIDogZXJyKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEhlbHBlcjogcGljayBvbmx5IGZpZWxkcyB0aGF0IGV4aXN0IG9uIHRoZSBQcmlzbWEgRXZlbnQvQXJjaGl2ZWRFdmVudCBtb2RlbHNcclxuICAgICAgICBjb25zdCBwaWNrUHJpc21hRmllbGRzID0gKHNyYykgPT4ge1xyXG4gICAgICAgICAgY29uc3QgYWxsb3dlZCA9IFsndGl0bGUnLCAndHlwZScsICdjb3Vyc2VfaWQnLCAnZGF0ZScsICd0aW1lJywgJ2VuZF9kYXRlJywgJ2Rlc2NyaXB0aW9uJywgJ2NvbXBsZXRlZCcsICdhcmNoaXZlZCcsICdsb2NhdGlvbicsICdtZXRhJ107XHJcbiAgICAgICAgICBjb25zdCBvdXQgPSB7fTtcclxuICAgICAgICAgIGZvciAoY29uc3QgayBvZiBhbGxvd2VkKSB7XHJcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3JjLCBrKSkgb3V0W2tdID0gc3JjW2tdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIG91dDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBBdHRlbXB0IHRvIHVwZGF0ZSBpbiBhY3RpdmUgZXZlbnRzOyBpZiBub3QgZm91bmQsIHRyeSBhcmNoaXZlZCB0YWJsZSBleHBsaWNpdGx5XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIC8vIGRpYWdub3N0aWM6IGNoZWNrIHdoZXJlIHRoZSByZWNvcmQgY3VycmVudGx5IGV4aXN0c1xyXG4gICAgICAgICAgY29uc3QgZXhpc3RpbmdFdmVudCA9IGF3YWl0IHNhZmVGaW5kRXZlbnQoaWQsIGZhbHNlKTtcclxuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nQXJjaGl2ZWQgPSBhd2FpdCBwcmlzbWEuYXJjaGl2ZWRFdmVudC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgb3JpZ2luYWxfZXZlbnRfaWQ6IGlkIH0gfSk7XHJcbiAgICAgICAgICBjb25zb2xlLmluZm8oYFtldmVudHMvOmlkXSB1cGRhdGUgdGFyZ2V0IGxvb2t1cCBmb3IgaWQ9JHtpZH06IGV2ZW50PSR7ZXhpc3RpbmdFdmVudCA/ICdmb3VuZCcgOiAnbWlzc2luZyd9LCBhcmNoaXZlZD0ke2V4aXN0aW5nQXJjaGl2ZWQgPyAnZm91bmQnIDogJ21pc3NpbmcnfWApO1xyXG5cclxuICAgICAgICAgIGNvbnN0IGRhdGFUb0FwcGx5ID0gcGlja1ByaXNtYUZpZWxkcyh1cGRhdGVEYXRhKTtcclxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWQgPSBhd2FpdCBzYWZlVXBkYXRlRXZlbnQoaWQsIGRhdGFUb0FwcGx5LCB0cnVlKTtcclxuICAgICAgICAgIHJldHVybiByZXMuc3RhdHVzKDIwMCkuanNvbih7IHN1Y2Nlc3M6IHRydWUsIGV2ZW50OiB1cGRhdGVkIH0pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgW2V2ZW50cy86aWRdIHByaXNtYS5ldmVudC51cGRhdGUgZXJyb3IgZm9yIGlkPSR7aWR9OmAsIGVyciAmJiBlcnIubWVzc2FnZSA/IGVyci5tZXNzYWdlIDogZXJyKTtcclxuXHJcbiAgICAgICAgICAvLyBUcnkgdGhlIGZpbGUtYmFja2VkIGZhbGxiYWNrIGZvciBhbnkgdXBkYXRlIGVycm9yIHNvIFVJIGRvZXNuJ3QgYnJlYWsgd2hlbiBQcmlzbWEvREIgaXMgZmxha3lcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsID0gZmFsbGJhY2sudXBkYXRlKGlkLCB1cGRhdGVEYXRhKTtcclxuICAgICAgICAgICAgaWYgKGxvY2FsKSByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oeyBzdWNjZXNzOiB0cnVlLCBldmVudDogbG9jYWwsIGZhbGxiYWNrOiB0cnVlIH0pO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZmUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW2V2ZW50cy86aWRdIGZhbGxiYWNrLnVwZGF0ZSBlcnJvcjonLCBmZSAmJiBmZS5tZXNzYWdlID8gZmUubWVzc2FnZSA6IGZlKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBJZiB0aGUgZXJyb3IgaXMgcmVjb3JkIG5vdCBmb3VuZCBpbiB0aGUgcHJpbWFyeSB0YWJsZSwgdHJ5IGFyY2hpdmVkRXZlbnQgKGRhdGFiYXNlLXNpZGUpXHJcbiAgICAgICAgICBpZiAoZXJyICYmIGVyci5jb2RlID09PSAnUDIwMjUnKSB7XHJcbiAgICAgICAgICAgIC8vIElmIHJlY29yZCB3YXNuJ3QgZm91bmQgaW4gYWN0aXZlIGV2ZW50cywgdHJ5IHVwZGF0aW5nIGFyY2hpdmVkIHJlY29yZC5cclxuICAgICAgICAgICAgLy8gQXJjaGl2ZWQgcm93cyBtYXkgYmUga2V5ZWQgYnkgb3JpZ2luYWxfZXZlbnRfaWQgb3IgYnkgdGhlaXIgb3duIGlkOyB0cnkgYm90aC5cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBjb25zdCBhcmNoaXZlZFVwZGF0ZSA9IGF3YWl0IHByaXNtYS5hcmNoaXZlZEV2ZW50LnVwZGF0ZSh7IHdoZXJlOiB7IG9yaWdpbmFsX2V2ZW50X2lkOiBpZCB9LCBkYXRhOiBwaWNrUHJpc21hRmllbGRzKHVwZGF0ZURhdGEpLCBpbmNsdWRlOiB7IGNvdXJzZXM6IHRydWUgfSB9KTtcclxuICAgICAgICAgICAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oeyBzdWNjZXNzOiB0cnVlLCBldmVudDogYXJjaGl2ZWRVcGRhdGUgfSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycjIpIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmluZm8oYFtldmVudHMvOmlkXSBhcmNoaXZlZEV2ZW50LnVwZGF0ZSBieSBvcmlnaW5hbF9ldmVudF9pZCBmYWlsZWQgZm9yIGlkPSR7aWR9LCB0cnlpbmcgYnkgYXJjaGl2ZWQgaWRgKTtcclxuICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBhcmNoaXZlZFVwZGF0ZTIgPSBhd2FpdCBwcmlzbWEuYXJjaGl2ZWRFdmVudC51cGRhdGUoeyB3aGVyZTogeyBpZCB9LCBkYXRhOiBwaWNrUHJpc21hRmllbGRzKHVwZGF0ZURhdGEpLCBpbmNsdWRlOiB7IGNvdXJzZXM6IHRydWUgfSB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXMuc3RhdHVzKDIwMCkuanNvbih7IHN1Y2Nlc3M6IHRydWUsIGV2ZW50OiBhcmNoaXZlZFVwZGF0ZTIgfSk7XHJcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyMykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgW2V2ZW50cy86aWRdIGFyY2hpdmVkRXZlbnQudXBkYXRlIGVycm9yIGZvciBpZD0ke2lkfTpgLCBlcnIzICYmIGVycjMubWVzc2FnZSA/IGVycjMubWVzc2FnZSA6IGVycjMpO1xyXG4gICAgICAgICAgICAgICAgLy8gQWRkIGF0dGVtcHRlZCBrZXlzIHRvIGVycm9yIGZvciBkZWJ1Z2dpbmdcclxuICAgICAgICAgICAgICAgIGVycjMuYXR0ZW1wdGVkID0gWydvcmlnaW5hbF9ldmVudF9pZCcsICdpZCddO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyMztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBTb21lIFByaXNtYSBlcnJvcnMgaW5jbHVkZSB1c2VmdWwgbWV0YWRhdGEgLSBzdXJmYWNlIGl0IGluIGRldmVsb3BtZW50XHJcbiAgICAgICAgICBpZiAoZXJyICYmIGVyci5tZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXMuc3RhdHVzKDUwMCkuanNvbih7IGNvZGU6ICdQUklTTUFfRVJST1InLCBtZXNzYWdlOiAnRGF0YWJhc2UgdXBkYXRlIGZhaWxlZCcsIGRldGFpbHM6IGVyci5tZXNzYWdlIH0pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIE90aGVyd2lzZSByZS10aHJvdyB0byBiZSBoYW5kbGVkIGJ5IG91dGVyIGNhdGNoXHJcbiAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjYXNlICdERUxFVEUnOiB7XHJcbiAgICAgICAgLy8gSWYgY2xpZW50IHJlcXVlc3RlZCBkZWxldGluZyB0aGUgZW50aXJlIHNlcmllcyAoYWxsIG1hdGVyaWFsaXplZCBvY2N1cnJlbmNlcyksXHJcbiAgICAgICAgLy8gc3VwcG9ydCA/c2NvcGU9YWxsIGJ5IGRlbGV0aW5nIGFsbCBldmVudHMgd2l0aCB0aGUgc2FtZSB0ZW1wbGF0ZV9pZCBhbmQgdGhlIHRlbXBsYXRlIHJlY29yZC5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3Qgc2NvcGUgPSByZXEucXVlcnkgJiYgcmVxLnF1ZXJ5LnNjb3BlID8gU3RyaW5nKHJlcS5xdWVyeS5zY29wZSkgOiBudWxsO1xyXG4gICAgICAgICAgaWYgKHNjb3BlID09PSAnYWxsJykge1xyXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBldmVudCBpbiBhY3RpdmUgZXZlbnRzIGZpcnN0XHJcbiAgICAgICAgICAgIGNvbnN0IGV2ID0gYXdhaXQgc2FmZUZpbmRFdmVudChpZCwgZmFsc2UpO1xyXG4gICAgICAgICAgICBsZXQgdHBsSWQgPSBldiA/IGV2LnRlbXBsYXRlX2lkIDogbnVsbDtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIG5vdCBmb3VuZCBpbiBhY3RpdmUgZXZlbnRzLCB0cnkgYXJjaGl2ZWQgbG9va3VwXHJcbiAgICAgICAgICAgIGlmICghdHBsSWQpIHtcclxuICAgICAgICAgICAgICBjb25zdCBhcmNoaXZlZCA9IGF3YWl0IHByaXNtYS5hcmNoaXZlZEV2ZW50LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBvcmlnaW5hbF9ldmVudF9pZDogaWQgfSB9KSB8fCBhd2FpdCBwcmlzbWEuYXJjaGl2ZWRFdmVudC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQgfSB9KTtcclxuICAgICAgICAgICAgICB0cGxJZCA9IGFyY2hpdmVkID8gYXJjaGl2ZWQudGVtcGxhdGVfaWQgOiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRwbElkKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHsgY29kZTogJ05PX1RFTVBMQVRFJywgbWVzc2FnZTogJ0V2ZW50IGlzIG5vdCBwYXJ0IG9mIGEgcmVwZWF0IHNlcmllcyBvciB0ZW1wbGF0ZSBpZCBpcyBtaXNzaW5nJyB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRGVsZXRlIGFsbCBtYXRlcmlhbGl6ZWQgZXZlbnRzIGFuZCB0aGUgdGVtcGxhdGUgaW4gYSB0cmFuc2FjdGlvblxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByaXNtYS4kdHJhbnNhY3Rpb24oYXN5bmMgKHR4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkZWxldGVkID0gYXdhaXQgdHguZXZlbnQuZGVsZXRlTWFueSh7IHdoZXJlOiB7IHRlbXBsYXRlX2lkOiB0cGxJZCB9IH0pO1xyXG4gICAgICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBkZWxldGUgdGhlIHRlbXBsYXRlIHJlY29yZDsgaWdub3JlIGlmIGFscmVhZHkgcmVtb3ZlZFxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgYXdhaXQgdHguZXZlbnRUZW1wbGF0ZS5kZWxldGUoeyB3aGVyZTogeyBpZDogdHBsSWQgfSB9KTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge1xyXG4gICAgICAgICAgICAgICAgICAvLyBzd2FsbG93IG5vdC1mb3VuZCBlcnJvcnMgZm9yIHRlbXBsYXRlIGRlbGV0aW9uXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVsZXRlZDtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oeyBzdWNjZXNzOiB0cnVlLCBtZXNzYWdlOiAnU2VyaWVzIGRlbGV0ZWQnLCBkZWxldGVkQ291bnQ6IHJlc3VsdC5jb3VudCB9KTtcclxuICAgICAgICAgICAgfSBjYXRjaCAodHhFcnIpIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbZXZlbnRzLzppZF0gREVMRVRFIHNlcmllcyB0cmFuc2FjdGlvbiBlcnJvciBmb3IgdGVtcGxhdGVfaWQ9JHt0cGxJZH06YCwgdHhFcnIgJiYgdHhFcnIubWVzc2FnZSA/IHR4RXJyLm1lc3NhZ2UgOiB0eEVycik7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNTAwKS5qc29uKHsgY29kZTogJ0RFTEVURV9TRVJJRVNfRkFJTEVEJywgbWVzc2FnZTogJ0ZhaWxlZCB0byBkZWxldGUgZXZlbnQgc2VyaWVzJywgZGV0YWlsczogdHhFcnIgJiYgdHhFcnIubWVzc2FnZSA/IHR4RXJyLm1lc3NhZ2UgOiBudWxsIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGZhbGwgYmFjayB0byBzaW5nbGUtZXZlbnQgZGVsZXRlXHJcbiAgICAgICAgICBhd2FpdCBwcmlzbWEuZXZlbnQuZGVsZXRlKHsgd2hlcmU6IHsgaWQgfSB9KTtcclxuICAgICAgICAgIHJldHVybiByZXMuc3RhdHVzKDIwMCkuanNvbih7IHN1Y2Nlc3M6IHRydWUsIG1lc3NhZ2U6ICdFdmVudCBkZWxldGVkJyB9KTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFtldmVudHMvOmlkXSBERUxFVEUgcHJpc21hLmV2ZW50LmRlbGV0ZSBlcnJvciBmb3IgaWQ9JHtpZH06YCwgZXJyICYmIGVyci5tZXNzYWdlID8gZXJyLm1lc3NhZ2UgOiBlcnIpO1xyXG4gICAgICAgICAgLy8gSWYgREIgdW5yZWFjaGFibGUsIHRyeSBmaWxlIGZhbGxiYWNrXHJcbiAgICAgICAgICBpZiAoZXJyICYmIChlcnIuY29kZSA9PT0gJ1AxMDAxJyB8fCBTdHJpbmcoZXJyLm1lc3NhZ2UgfHwgJycpLmluY2x1ZGVzKFwiQ2FuJ3QgcmVhY2ggZGF0YWJhc2VcIikpKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgbG9jYWwgPSBmYWxsYmFjay5kZWxldGUoaWQpO1xyXG4gICAgICAgICAgICAgIGlmIChsb2NhbCkgcmV0dXJuIHJlcy5zdGF0dXMoMjAwKS5qc29uKHsgc3VjY2VzczogdHJ1ZSwgbWVzc2FnZTogJ0V2ZW50IGRlbGV0ZWQnLCBldmVudDogbG9jYWwgfSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGZlKSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignW2V2ZW50cy86aWRdIGZhbGxiYWNrLmRlbGV0ZSBlcnJvcjonLCBmZSAmJiBmZS5tZXNzYWdlID8gZmUubWVzc2FnZSA6IGZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gVHJ5IGFyY2hpdmVkXHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyBUcnkgZGVsZXRlIGJ5IG9yaWdpbmFsX2V2ZW50X2lkIGZpcnN0XHJcbiAgICAgICAgICAgIGF3YWl0IHByaXNtYS5hcmNoaXZlZEV2ZW50LmRlbGV0ZSh7IHdoZXJlOiB7IG9yaWdpbmFsX2V2ZW50X2lkOiBpZCB9IH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oeyBzdWNjZXNzOiB0cnVlLCBtZXNzYWdlOiAnQXJjaGl2ZWQgZXZlbnQgZGVsZXRlZCcgfSk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlcnIyKSB7XHJcbiAgICAgICAgICAgIC8vIElmIG5vdCBmb3VuZCwgYXR0ZW1wdCB0byBkZWxldGUgYnkgYXJjaGl2ZWQgcmVjb3JkIGlkXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgYXdhaXQgcHJpc21hLmFyY2hpdmVkRXZlbnQuZGVsZXRlKHsgd2hlcmU6IHsgaWQgfSB9KTtcclxuICAgICAgICAgICAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oeyBzdWNjZXNzOiB0cnVlLCBtZXNzYWdlOiAnQXJjaGl2ZWQgZXZlbnQgZGVsZXRlZCcgfSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycjMpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDQpLmpzb24oeyBjb2RlOiAnTk9UX0ZPVU5EJywgbWVzc2FnZTogJ0V2ZW50IG5vdCBmb3VuZCcgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmVzLnNldEhlYWRlcignQWxsb3cnLCBbJ0dFVCcsICdQQVRDSCcsICdERUxFVEUnXSk7XHJcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDA1KS5qc29uKHsgXHJcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSwgXHJcbiAgICAgICAgICBlcnJvcjogYE1ldGhvZCAke21ldGhvZH0gTm90IEFsbG93ZWRgIFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFdmVudHMgW2lkXSBBUEkgZXJyb3I6JywgZXJyb3IpO1xyXG5cclxuICAgIGlmIChlcnJvci5jb2RlID09PSAnUDIwMjUnKSB7XHJcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwNCkuanNvbih7IGNvZGU6ICdOT1RfRk9VTkQnLCBtZXNzYWdlOiAnRXZlbnQgbm90IGZvdW5kJyB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzLnN0YXR1cyg1MDApLmpzb24oeyBjb2RlOiAnSU5URVJOQUxfRVJST1InLCBtZXNzYWdlOiAnSW50ZXJuYWwgc2VydmVyIGVycm9yJywgZGV0YWlsczogZXJyb3IubWVzc2FnZSB9KTtcclxuICB9XHJcbn0iXSwibmFtZXMiOlsicHJpc21hIiwicmVxdWlyZSIsImZhbGxiYWNrIiwiTUlOX1NDSEVEVUxFX09GRlNFVF9NUyIsIk1JTl9TQ0hFRFVMRV9PRkZTRVRfTEFCRUwiLCJpc0RhdGVPbmx5IiwidmFsdWUiLCJ0ZXN0IiwicGFyc2VEYXRlRm9yU3RvcmFnZSIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsInMiLCJTdHJpbmciLCJEYXRlIiwicGFyc2VkIiwiaXNOYU4iLCJnZXRUaW1lIiwiaXNCZWZvcmVUb2RheUxvY2FsIiwiZGF0ZSIsImQiLCJub3ciLCJ0b2RheVN0YXJ0IiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsImdldERhdGUiLCJwcm92aWRlZFN0YXJ0IiwiaGFuZGxlciIsInJlcSIsInJlcyIsIm1ldGhvZCIsImlkIiwicXVlcnkiLCJzdGF0dXMiLCJqc29uIiwiY29kZSIsIm1lc3NhZ2UiLCJpc01pc3NpbmdDb2x1bW5FcnJvciIsImVyciIsIm0iLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwic2FmZUZpbmRFdmVudCIsImV2dElkIiwiaW5jbHVkZUNvdXJzZXMiLCJldmVudCIsImZpbmRVbmlxdWUiLCJ3aGVyZSIsImluY2x1ZGUiLCJjb3Vyc2VzIiwiZSIsImJhc2VTZWxlY3QiLCJ0aXRsZSIsInR5cGUiLCJsb2NhdGlvbiIsImFyY2hpdmVkIiwiY291cnNlX2lkIiwidGVtcGxhdGVfaWQiLCJ0aW1lIiwiZW5kX2RhdGUiLCJkZXNjcmlwdGlvbiIsImNvbXBsZXRlZCIsInVzZXJfaWQiLCJjcmVhdGVkX2F0IiwidXBkYXRlZF9hdCIsInNlbGVjdCIsInNhZmVVcGRhdGVFdmVudCIsImRhdGEiLCJ1cGRhdGUiLCJ1bmRlZmluZWQiLCJjb25zb2xlIiwid2FybiIsImNvcHkiLCJoYXNPd25Qcm9wZXJ0eSIsIm1ldGEiLCJzYWZlQ3JlYXRlRXZlbnQiLCJjcmVhdGUiLCJzdWNjZXNzIiwiZXJyb3IiLCJsb2NhbCIsImZpbmQiLCJmZSIsInVwZGF0ZURhdGEiLCJib2R5IiwibG9nIiwiSlNPTiIsInN0cmluZ2lmeSIsImNvdXJzZUlkIiwicm9vbSIsInVzZXJJZCIsImVuZERhdGUiLCJlbmRWYWwiLCJwYXJzZWRFbmQiLCJ3YW50c0FyY2hpdmVkIiwiZXhpc3RpbmciLCJjcmVhdGVkIiwiYXJjaGl2ZWRFdmVudCIsIm9yaWdpbmFsX2V2ZW50X2lkIiwiZGVsZXRlIiwibWF5YmVBY3RpdmUiLCJkYXRhVG9BcHBseSIsInVwZGF0ZWQiLCJhcmNoaXZlZFJlYyIsImRlbGV0ZUtleSIsImF0dGVtcHRlZCIsImpvaW4iLCJtaW5BbGxvd2VkIiwiYmFzZURhdGUiLCJoaCIsIm1tIiwic3BsaXQiLCJtYXAiLCJOdW1iZXIiLCJpbmNvbWluZ0RhdGVUaW1lIiwicGlja1ByaXNtYUZpZWxkcyIsInNyYyIsImFsbG93ZWQiLCJvdXQiLCJrIiwiZXhpc3RpbmdFdmVudCIsImV4aXN0aW5nQXJjaGl2ZWQiLCJpbmZvIiwiYXJjaGl2ZWRVcGRhdGUiLCJlcnIyIiwiYXJjaGl2ZWRVcGRhdGUyIiwiZXJyMyIsImRldGFpbHMiLCJzY29wZSIsImV2IiwidHBsSWQiLCJyZXN1bHQiLCIkdHJhbnNhY3Rpb24iLCJ0eCIsImRlbGV0ZWQiLCJkZWxldGVNYW55IiwiZXZlbnRUZW1wbGF0ZSIsImlnbm9yZSIsImRlbGV0ZWRDb3VudCIsImNvdW50IiwidHhFcnIiLCJzZXRIZWFkZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api-node)/./pages/api/events/[id].js\n");

/***/ }),

/***/ "@prisma/client":
/*!*********************************!*\
  !*** external "@prisma/client" ***!
  \*********************************/
/***/ ((module) => {

module.exports = require("@prisma/client");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api-node)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fevents%2F%5Bid%5D&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cevents%5C%5Bid%5D.js&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();