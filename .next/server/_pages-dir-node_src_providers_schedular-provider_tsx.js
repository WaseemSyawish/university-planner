"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_pages-dir-node_src_providers_schedular-provider_tsx";
exports.ids = ["_pages-dir-node_src_providers_schedular-provider_tsx"];
exports.modules = {

/***/ "(pages-dir-node)/./src/providers/modal-context.tsx":
/*!*****************************************!*\
  !*** ./src/providers/modal-context.tsx ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ModalContext: () => (/* binding */ ModalContext),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   useModal: () => (/* binding */ useModal)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ ModalContext,default,useModal auto */ \n\nconst ModalContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n    data: {},\n    isOpen: {},\n    canClose: {},\n    setOpen: ()=>{},\n    setClose: ()=>{},\n    setCanClose: ()=>{}\n});\nconst ModalProvider = ({ children })=>{\n    const [isOpen, setIsOpen] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [data, setData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [modals, setModals] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [canClose, setCanCloseState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const setOpen = async (modal, fetchdata, modalId = \"default\")=>{\n        if (fetchdata) {\n            const fetchedData = await fetchdata();\n            setData((prev)=>({\n                    ...prev,\n                    [modalId]: fetchedData || null\n                }));\n        }\n        setIsOpen((prev)=>({\n                ...prev,\n                [modalId]: true\n            }));\n        setModals((prev)=>({\n                ...prev,\n                [modalId]: modal\n            }));\n        // Only update canClose if needed.\n        setCanCloseState((prev)=>prev[modalId] === true ? prev : {\n                ...prev,\n                [modalId]: true\n            });\n    };\n    const setClose = (modalId = \"default\")=>{\n        if (canClose[modalId] !== false) {\n            setIsOpen((prev)=>({\n                    ...prev,\n                    [modalId]: false\n                }));\n            setData((prev)=>({\n                    ...prev,\n                    [modalId]: null\n                }));\n            setModals((prev)=>{\n                const newState = {\n                    ...prev\n                };\n                delete newState[modalId];\n                return newState;\n            });\n            setCanCloseState((prev)=>{\n                const newState = {\n                    ...prev\n                };\n                delete newState[modalId];\n                return newState;\n            });\n        }\n    };\n    const setCanClose = (modalId, value)=>{\n        setCanCloseState((prev)=>{\n            // Only update if the value changes\n            if (prev[modalId] === value) return prev;\n            return {\n                ...prev,\n                [modalId]: value\n            };\n        });\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ModalContext.Provider, {\n        value: {\n            data,\n            isOpen,\n            canClose,\n            setOpen,\n            setClose,\n            setCanClose\n        },\n        children: [\n            children,\n            Object.entries(modals).map(([id, modal])=>isOpen[id] && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), {\n                    children: modal\n                }, id, false, {\n                    fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\university-planner\\\\src\\\\providers\\\\modal-context.tsx\",\n                    lineNumber: 86,\n                    columnNumber: 25\n                }, undefined))\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\university-planner\\\\src\\\\providers\\\\modal-context.tsx\",\n        lineNumber: 80,\n        columnNumber: 5\n    }, undefined);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ModalProvider);\nconst useModal = ()=>{\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ModalContext);\n    if (!context) {\n        throw new Error(\"useModal must be used within a ModalProvider\");\n    }\n    return context;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL3NyYy9wcm92aWRlcnMvbW9kYWwtY29udGV4dC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFFbUU7QUFlNUQsTUFBTUksNkJBQWVILG9EQUFhQSxDQUFtQjtJQUMxREksTUFBTSxDQUFDO0lBQ1BDLFFBQVEsQ0FBQztJQUNUQyxVQUFVLENBQUM7SUFDWEMsU0FBUyxLQUFPO0lBQ2hCQyxVQUFVLEtBQU87SUFDakJDLGFBQWEsS0FBTztBQUN0QixHQUFHO0FBTUgsTUFBTUMsZ0JBQThDLENBQUMsRUFBRUMsUUFBUSxFQUFFO0lBQy9ELE1BQU0sQ0FBQ04sUUFBUU8sVUFBVSxHQUFHViwrQ0FBUUEsQ0FBMEIsQ0FBQztJQUMvRCxNQUFNLENBQUNFLE1BQU1TLFFBQVEsR0FBR1gsK0NBQVFBLENBQXNCLENBQUM7SUFDdkQsTUFBTSxDQUFDWSxRQUFRQyxVQUFVLEdBQUdiLCtDQUFRQSxDQUFrQyxDQUFDO0lBQ3ZFLE1BQU0sQ0FBQ0ksVUFBVVUsaUJBQWlCLEdBQUdkLCtDQUFRQSxDQUEwQixDQUFDO0lBRXhFLE1BQU1LLFVBQVUsT0FDZFUsT0FDQUMsV0FDQUMsVUFBa0IsU0FBUztRQUUzQixJQUFJRCxXQUFXO1lBQ2IsTUFBTUUsY0FBYyxNQUFNRjtZQUMxQkwsUUFBUSxDQUFDUSxPQUFVO29CQUFFLEdBQUdBLElBQUk7b0JBQUUsQ0FBQ0YsUUFBUSxFQUFFQyxlQUFlO2dCQUFLO1FBQy9EO1FBQ0FSLFVBQVUsQ0FBQ1MsT0FBVTtnQkFBRSxHQUFHQSxJQUFJO2dCQUFFLENBQUNGLFFBQVEsRUFBRTtZQUFLO1FBQ2hESixVQUFVLENBQUNNLE9BQVU7Z0JBQUUsR0FBR0EsSUFBSTtnQkFBRSxDQUFDRixRQUFRLEVBQUVGO1lBQU07UUFDakQsa0NBQWtDO1FBQ2xDRCxpQkFBaUIsQ0FBQ0ssT0FDaEJBLElBQUksQ0FBQ0YsUUFBUSxLQUFLLE9BQU9FLE9BQU87Z0JBQUUsR0FBR0EsSUFBSTtnQkFBRSxDQUFDRixRQUFRLEVBQUU7WUFBSztJQUUvRDtJQUVBLE1BQU1YLFdBQVcsQ0FBQ1csVUFBa0IsU0FBUztRQUMzQyxJQUFJYixRQUFRLENBQUNhLFFBQVEsS0FBSyxPQUFPO1lBQy9CUCxVQUFVLENBQUNTLE9BQVU7b0JBQUUsR0FBR0EsSUFBSTtvQkFBRSxDQUFDRixRQUFRLEVBQUU7Z0JBQU07WUFDakROLFFBQVEsQ0FBQ1EsT0FBVTtvQkFBRSxHQUFHQSxJQUFJO29CQUFFLENBQUNGLFFBQVEsRUFBRTtnQkFBSztZQUM5Q0osVUFBVSxDQUFDTTtnQkFDVCxNQUFNQyxXQUFXO29CQUFFLEdBQUdELElBQUk7Z0JBQUM7Z0JBQzNCLE9BQU9DLFFBQVEsQ0FBQ0gsUUFBUTtnQkFDeEIsT0FBT0c7WUFDVDtZQUNBTixpQkFBaUIsQ0FBQ0s7Z0JBQ2hCLE1BQU1DLFdBQVc7b0JBQUUsR0FBR0QsSUFBSTtnQkFBQztnQkFDM0IsT0FBT0MsUUFBUSxDQUFDSCxRQUFRO2dCQUN4QixPQUFPRztZQUNUO1FBQ0Y7SUFDRjtJQUVBLE1BQU1iLGNBQWMsQ0FBQ1UsU0FBaUJJO1FBQ3BDUCxpQkFBaUIsQ0FBQ0s7WUFDaEIsbUNBQW1DO1lBQ25DLElBQUlBLElBQUksQ0FBQ0YsUUFBUSxLQUFLSSxPQUFPLE9BQU9GO1lBQ3BDLE9BQU87Z0JBQUUsR0FBR0EsSUFBSTtnQkFBRSxDQUFDRixRQUFRLEVBQUVJO1lBQU07UUFDckM7SUFDRjtJQUVBLHFCQUNFLDhEQUFDcEIsYUFBYXFCLFFBQVE7UUFDcEJELE9BQU87WUFBRW5CO1lBQU1DO1lBQVFDO1lBQVVDO1lBQVNDO1lBQVVDO1FBQVk7O1lBRS9ERTtZQUNBYyxPQUFPQyxPQUFPLENBQUNaLFFBQVFhLEdBQUcsQ0FDekIsQ0FBQyxDQUFDQyxJQUFJWCxNQUFNLEdBQ1ZaLE1BQU0sQ0FBQ3VCLEdBQUcsa0JBQUksOERBQUM3Qix1REFBYzs4QkFBV2tCO21CQUFMVzs7Ozs7Ozs7Ozs7QUFJN0M7QUFFQSxpRUFBZWxCLGFBQWFBLEVBQUM7QUFFdEIsTUFBTW9CLFdBQVc7SUFDdEIsTUFBTUMsVUFBVTlCLGlEQUFVQSxDQUFDRTtJQUMzQixJQUFJLENBQUM0QixTQUFTO1FBQ1osTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0lBQ0EsT0FBT0Q7QUFDVCxFQUFFIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXHVuaXZlcnNpdHktcGxhbm5lclxcc3JjXFxwcm92aWRlcnNcXG1vZGFsLWNvbnRleHQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xyXG5cclxuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XHJcblxyXG5pbnRlcmZhY2UgTW9kYWxDb250ZXh0VHlwZSB7XHJcbiAgZGF0YTogUmVjb3JkPHN0cmluZywgYW55PjtcclxuICBpc09wZW46IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+O1xyXG4gIGNhbkNsb3NlOiBSZWNvcmQ8c3RyaW5nLCBib29sZWFuPjtcclxuICBzZXRDYW5DbG9zZTogKG1vZGFsSWQ6IHN0cmluZywgY2FuQ2xvc2U6IGJvb2xlYW4pID0+IHZvaWQ7XHJcbiAgc2V0T3BlbjogKFxyXG4gICAgbW9kYWw6IFJlYWN0LlJlYWN0Tm9kZSxcclxuICAgIGZldGNoZGF0YT86ICgpID0+IFByb21pc2U8YW55PixcclxuICAgIG1vZGFsSWQ/OiBzdHJpbmdcclxuICApID0+IHZvaWQ7XHJcbiAgc2V0Q2xvc2U6IChtb2RhbElkPzogc3RyaW5nKSA9PiB2b2lkO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgTW9kYWxDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxNb2RhbENvbnRleHRUeXBlPih7XHJcbiAgZGF0YToge30sXHJcbiAgaXNPcGVuOiB7fSxcclxuICBjYW5DbG9zZToge30sXHJcbiAgc2V0T3BlbjogKCkgPT4ge30sXHJcbiAgc2V0Q2xvc2U6ICgpID0+IHt9LFxyXG4gIHNldENhbkNsb3NlOiAoKSA9PiB7fSxcclxufSk7XHJcblxyXG5pbnRlcmZhY2UgTW9kYWxQcm92aWRlclByb3BzIHtcclxuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xyXG59XHJcblxyXG5jb25zdCBNb2RhbFByb3ZpZGVyOiBSZWFjdC5GQzxNb2RhbFByb3ZpZGVyUHJvcHM+ID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xyXG4gIGNvbnN0IFtpc09wZW4sIHNldElzT3Blbl0gPSB1c2VTdGF0ZTxSZWNvcmQ8c3RyaW5nLCBib29sZWFuPj4oe30pO1xyXG4gIGNvbnN0IFtkYXRhLCBzZXREYXRhXSA9IHVzZVN0YXRlPFJlY29yZDxzdHJpbmcsIGFueT4+KHt9KTtcclxuICBjb25zdCBbbW9kYWxzLCBzZXRNb2RhbHNdID0gdXNlU3RhdGU8UmVjb3JkPHN0cmluZywgUmVhY3QuUmVhY3ROb2RlPj4oe30pO1xyXG4gIGNvbnN0IFtjYW5DbG9zZSwgc2V0Q2FuQ2xvc2VTdGF0ZV0gPSB1c2VTdGF0ZTxSZWNvcmQ8c3RyaW5nLCBib29sZWFuPj4oe30pO1xyXG5cclxuICBjb25zdCBzZXRPcGVuID0gYXN5bmMgKFxyXG4gICAgbW9kYWw6IFJlYWN0LlJlYWN0Tm9kZSxcclxuICAgIGZldGNoZGF0YT86ICgpID0+IFByb21pc2U8YW55PixcclxuICAgIG1vZGFsSWQ6IHN0cmluZyA9IFwiZGVmYXVsdFwiXHJcbiAgKSA9PiB7XHJcbiAgICBpZiAoZmV0Y2hkYXRhKSB7XHJcbiAgICAgIGNvbnN0IGZldGNoZWREYXRhID0gYXdhaXQgZmV0Y2hkYXRhKCk7XHJcbiAgICAgIHNldERhdGEoKHByZXYpID0+ICh7IC4uLnByZXYsIFttb2RhbElkXTogZmV0Y2hlZERhdGEgfHwgbnVsbCB9KSk7XHJcbiAgICB9XHJcbiAgICBzZXRJc09wZW4oKHByZXYpID0+ICh7IC4uLnByZXYsIFttb2RhbElkXTogdHJ1ZSB9KSk7XHJcbiAgICBzZXRNb2RhbHMoKHByZXYpID0+ICh7IC4uLnByZXYsIFttb2RhbElkXTogbW9kYWwgfSkpO1xyXG4gICAgLy8gT25seSB1cGRhdGUgY2FuQ2xvc2UgaWYgbmVlZGVkLlxyXG4gICAgc2V0Q2FuQ2xvc2VTdGF0ZSgocHJldikgPT5cclxuICAgICAgcHJldlttb2RhbElkXSA9PT0gdHJ1ZSA/IHByZXYgOiB7IC4uLnByZXYsIFttb2RhbElkXTogdHJ1ZSB9XHJcbiAgICApO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IHNldENsb3NlID0gKG1vZGFsSWQ6IHN0cmluZyA9IFwiZGVmYXVsdFwiKSA9PiB7XHJcbiAgICBpZiAoY2FuQ2xvc2VbbW9kYWxJZF0gIT09IGZhbHNlKSB7XHJcbiAgICAgIHNldElzT3BlbigocHJldikgPT4gKHsgLi4ucHJldiwgW21vZGFsSWRdOiBmYWxzZSB9KSk7XHJcbiAgICAgIHNldERhdGEoKHByZXYpID0+ICh7IC4uLnByZXYsIFttb2RhbElkXTogbnVsbCB9KSk7XHJcbiAgICAgIHNldE1vZGFscygocHJldikgPT4ge1xyXG4gICAgICAgIGNvbnN0IG5ld1N0YXRlID0geyAuLi5wcmV2IH07XHJcbiAgICAgICAgZGVsZXRlIG5ld1N0YXRlW21vZGFsSWRdO1xyXG4gICAgICAgIHJldHVybiBuZXdTdGF0ZTtcclxuICAgICAgfSk7XHJcbiAgICAgIHNldENhbkNsb3NlU3RhdGUoKHByZXYpID0+IHtcclxuICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IHsgLi4ucHJldiB9O1xyXG4gICAgICAgIGRlbGV0ZSBuZXdTdGF0ZVttb2RhbElkXTtcclxuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IHNldENhbkNsb3NlID0gKG1vZGFsSWQ6IHN0cmluZywgdmFsdWU6IGJvb2xlYW4pID0+IHtcclxuICAgIHNldENhbkNsb3NlU3RhdGUoKHByZXYpID0+IHtcclxuICAgICAgLy8gT25seSB1cGRhdGUgaWYgdGhlIHZhbHVlIGNoYW5nZXNcclxuICAgICAgaWYgKHByZXZbbW9kYWxJZF0gPT09IHZhbHVlKSByZXR1cm4gcHJldjtcclxuICAgICAgcmV0dXJuIHsgLi4ucHJldiwgW21vZGFsSWRdOiB2YWx1ZSB9O1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxNb2RhbENvbnRleHQuUHJvdmlkZXJcclxuICAgICAgdmFsdWU9e3sgZGF0YSwgaXNPcGVuLCBjYW5DbG9zZSwgc2V0T3Blbiwgc2V0Q2xvc2UsIHNldENhbkNsb3NlIH19XHJcbiAgICA+XHJcbiAgICAgIHtjaGlsZHJlbn1cclxuICAgICAge09iamVjdC5lbnRyaWVzKG1vZGFscykubWFwKFxyXG4gICAgICAgIChbaWQsIG1vZGFsXSkgPT5cclxuICAgICAgICAgIGlzT3BlbltpZF0gJiYgPFJlYWN0LkZyYWdtZW50IGtleT17aWR9Pnttb2RhbH08L1JlYWN0LkZyYWdtZW50PlxyXG4gICAgICApfVxyXG4gICAgPC9Nb2RhbENvbnRleHQuUHJvdmlkZXI+XHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1vZGFsUHJvdmlkZXI7XHJcblxyXG5leHBvcnQgY29uc3QgdXNlTW9kYWwgPSAoKSA9PiB7XHJcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoTW9kYWxDb250ZXh0KTtcclxuICBpZiAoIWNvbnRleHQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcInVzZU1vZGFsIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBNb2RhbFByb3ZpZGVyXCIpO1xyXG4gIH1cclxuICByZXR1cm4gY29udGV4dDtcclxufTtcclxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsIk1vZGFsQ29udGV4dCIsImRhdGEiLCJpc09wZW4iLCJjYW5DbG9zZSIsInNldE9wZW4iLCJzZXRDbG9zZSIsInNldENhbkNsb3NlIiwiTW9kYWxQcm92aWRlciIsImNoaWxkcmVuIiwic2V0SXNPcGVuIiwic2V0RGF0YSIsIm1vZGFscyIsInNldE1vZGFscyIsInNldENhbkNsb3NlU3RhdGUiLCJtb2RhbCIsImZldGNoZGF0YSIsIm1vZGFsSWQiLCJmZXRjaGVkRGF0YSIsInByZXYiLCJuZXdTdGF0ZSIsInZhbHVlIiwiUHJvdmlkZXIiLCJPYmplY3QiLCJlbnRyaWVzIiwibWFwIiwiaWQiLCJGcmFnbWVudCIsInVzZU1vZGFsIiwiY29udGV4dCIsIkVycm9yIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./src/providers/modal-context.tsx\n");

/***/ }),

/***/ "(pages-dir-node)/./src/providers/schedular-provider.tsx":
/*!**********************************************!*\
  !*** ./src/providers/schedular-provider.tsx ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SchedulerProvider: () => (/* binding */ SchedulerProvider),\n/* harmony export */   useScheduler: () => (/* binding */ useScheduler),\n/* harmony export */   variants: () => (/* binding */ variants)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _modal_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modal-context */ \"(pages-dir-node)/./src/providers/modal-context.tsx\");\n/* __next_internal_client_entry_do_not_use__ variants,SchedulerProvider,useScheduler auto */ \n// SchedulerContext.tsx\n\n\n// Define the variant options\nconst variants = [\n    \"success\",\n    \"primary\",\n    \"default\",\n    \"warning\",\n    \"danger\"\n];\n// Initial state\nconst initialState = {\n    events: []\n};\n// Reducer function\nconst schedulerReducer = (state, action)=>{\n    switch(action.type){\n        case \"ADD_EVENT\":\n            // avoid duplicates by id\n            if (!action.payload || !action.payload.id) {\n                return state;\n            }\n            if (state.events.some((e)=>e.id === action.payload.id)) return state;\n            return {\n                ...state,\n                events: [\n                    ...state.events,\n                    action.payload\n                ]\n            };\n        case \"REMOVE_EVENT\":\n            return {\n                ...state,\n                events: state.events.filter((event)=>event.id !== action.payload.id)\n            };\n        case \"UPDATE_EVENT\":\n            return {\n                ...state,\n                events: state.events.map((event)=>event.id === action.payload.id ? action.payload : event)\n            };\n        case \"SET_EVENTS\":\n            // ensure payload is deduped by id\n            const list = Array.isArray(action.payload) ? action.payload : [];\n            const seen = new Set();\n            const deduped = list.filter((ev)=>{\n                if (!ev || !ev.id) return false;\n                if (seen.has(ev.id)) return false;\n                seen.add(ev.id);\n                return true;\n            });\n            return {\n                ...state,\n                events: deduped\n            };\n        default:\n            return state;\n    }\n};\n// Create the context with the correct type\nconst SchedulerContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\n// Provider component\nconst SchedulerProvider = ({ children, onAddEvent, onUpdateEvent, onDeleteEvent, initialState, weekStartsOn = \"sunday\", recurrenceOptions })=>{\n    const [state, dispatch] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useReducer)(schedulerReducer, {\n        events: initialState ?? []\n    } // Sets initialState or an empty array as the default\n    );\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SchedulerProvider.useEffect\": ()=>{\n            if (initialState) {\n                dispatch({\n                    type: \"SET_EVENTS\",\n                    payload: initialState\n                });\n            }\n        }\n    }[\"SchedulerProvider.useEffect\"], [\n        initialState\n    ]);\n    // global getters\n    const getDaysInMonth = (month, year)=>{\n        return Array.from({\n            length: new Date(year, month + 1, 0).getDate()\n        }, (_, index)=>({\n                day: index + 1,\n                events: []\n            }));\n    };\n    const getDaysInWeek = (week, year)=>{\n        // Determine if the week should start on Sunday (0) or Monday (1)\n        const startDay = weekStartsOn === \"sunday\" ? 0 : 1;\n        // Get January 1st of the year\n        const janFirst = new Date(year, 0, 1);\n        // Calculate how many days we are offsetting from January 1st\n        const janFirstDayOfWeek = janFirst.getDay();\n        // Calculate the start of the week by finding the correct day in the year\n        const weekStart = new Date(janFirst);\n        weekStart.setDate(janFirst.getDate() + (week - 1) * 7 + (startDay - janFirstDayOfWeek + 7) % 7);\n        // Generate the week's days\n        const days = [];\n        for(let i = 0; i < 7; i++){\n            const day = new Date(weekStart);\n            day.setDate(day.getDate() + i);\n            days.push(day);\n        }\n        return days;\n    };\n    const getWeekNumber = (date)=>{\n        const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));\n        d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));\n        const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));\n        const weekNo = Math.ceil(((d.getTime() - yearStart.getTime()) / 86400000 + 1) / 7);\n        return weekNo;\n    };\n    // Helper function to filter events for a specific day\n    const getEventsForDay = (day, currentDate)=>{\n        return state?.events.filter((event)=>{\n            const eventStart = new Date(event.startDate);\n            const eventEnd = new Date(event.endDate);\n            // Create new Date objects to avoid mutating `currentDate`\n            const startOfDay = new Date(currentDate);\n            startOfDay.setDate(day);\n            startOfDay.setHours(0, 0, 0, 0);\n            const endOfDay = new Date(currentDate);\n            endOfDay.setDate(day + 1);\n            endOfDay.setHours(0, 0, 0, 0);\n            // Check if the event starts or spans across the given day\n            const isSameDay = eventStart.getDate() === day && eventStart.getMonth() === currentDate.getMonth() && eventStart.getFullYear() === currentDate.getFullYear();\n            const isSpanningDay = eventStart < endOfDay && eventEnd >= startOfDay;\n            return isSameDay || isSpanningDay;\n        });\n    };\n    const getDayName = (day)=>{\n        const days = [\n            \"Sun\",\n            \"Mon\",\n            \"Tue\",\n            \"Wed\",\n            \"Thu\",\n            \"Fri\",\n            \"Sat\"\n        ];\n        return days[day];\n    };\n    const getters = {\n        getDaysInMonth,\n        getEventsForDay,\n        getDaysInWeek,\n        getWeekNumber,\n        getDayName\n    };\n    // handlers\n    function handleEventStyling(event, dayEvents, periodOptions) {\n        // Mina-inspired minutes-based layout\n        const toMillis = (d)=>d instanceof Date ? d.getTime() : new Date(d).getTime();\n        const ensureDate = (d)=>d instanceof Date ? d : new Date(d);\n        // Row height per hour - matches the hourly row height used in day/week views (64px)\n        const ROW_PX_PER_HOUR = 64;\n        // Build a list of items for the same day (or overlapping range)\n        const items = (dayEvents || []).filter((ev)=>ev && ev.startDate && ev.endDate).map((ev)=>{\n            const s = ensureDate(ev.startDate);\n            const e = ensureDate(ev.endDate);\n            const startMinutes = s.getHours() * 60 + s.getMinutes();\n            const endMinutes = e.getHours() * 60 + e.getMinutes();\n            const duration = Math.max(1, endMinutes - startMinutes);\n            return {\n                ev,\n                startMinutes,\n                endMinutes,\n                duration\n            };\n        }).sort((a, b)=>a.startMinutes - b.startMinutes || b.endMinutes - a.endMinutes);\n        // Simple column packing like Mina: place each event in the first column that doesn't overlap\n        const columns = [];\n        const columnsIndexMap = [];\n        items.forEach((it, idx)=>{\n            let placed = false;\n            for(let ci = 0; ci < columns.length; ci++){\n                const col = columns[ci];\n                const last = col[col.length - 1];\n                if (it.startMinutes >= last.endMinutes) {\n                    col.push(it);\n                    columnsIndexMap[idx] = ci;\n                    placed = true;\n                    break;\n                }\n            }\n            if (!placed) {\n                columnsIndexMap[idx] = columns.length;\n                columns.push([\n                    it\n                ]);\n            }\n        });\n        const totalCols = Math.max(1, columns.length);\n        // Find current event item\n        const thisStart = ensureDate(event.startDate);\n        const thisEnd = ensureDate(event.endDate);\n        const thisStartMin = thisStart.getHours() * 60 + thisStart.getMinutes();\n        const thisEndMin = thisEnd.getHours() * 60 + thisEnd.getMinutes();\n        const thisDuration = Math.max(1, thisEndMin - thisStartMin);\n        // Determine which column index this event occupies (fallback to 0)\n        let colIndex = 0;\n        for(let ci = 0; ci < columns.length; ci++){\n            if (columns[ci].some((it)=>it.ev.id === event.id)) {\n                colIndex = ci;\n                break;\n            }\n        }\n        const widthPercent = 100 / totalCols;\n        const leftPercent = colIndex * widthPercent;\n        // Compute pixels\n        const topPx = thisStartMin / 60 * ROW_PX_PER_HOUR;\n        const heightPx = Math.max(20, thisDuration / 60 * ROW_PX_PER_HOUR);\n        return {\n            height: `${heightPx}px`,\n            top: `${topPx}px`,\n            zIndex: colIndex + 1,\n            left: `${leftPercent}%`,\n            maxWidth: `${widthPercent}%`,\n            minWidth: `${widthPercent}%`\n        };\n    }\n    async function handleAddEvent(event) {\n        // If a parent handler is provided, call it and await its result. Only\n        // update local state after the parent returns a server-canonical event so\n        // the provider does not keep optimistic (possibly different) values that\n        // get overwritten on reload.\n        if (onAddEvent) {\n            try {\n                const res = await onAddEvent(event);\n                // If parent returned the saved canonical event, use it to update local state\n                if (res && res.id) {\n                    try {\n                        dispatch({\n                            type: \"ADD_EVENT\",\n                            payload: res\n                        });\n                    } catch (e) {}\n                    return res;\n                }\n                // Parent did not return a canonical saved event.\n                // Fall back to local optimistic add so the UI still reflects the new event.\n                try {\n                    dispatch({\n                        type: \"ADD_EVENT\",\n                        payload: event\n                    });\n                } catch (e) {}\n                return event;\n            } catch (e) {\n                // If the error is a client-side (4xx) response, rethrow so callers can show validation\n                // Otherwise (network error or 5xx) we can fallback to local optimistic add to keep UI responsive\n                try {\n                    const status = e && (e.status || e.statusCode || e.response && e.response.status);\n                    if (status && Number(status) >= 400 && Number(status) < 500) {\n                        console.warn('[SchedulerProvider] onAddEvent returned client error, aborting local fallback', status, e);\n                        throw e;\n                    }\n                } catch (inner) {}\n                console.warn('[SchedulerProvider] onAddEvent handler failed, falling back to local add', e);\n            }\n        }\n        dispatch({\n            type: \"ADD_EVENT\",\n            payload: event\n        });\n        return event;\n    }\n    async function handleUpdateEvent(event, id) {\n        // Prefer to let the parent persist the change and return the canonical\n        // event; only then update local state with the authoritative values.\n        if (onUpdateEvent) {\n            try {\n                const res = await onUpdateEvent({\n                    ...event,\n                    id\n                });\n                if (res && res.id) {\n                    try {\n                        dispatch({\n                            type: \"UPDATE_EVENT\",\n                            payload: res\n                        });\n                    } catch (e) {}\n                }\n                return res;\n            } catch (e) {\n                // If parent handler fails, fall back to optimistic local update so UI still reflects change\n                console.warn('[SchedulerProvider] onUpdateEvent handler failed, applying optimistic update', e);\n                try {\n                    dispatch({\n                        type: \"UPDATE_EVENT\",\n                        payload: {\n                            ...event,\n                            id\n                        }\n                    });\n                } catch (err) {}\n                // rethrow so callers can handle failure if needed\n                throw e;\n            }\n        }\n        // No parent handler: do a local optimistic update\n        try {\n            dispatch({\n                type: \"UPDATE_EVENT\",\n                payload: {\n                    ...event,\n                    id\n                }\n            });\n        } catch (e) {\n            console.warn('[SchedulerProvider] local dispatch update failed', e);\n        }\n        return {\n            ...event,\n            id\n        };\n    }\n    function handleDeleteEvent(id) {\n        if (onDeleteEvent) {\n            try {\n                const maybe = onDeleteEvent(id);\n                return maybe;\n            } catch (e) {\n            // fall back to local remove\n            }\n        }\n        dispatch({\n            type: \"REMOVE_EVENT\",\n            payload: {\n                id\n            }\n        });\n    }\n    // Local-only handlers: allow callers to update provider state without delegating\n    // persistence to parent page handlers. Useful when the caller performs the\n    // network request itself and only wants to update UI after confirmation.\n    function handleLocalAddEvent(event) {\n        try {\n            try {\n                // debug: log the incoming event for troubleshooting\n                console.debug('[SchedulerProvider] handleLocalAddEvent incoming:', event);\n            } catch (e) {}\n            dispatch({\n                type: \"ADD_EVENT\",\n                payload: event\n            });\n            try {\n                console.debug('[SchedulerProvider] events after add (count):', state && state.events && state.events.length ? state.events.length + 1 : 'unknown');\n            } catch (e) {}\n        } catch (e) {\n        // swallow - UI best-effort\n        }\n    }\n    function handleLocalUpdateEvent(event) {\n        try {\n            try {\n                console.debug('[SchedulerProvider] handleLocalUpdateEvent incoming:', event);\n            } catch (e) {}\n            if (!event || !event.id) return;\n            dispatch({\n                type: \"UPDATE_EVENT\",\n                payload: event\n            });\n            try {\n                console.debug('[SchedulerProvider] events after update (count):', state && state.events && state.events.length ? state.events.length : 'unknown');\n            } catch (e) {}\n        } catch (e) {\n        // swallow\n        }\n    }\n    const handlers = {\n        handleEventStyling,\n        handleAddEvent,\n        handleUpdateEvent,\n        handleDeleteEvent,\n        // local-only helpers\n        handleLocalAddEvent,\n        handleLocalUpdateEvent\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(SchedulerContext.Provider, {\n        // include recurrenceOptions if passed via props (kept backward compatible)\n        value: {\n            events: state,\n            dispatch,\n            getters,\n            handlers,\n            weekStartsOn,\n            recurrenceOptions\n        },\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_modal_context__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n            children: children\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\university-planner\\\\src\\\\providers\\\\schedular-provider.tsx\",\n            lineNumber: 414,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\university-planner\\\\src\\\\providers\\\\schedular-provider.tsx\",\n        lineNumber: 410,\n        columnNumber: 5\n    }, undefined);\n};\n// Custom hook to use the scheduler context\nconst useScheduler = ()=>{\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(SchedulerContext);\n    if (!context) {\n        throw new Error(\"useScheduler must be used within a SchedulerProvider\");\n    }\n    return context;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL3NyYy9wcm92aWRlcnMvc2NoZWR1bGFyLXByb3ZpZGVyLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFFQSx1QkFBdUI7QUFRUjtBQVc2QjtBQU81Qyw2QkFBNkI7QUFDdEIsTUFBTU0sV0FBVztJQUN0QjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0QsQ0FBVTtBQUVYLGdCQUFnQjtBQUNoQixNQUFNQyxlQUErQjtJQUNuQ0MsUUFBUSxFQUFFO0FBQ1o7QUFFQSxtQkFBbUI7QUFDbkIsTUFBTUMsbUJBQW1CLENBQ3ZCQyxPQUNBQztJQUVBLE9BQVFBLE9BQU9DLElBQUk7UUFDakIsS0FBSztZQUNILHlCQUF5QjtZQUN6QixJQUFJLENBQUNELE9BQU9FLE9BQU8sSUFBSSxDQUFDRixPQUFPRSxPQUFPLENBQUNDLEVBQUUsRUFBRTtnQkFDekMsT0FBT0o7WUFDVDtZQUNBLElBQUlBLE1BQU1GLE1BQU0sQ0FBQ08sSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFRixFQUFFLEtBQUtILE9BQU9FLE9BQU8sQ0FBQ0MsRUFBRSxHQUFHLE9BQU9KO1lBQy9ELE9BQU87Z0JBQUUsR0FBR0EsS0FBSztnQkFBRUYsUUFBUTt1QkFBSUUsTUFBTUYsTUFBTTtvQkFBRUcsT0FBT0UsT0FBTztpQkFBQztZQUFDO1FBRS9ELEtBQUs7WUFDSCxPQUFPO2dCQUNMLEdBQUdILEtBQUs7Z0JBQ1JGLFFBQVFFLE1BQU1GLE1BQU0sQ0FBQ1MsTUFBTSxDQUFDLENBQUNDLFFBQVVBLE1BQU1KLEVBQUUsS0FBS0gsT0FBT0UsT0FBTyxDQUFDQyxFQUFFO1lBQ3ZFO1FBQ0YsS0FBSztZQUNILE9BQU87Z0JBQ0wsR0FBR0osS0FBSztnQkFDUkYsUUFBUUUsTUFBTUYsTUFBTSxDQUFDVyxHQUFHLENBQUMsQ0FBQ0QsUUFDeEJBLE1BQU1KLEVBQUUsS0FBS0gsT0FBT0UsT0FBTyxDQUFDQyxFQUFFLEdBQUdILE9BQU9FLE9BQU8sR0FBR0s7WUFFdEQ7UUFD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LENBQUM7UUFDZixFQUFFLE9BQU9BLEdBQUc7UUFDVixVQUFVO1FBQ1o7SUFDRjtJQUVBLE1BQU1tSSxXQUFxQjtRQUN6QjNEO1FBQ0EyQztRQUNBUztRQUNBRTtRQUNBLHFCQUFxQjtRQUNyQkU7UUFDQUU7SUFDRjtJQUVBLHFCQUNFLDhEQUFDckgsaUJBQWlCdUgsUUFBUTtRQUN4QiwyRUFBMkU7UUFDM0VDLE9BQU87WUFBRTdJLFFBQVFFO1lBQU80QjtZQUFVaUQ7WUFBUzREO1lBQVUvRztZQUFjQztRQUFrQjtrQkFFckYsNEVBQUNoQyxzREFBYUE7c0JBQUUyQjs7Ozs7Ozs7Ozs7QUFHdEIsRUFBRTtBQUVGLDJDQUEyQztBQUNwQyxNQUFNc0gsZUFBZTtJQUMxQixNQUFNQyxVQUFVckosaURBQVVBLENBQUMyQjtJQUMzQixJQUFJLENBQUMwSCxTQUFTO1FBQ1osTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0lBQ0EsT0FBT0Q7QUFDVCxFQUFFIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXHVuaXZlcnNpdHktcGxhbm5lclxcc3JjXFxwcm92aWRlcnNcXHNjaGVkdWxhci1wcm92aWRlci50c3giXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XHJcblxyXG4vLyBTY2hlZHVsZXJDb250ZXh0LnRzeFxyXG5pbXBvcnQgUmVhY3QsIHtcclxuICBjcmVhdGVDb250ZXh0LFxyXG4gIHVzZUNvbnRleHQsXHJcbiAgdXNlUmVkdWNlcixcclxuICBSZWFjdE5vZGUsXHJcbiAgRGlzcGF0Y2gsXHJcbiAgdXNlRWZmZWN0LFxyXG59IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgeyB6IH0gZnJvbSBcInpvZFwiO1xyXG5cclxuaW1wb3J0IHtcclxuICBBY3Rpb24sXHJcbiAgRXZlbnQsXHJcbiAgR2V0dGVycyxcclxuICBIYW5kbGVycyxcclxuICBTY2hlZHVsZXJDb250ZXh0VHlwZSxcclxuICBzdGFydE9mV2VlayxcclxufSBmcm9tIFwiQC90eXBlcy9pbmRleFwiO1xyXG5pbXBvcnQgTW9kYWxQcm92aWRlciBmcm9tIFwiLi9tb2RhbC1jb250ZXh0XCI7XHJcbi8vIERlZmluZSBldmVudCBhbmQgc3RhdGUgdHlwZXNcclxuXHJcbmludGVyZmFjZSBTY2hlZHVsZXJTdGF0ZSB7XHJcbiAgZXZlbnRzOiBFdmVudFtdO1xyXG59XHJcblxyXG4vLyBEZWZpbmUgdGhlIHZhcmlhbnQgb3B0aW9uc1xyXG5leHBvcnQgY29uc3QgdmFyaWFudHMgPSBbXHJcbiAgXCJzdWNjZXNzXCIsXHJcbiAgXCJwcmltYXJ5XCIsXHJcbiAgXCJkZWZhdWx0XCIsXHJcbiAgXCJ3YXJuaW5nXCIsXHJcbiAgXCJkYW5nZXJcIixcclxuXSBhcyBjb25zdDtcclxuXHJcbi8vIEluaXRpYWwgc3RhdGVcclxuY29uc3QgaW5pdGlhbFN0YXRlOiBTY2hlZHVsZXJTdGF0ZSA9IHtcclxuICBldmVudHM6IFtdLFxyXG59O1xyXG5cclxuLy8gUmVkdWNlciBmdW5jdGlvblxyXG5jb25zdCBzY2hlZHVsZXJSZWR1Y2VyID0gKFxyXG4gIHN0YXRlOiBTY2hlZHVsZXJTdGF0ZSxcclxuICBhY3Rpb246IEFjdGlvblxyXG4pOiBTY2hlZHVsZXJTdGF0ZSA9PiB7XHJcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xyXG4gICAgY2FzZSBcIkFERF9FVkVOVFwiOlxyXG4gICAgICAvLyBhdm9pZCBkdXBsaWNhdGVzIGJ5IGlkXHJcbiAgICAgIGlmICghYWN0aW9uLnBheWxvYWQgfHwgIWFjdGlvbi5wYXlsb2FkLmlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzdGF0ZS5ldmVudHMuc29tZShlID0+IGUuaWQgPT09IGFjdGlvbi5wYXlsb2FkLmlkKSkgcmV0dXJuIHN0YXRlO1xyXG4gICAgICByZXR1cm4geyAuLi5zdGF0ZSwgZXZlbnRzOiBbLi4uc3RhdGUuZXZlbnRzLCBhY3Rpb24ucGF5bG9hZF0gfTtcclxuXHJcbiAgICBjYXNlIFwiUkVNT1ZFX0VWRU5UXCI6XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgLi4uc3RhdGUsXHJcbiAgICAgICAgZXZlbnRzOiBzdGF0ZS5ldmVudHMuZmlsdGVyKChldmVudCkgPT4gZXZlbnQuaWQgIT09IGFjdGlvbi5wYXlsb2FkLmlkKSxcclxuICAgICAgfTtcclxuICAgIGNhc2UgXCJVUERBVEVfRVZFTlRcIjpcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICAuLi5zdGF0ZSxcclxuICAgICAgICBldmVudHM6IHN0YXRlLmV2ZW50cy5tYXAoKGV2ZW50KSA9PlxyXG4gICAgICAgICAgZXZlbnQuaWQgPT09IGFjdGlvbi5wYXlsb2FkLmlkID8gYWN0aW9uLnBheWxvYWQgOiBldmVudFxyXG4gICAgICAgICksXHJcbiAgICAgIH07XHJcbiAgICBjYXNlIFwiU0VUX0VWRU5UU1wiOlxyXG4gICAgICAvLyBlbnN1cmUgcGF5bG9hZCBpcyBkZWR1cGVkIGJ5IGlkXHJcbiAgICAgIGNvbnN0IGxpc3QgPSBBcnJheS5pc0FycmF5KGFjdGlvbi5wYXlsb2FkKSA/IGFjdGlvbi5wYXlsb2FkIDogW107XHJcbiAgICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0KCk7XHJcbiAgICAgIGNvbnN0IGRlZHVwZWQgPSBsaXN0LmZpbHRlcigoZXY6IEV2ZW50KSA9PiB7XHJcbiAgICAgICAgaWYgKCFldiB8fCAhZXYuaWQpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAoc2Vlbi5oYXMoZXYuaWQpKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgc2Vlbi5hZGQoZXYuaWQpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsIGV2ZW50czogZGVkdXBlZCB9O1xyXG5cclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiBzdGF0ZTtcclxuICB9XHJcbn07XHJcblxyXG4vLyBDcmVhdGUgdGhlIGNvbnRleHQgd2l0aCB0aGUgY29ycmVjdCB0eXBlXHJcbmNvbnN0IFNjaGVkdWxlckNvbnRleHQgPSBjcmVhdGVDb250ZXh0PFNjaGVkdWxlckNvbnRleHRUeXBlIHwgdW5kZWZpbmVkPihcclxuICB1bmRlZmluZWRcclxuKTtcclxuXHJcbi8vIFByb3ZpZGVyIGNvbXBvbmVudFxyXG5leHBvcnQgY29uc3QgU2NoZWR1bGVyUHJvdmlkZXIgPSAoe1xyXG4gIGNoaWxkcmVuLFxyXG4gIG9uQWRkRXZlbnQsXHJcbiAgb25VcGRhdGVFdmVudCxcclxuICBvbkRlbGV0ZUV2ZW50LFxyXG4gIGluaXRpYWxTdGF0ZSxcclxuICB3ZWVrU3RhcnRzT24gPSBcInN1bmRheVwiLFxyXG4gIHJlY3VycmVuY2VPcHRpb25zLFxyXG59OiB7XHJcbiAgb25BZGRFdmVudD86IChldmVudDogRXZlbnQpID0+IHZvaWQ7XHJcbiAgb25VcGRhdGVFdmVudD86IChldmVudDogRXZlbnQpID0+IHZvaWQ7XHJcbiAgb25EZWxldGVFdmVudD86IChpZDogc3RyaW5nKSA9PiB2b2lkO1xyXG4gIHdlZWtTdGFydHNPbj86IHN0YXJ0T2ZXZWVrO1xyXG4gIGNoaWxkcmVuOiBSZWFjdE5vZGU7XHJcbiAgaW5pdGlhbFN0YXRlPzogRXZlbnRbXTtcclxuICByZWN1cnJlbmNlT3B0aW9ucz86IEFycmF5PHsgaWQ6IHN0cmluZzsgbGFiZWw6IHN0cmluZzsgcnJ1bGVUZW1wbGF0ZT86IHN0cmluZyB8IG51bGwgfT5cclxufSkgPT4ge1xyXG4gIGNvbnN0IFtzdGF0ZSwgZGlzcGF0Y2hdID0gdXNlUmVkdWNlcihcclxuICAgIHNjaGVkdWxlclJlZHVjZXIsXHJcbiAgICB7IGV2ZW50czogaW5pdGlhbFN0YXRlID8/IFtdIH0gLy8gU2V0cyBpbml0aWFsU3RhdGUgb3IgYW4gZW1wdHkgYXJyYXkgYXMgdGhlIGRlZmF1bHRcclxuICApO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKGluaXRpYWxTdGF0ZSkge1xyXG4gICAgICBkaXNwYXRjaCh7IHR5cGU6IFwiU0VUX0VWRU5UU1wiLCBwYXlsb2FkOiBpbml0aWFsU3RhdGUgfSk7XHJcbiAgICB9XHJcbiAgfSwgW2luaXRpYWxTdGF0ZV0pO1xyXG5cclxuICAvLyBnbG9iYWwgZ2V0dGVyc1xyXG4gIGNvbnN0IGdldERheXNJbk1vbnRoID0gKG1vbnRoOiBudW1iZXIsIHllYXI6IG51bWJlcikgPT4ge1xyXG4gICAgcmV0dXJuIEFycmF5LmZyb20oXHJcbiAgICAgIHsgbGVuZ3RoOiBuZXcgRGF0ZSh5ZWFyLCBtb250aCArIDEsIDApLmdldERhdGUoKSB9LFxyXG4gICAgICAoXywgaW5kZXgpID0+ICh7XHJcbiAgICAgICAgZGF5OiBpbmRleCArIDEsXHJcbiAgICAgICAgZXZlbnRzOiBbXSxcclxuICAgICAgfSlcclxuICAgICk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgZ2V0RGF5c0luV2VlayA9ICh3ZWVrOiBudW1iZXIsIHllYXI6IG51bWJlcikgPT4ge1xyXG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSB3ZWVrIHNob3VsZCBzdGFydCBvbiBTdW5kYXkgKDApIG9yIE1vbmRheSAoMSlcclxuICAgIGNvbnN0IHN0YXJ0RGF5ID0gd2Vla1N0YXJ0c09uID09PSBcInN1bmRheVwiID8gMCA6IDE7XHJcblxyXG4gICAgLy8gR2V0IEphbnVhcnkgMXN0IG9mIHRoZSB5ZWFyXHJcbiAgICBjb25zdCBqYW5GaXJzdCA9IG5ldyBEYXRlKHllYXIsIDAsIDEpO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBob3cgbWFueSBkYXlzIHdlIGFyZSBvZmZzZXR0aW5nIGZyb20gSmFudWFyeSAxc3RcclxuICAgIGNvbnN0IGphbkZpcnN0RGF5T2ZXZWVrID0gamFuRmlyc3QuZ2V0RGF5KCk7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBzdGFydCBvZiB0aGUgd2VlayBieSBmaW5kaW5nIHRoZSBjb3JyZWN0IGRheSBpbiB0aGUgeWVhclxyXG4gICAgY29uc3Qgd2Vla1N0YXJ0ID0gbmV3IERhdGUoamFuRmlyc3QpO1xyXG4gICAgd2Vla1N0YXJ0LnNldERhdGUoXHJcbiAgICAgIGphbkZpcnN0LmdldERhdGUoKSArXHJcbiAgICAgICAgKHdlZWsgLSAxKSAqIDcgK1xyXG4gICAgICAgICgoc3RhcnREYXkgLSBqYW5GaXJzdERheU9mV2VlayArIDcpICUgNylcclxuICAgICk7XHJcblxyXG4gICAgLy8gR2VuZXJhdGUgdGhlIHdlZWsncyBkYXlzXHJcbiAgICBjb25zdCBkYXlzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDc7IGkrKykge1xyXG4gICAgICBjb25zdCBkYXkgPSBuZXcgRGF0ZSh3ZWVrU3RhcnQpO1xyXG4gICAgICBkYXkuc2V0RGF0ZShkYXkuZ2V0RGF0ZSgpICsgaSk7XHJcbiAgICAgIGRheXMucHVzaChkYXkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkYXlzO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGdldFdlZWtOdW1iZXIgPSAoZGF0ZTogRGF0ZSkgPT4ge1xyXG4gICAgY29uc3QgZCA9IG5ldyBEYXRlKFxyXG4gICAgICBEYXRlLlVUQyhkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCkpXHJcbiAgICApO1xyXG4gICAgZC5zZXRVVENEYXRlKGQuZ2V0VVRDRGF0ZSgpICsgNCAtIChkLmdldFVUQ0RheSgpIHx8IDcpKTtcclxuICAgIGNvbnN0IHllYXJTdGFydCA9IG5ldyBEYXRlKERhdGUuVVRDKGQuZ2V0VVRDRnVsbFllYXIoKSwgMCwgMSkpO1xyXG4gICAgY29uc3Qgd2Vla05vID0gTWF0aC5jZWlsKFxyXG4gICAgICAoKGQuZ2V0VGltZSgpIC0geWVhclN0YXJ0LmdldFRpbWUoKSkgLyA4NjQwMDAwMCArIDEpIC8gN1xyXG4gICAgKTtcclxuICAgIHJldHVybiB3ZWVrTm87XHJcbiAgfTtcclxuXHJcbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGZpbHRlciBldmVudHMgZm9yIGEgc3BlY2lmaWMgZGF5XHJcbiAgY29uc3QgZ2V0RXZlbnRzRm9yRGF5ID0gKGRheTogbnVtYmVyLCBjdXJyZW50RGF0ZTogRGF0ZSkgPT4ge1xyXG4gICAgcmV0dXJuIHN0YXRlPy5ldmVudHMuZmlsdGVyKChldmVudCkgPT4ge1xyXG4gICAgICBjb25zdCBldmVudFN0YXJ0ID0gbmV3IERhdGUoZXZlbnQuc3RhcnREYXRlKTtcclxuICAgICAgY29uc3QgZXZlbnRFbmQgPSBuZXcgRGF0ZShldmVudC5lbmREYXRlKTtcclxuXHJcbiAgICAgIC8vIENyZWF0ZSBuZXcgRGF0ZSBvYmplY3RzIHRvIGF2b2lkIG11dGF0aW5nIGBjdXJyZW50RGF0ZWBcclxuICAgICAgY29uc3Qgc3RhcnRPZkRheSA9IG5ldyBEYXRlKGN1cnJlbnREYXRlKTtcclxuICAgICAgc3RhcnRPZkRheS5zZXREYXRlKGRheSk7XHJcbiAgICAgIHN0YXJ0T2ZEYXkuc2V0SG91cnMoMCwgMCwgMCwgMCk7XHJcblxyXG4gICAgICBjb25zdCBlbmRPZkRheSA9IG5ldyBEYXRlKGN1cnJlbnREYXRlKTtcclxuICAgICAgZW5kT2ZEYXkuc2V0RGF0ZShkYXkgKyAxKTtcclxuICAgICAgZW5kT2ZEYXkuc2V0SG91cnMoMCwgMCwgMCwgMCk7XHJcblxyXG4gICAgICAvLyBDaGVjayBpZiB0aGUgZXZlbnQgc3RhcnRzIG9yIHNwYW5zIGFjcm9zcyB0aGUgZ2l2ZW4gZGF5XHJcbiAgICAgIGNvbnN0IGlzU2FtZURheSA9XHJcbiAgICAgICAgZXZlbnRTdGFydC5nZXREYXRlKCkgPT09IGRheSAmJlxyXG4gICAgICAgIGV2ZW50U3RhcnQuZ2V0TW9udGgoKSA9PT0gY3VycmVudERhdGUuZ2V0TW9udGgoKSAmJlxyXG4gICAgICAgIGV2ZW50U3RhcnQuZ2V0RnVsbFllYXIoKSA9PT0gY3VycmVudERhdGUuZ2V0RnVsbFllYXIoKTtcclxuXHJcbiAgICAgIGNvbnN0IGlzU3Bhbm5pbmdEYXkgPSBldmVudFN0YXJ0IDwgZW5kT2ZEYXkgJiYgZXZlbnRFbmQgPj0gc3RhcnRPZkRheTtcclxuXHJcbiAgICAgIHJldHVybiBpc1NhbWVEYXkgfHwgaXNTcGFubmluZ0RheTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGdldERheU5hbWUgPSAoZGF5OiBudW1iZXIpID0+IHtcclxuICAgIGNvbnN0IGRheXMgPSBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIl07XHJcbiAgICByZXR1cm4gZGF5c1tkYXldO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGdldHRlcnM6IEdldHRlcnMgPSB7XHJcbiAgICBnZXREYXlzSW5Nb250aCxcclxuICAgIGdldEV2ZW50c0ZvckRheSxcclxuICAgIGdldERheXNJbldlZWssXHJcbiAgICBnZXRXZWVrTnVtYmVyLFxyXG4gICAgZ2V0RGF5TmFtZSxcclxuICB9O1xyXG5cclxuICAvLyBoYW5kbGVyc1xyXG4gIGZ1bmN0aW9uIGhhbmRsZUV2ZW50U3R5bGluZyhcclxuICAgIGV2ZW50OiBFdmVudCwgXHJcbiAgICBkYXlFdmVudHM6IEV2ZW50W10sXHJcbiAgICBwZXJpb2RPcHRpb25zPzogeyBcclxuICAgICAgZXZlbnRzSW5TYW1lUGVyaW9kPzogbnVtYmVyOyBcclxuICAgICAgcGVyaW9kSW5kZXg/OiBudW1iZXI7IFxyXG4gICAgICBhZGp1c3RGb3JQZXJpb2Q/OiBib29sZWFuO1xyXG4gICAgfVxyXG4gICkge1xyXG4gICAgLy8gTWluYS1pbnNwaXJlZCBtaW51dGVzLWJhc2VkIGxheW91dFxyXG4gICAgY29uc3QgdG9NaWxsaXMgPSAoZDogYW55KSA9PiAoZCBpbnN0YW5jZW9mIERhdGUgPyBkLmdldFRpbWUoKSA6IG5ldyBEYXRlKGQpLmdldFRpbWUoKSk7XHJcbiAgICBjb25zdCBlbnN1cmVEYXRlID0gKGQ6IGFueSkgPT4gKGQgaW5zdGFuY2VvZiBEYXRlID8gZCA6IG5ldyBEYXRlKGQpKTtcclxuXHJcbiAgICAvLyBSb3cgaGVpZ2h0IHBlciBob3VyIC0gbWF0Y2hlcyB0aGUgaG91cmx5IHJvdyBoZWlnaHQgdXNlZCBpbiBkYXkvd2VlayB2aWV3cyAoNjRweClcclxuICAgIGNvbnN0IFJPV19QWF9QRVJfSE9VUiA9IDY0O1xyXG5cclxuICAgIC8vIEJ1aWxkIGEgbGlzdCBvZiBpdGVtcyBmb3IgdGhlIHNhbWUgZGF5IChvciBvdmVybGFwcGluZyByYW5nZSlcclxuICAgIGNvbnN0IGl0ZW1zID0gKGRheUV2ZW50cyB8fCBbXSkuZmlsdGVyKChldikgPT4gZXYgJiYgZXYuc3RhcnREYXRlICYmIGV2LmVuZERhdGUpLm1hcChldiA9PiB7XHJcbiAgICAgIGNvbnN0IHMgPSBlbnN1cmVEYXRlKGV2LnN0YXJ0RGF0ZSk7XHJcbiAgICAgIGNvbnN0IGUgPSBlbnN1cmVEYXRlKGV2LmVuZERhdGUpO1xyXG4gICAgICBjb25zdCBzdGFydE1pbnV0ZXMgPSBzLmdldEhvdXJzKCkgKiA2MCArIHMuZ2V0TWludXRlcygpO1xyXG4gICAgICBjb25zdCBlbmRNaW51dGVzID0gZS5nZXRIb3VycygpICogNjAgKyBlLmdldE1pbnV0ZXMoKTtcclxuICAgICAgY29uc3QgZHVyYXRpb24gPSBNYXRoLm1heCgxLCBlbmRNaW51dGVzIC0gc3RhcnRNaW51dGVzKTtcclxuICAgICAgcmV0dXJuIHsgZXYsIHN0YXJ0TWludXRlcywgZW5kTWludXRlcywgZHVyYXRpb24gfTtcclxuICAgIH0pLnNvcnQoKGEsYikgPT4gYS5zdGFydE1pbnV0ZXMgLSBiLnN0YXJ0TWludXRlcyB8fCBiLmVuZE1pbnV0ZXMgLSBhLmVuZE1pbnV0ZXMpO1xyXG5cclxuICAgIC8vIFNpbXBsZSBjb2x1bW4gcGFja2luZyBsaWtlIE1pbmE6IHBsYWNlIGVhY2ggZXZlbnQgaW4gdGhlIGZpcnN0IGNvbHVtbiB0aGF0IGRvZXNuJ3Qgb3ZlcmxhcFxyXG4gICAgY29uc3QgY29sdW1uczogQXJyYXk8QXJyYXk8YW55Pj4gPSBbXTtcclxuICAgIGNvbnN0IGNvbHVtbnNJbmRleE1hcDogbnVtYmVyW10gPSBbXTtcclxuICAgIGl0ZW1zLmZvckVhY2goKGl0LCBpZHgpID0+IHtcclxuICAgICAgbGV0IHBsYWNlZCA9IGZhbHNlO1xyXG4gICAgICBmb3IgKGxldCBjaSA9IDA7IGNpIDwgY29sdW1ucy5sZW5ndGg7IGNpKyspIHtcclxuICAgICAgICBjb25zdCBjb2wgPSBjb2x1bW5zW2NpXTtcclxuICAgICAgICBjb25zdCBsYXN0ID0gY29sW2NvbC5sZW5ndGggLSAxXTtcclxuICAgICAgICBpZiAoaXQuc3RhcnRNaW51dGVzID49IGxhc3QuZW5kTWludXRlcykge1xyXG4gICAgICAgICAgY29sLnB1c2goaXQpO1xyXG4gICAgICAgICAgY29sdW1uc0luZGV4TWFwW2lkeF0gPSBjaTtcclxuICAgICAgICAgIHBsYWNlZCA9IHRydWU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFwbGFjZWQpIHtcclxuICAgICAgICBjb2x1bW5zSW5kZXhNYXBbaWR4XSA9IGNvbHVtbnMubGVuZ3RoO1xyXG4gICAgICAgIGNvbHVtbnMucHVzaChbaXRdKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgdG90YWxDb2xzID0gTWF0aC5tYXgoMSwgY29sdW1ucy5sZW5ndGgpO1xyXG5cclxuICAgIC8vIEZpbmQgY3VycmVudCBldmVudCBpdGVtXHJcbiAgICBjb25zdCB0aGlzU3RhcnQgPSBlbnN1cmVEYXRlKGV2ZW50LnN0YXJ0RGF0ZSk7XHJcbiAgICBjb25zdCB0aGlzRW5kID0gZW5zdXJlRGF0ZShldmVudC5lbmREYXRlKTtcclxuICAgIGNvbnN0IHRoaXNTdGFydE1pbiA9IHRoaXNTdGFydC5nZXRIb3VycygpICogNjAgKyB0aGlzU3RhcnQuZ2V0TWludXRlcygpO1xyXG4gICAgY29uc3QgdGhpc0VuZE1pbiA9IHRoaXNFbmQuZ2V0SG91cnMoKSAqIDYwICsgdGhpc0VuZC5nZXRNaW51dGVzKCk7XHJcbiAgICBjb25zdCB0aGlzRHVyYXRpb24gPSBNYXRoLm1heCgxLCB0aGlzRW5kTWluIC0gdGhpc1N0YXJ0TWluKTtcclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgd2hpY2ggY29sdW1uIGluZGV4IHRoaXMgZXZlbnQgb2NjdXBpZXMgKGZhbGxiYWNrIHRvIDApXHJcbiAgICBsZXQgY29sSW5kZXggPSAwO1xyXG4gICAgZm9yIChsZXQgY2kgPSAwOyBjaSA8IGNvbHVtbnMubGVuZ3RoOyBjaSsrKSB7XHJcbiAgICAgIGlmIChjb2x1bW5zW2NpXS5zb21lKGl0ID0+IGl0LmV2LmlkID09PSBldmVudC5pZCkpIHsgY29sSW5kZXggPSBjaTsgYnJlYWs7IH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB3aWR0aFBlcmNlbnQgPSAxMDAgLyB0b3RhbENvbHM7XHJcbiAgICBjb25zdCBsZWZ0UGVyY2VudCA9IGNvbEluZGV4ICogd2lkdGhQZXJjZW50O1xyXG5cclxuICAgIC8vIENvbXB1dGUgcGl4ZWxzXHJcbiAgICBjb25zdCB0b3BQeCA9ICh0aGlzU3RhcnRNaW4gLyA2MCkgKiBST1dfUFhfUEVSX0hPVVI7XHJcbiAgICBjb25zdCBoZWlnaHRQeCA9IE1hdGgubWF4KDIwLCAodGhpc0R1cmF0aW9uIC8gNjApICogUk9XX1BYX1BFUl9IT1VSKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBoZWlnaHQ6IGAke2hlaWdodFB4fXB4YCxcclxuICAgICAgdG9wOiBgJHt0b3BQeH1weGAsXHJcbiAgICAgIHpJbmRleDogY29sSW5kZXggKyAxLFxyXG4gICAgICBsZWZ0OiBgJHtsZWZ0UGVyY2VudH0lYCxcclxuICAgICAgbWF4V2lkdGg6IGAke3dpZHRoUGVyY2VudH0lYCxcclxuICAgICAgbWluV2lkdGg6IGAke3dpZHRoUGVyY2VudH0lYCxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVBZGRFdmVudChldmVudDogRXZlbnQpIHtcclxuICAgIC8vIElmIGEgcGFyZW50IGhhbmRsZXIgaXMgcHJvdmlkZWQsIGNhbGwgaXQgYW5kIGF3YWl0IGl0cyByZXN1bHQuIE9ubHlcclxuICAgIC8vIHVwZGF0ZSBsb2NhbCBzdGF0ZSBhZnRlciB0aGUgcGFyZW50IHJldHVybnMgYSBzZXJ2ZXItY2Fub25pY2FsIGV2ZW50IHNvXHJcbiAgICAvLyB0aGUgcHJvdmlkZXIgZG9lcyBub3Qga2VlcCBvcHRpbWlzdGljIChwb3NzaWJseSBkaWZmZXJlbnQpIHZhbHVlcyB0aGF0XHJcbiAgICAvLyBnZXQgb3ZlcndyaXR0ZW4gb24gcmVsb2FkLlxyXG4gICAgaWYgKG9uQWRkRXZlbnQpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCByZXM6IGFueSA9IGF3YWl0IG9uQWRkRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgICAgLy8gSWYgcGFyZW50IHJldHVybmVkIHRoZSBzYXZlZCBjYW5vbmljYWwgZXZlbnQsIHVzZSBpdCB0byB1cGRhdGUgbG9jYWwgc3RhdGVcclxuICAgICAgICAgIGlmIChyZXMgJiYgcmVzLmlkKSB7XHJcbiAgICAgICAgICAgIHRyeSB7IGRpc3BhdGNoKHsgdHlwZTogXCJBRERfRVZFTlRcIiwgcGF5bG9hZDogcmVzIH0pOyB9IGNhdGNoIChlKSB7fVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gUGFyZW50IGRpZCBub3QgcmV0dXJuIGEgY2Fub25pY2FsIHNhdmVkIGV2ZW50LlxyXG4gICAgICAgICAgLy8gRmFsbCBiYWNrIHRvIGxvY2FsIG9wdGltaXN0aWMgYWRkIHNvIHRoZSBVSSBzdGlsbCByZWZsZWN0cyB0aGUgbmV3IGV2ZW50LlxyXG4gICAgICAgICAgdHJ5IHsgZGlzcGF0Y2goeyB0eXBlOiBcIkFERF9FVkVOVFwiLCBwYXlsb2FkOiBldmVudCB9KTsgfSBjYXRjaCAoZSkge31cclxuICAgICAgICAgIHJldHVybiBldmVudDtcclxuICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcclxuICAgICAgICAgIC8vIElmIHRoZSBlcnJvciBpcyBhIGNsaWVudC1zaWRlICg0eHgpIHJlc3BvbnNlLCByZXRocm93IHNvIGNhbGxlcnMgY2FuIHNob3cgdmFsaWRhdGlvblxyXG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIChuZXR3b3JrIGVycm9yIG9yIDV4eCkgd2UgY2FuIGZhbGxiYWNrIHRvIGxvY2FsIG9wdGltaXN0aWMgYWRkIHRvIGtlZXAgVUkgcmVzcG9uc2l2ZVxyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gZSAmJiAoZS5zdGF0dXMgfHwgZS5zdGF0dXNDb2RlIHx8IChlLnJlc3BvbnNlICYmIGUucmVzcG9uc2Uuc3RhdHVzKSlcclxuICAgICAgICAgICAgaWYgKHN0YXR1cyAmJiBOdW1iZXIoc3RhdHVzKSA+PSA0MDAgJiYgTnVtYmVyKHN0YXR1cykgPCA1MDApIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tTY2hlZHVsZXJQcm92aWRlcl0gb25BZGRFdmVudCByZXR1cm5lZCBjbGllbnQgZXJyb3IsIGFib3J0aW5nIGxvY2FsIGZhbGxiYWNrJywgc3RhdHVzLCBlKVxyXG4gICAgICAgICAgICAgIHRocm93IGVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBjYXRjaCAoaW5uZXIpIHt9XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1tTY2hlZHVsZXJQcm92aWRlcl0gb25BZGRFdmVudCBoYW5kbGVyIGZhaWxlZCwgZmFsbGluZyBiYWNrIHRvIGxvY2FsIGFkZCcsIGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRpc3BhdGNoKHsgdHlwZTogXCJBRERfRVZFTlRcIiwgcGF5bG9hZDogZXZlbnQgfSk7XHJcbiAgICByZXR1cm4gZXZlbnQ7XHJcbiAgfVxyXG5cclxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVVcGRhdGVFdmVudChldmVudDogRXZlbnQsIGlkOiBzdHJpbmcpIHtcclxuICAgIC8vIFByZWZlciB0byBsZXQgdGhlIHBhcmVudCBwZXJzaXN0IHRoZSBjaGFuZ2UgYW5kIHJldHVybiB0aGUgY2Fub25pY2FsXHJcbiAgICAvLyBldmVudDsgb25seSB0aGVuIHVwZGF0ZSBsb2NhbCBzdGF0ZSB3aXRoIHRoZSBhdXRob3JpdGF0aXZlIHZhbHVlcy5cclxuICAgIGlmIChvblVwZGF0ZUV2ZW50KSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzOiBhbnkgPSBhd2FpdCBvblVwZGF0ZUV2ZW50KHsgLi4uZXZlbnQsIGlkIH0pO1xyXG4gICAgICAgIGlmIChyZXMgJiYgcmVzLmlkKSB7XHJcbiAgICAgICAgICB0cnkgeyBkaXNwYXRjaCh7IHR5cGU6IFwiVVBEQVRFX0VWRU5UXCIsIHBheWxvYWQ6IHJlcyB9KTsgfSBjYXRjaCAoZSkge31cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIC8vIElmIHBhcmVudCBoYW5kbGVyIGZhaWxzLCBmYWxsIGJhY2sgdG8gb3B0aW1pc3RpYyBsb2NhbCB1cGRhdGUgc28gVUkgc3RpbGwgcmVmbGVjdHMgY2hhbmdlXHJcbiAgICAgICAgY29uc29sZS53YXJuKCdbU2NoZWR1bGVyUHJvdmlkZXJdIG9uVXBkYXRlRXZlbnQgaGFuZGxlciBmYWlsZWQsIGFwcGx5aW5nIG9wdGltaXN0aWMgdXBkYXRlJywgZSk7XHJcbiAgICAgICAgdHJ5IHsgZGlzcGF0Y2goeyB0eXBlOiBcIlVQREFURV9FVkVOVFwiLCBwYXlsb2FkOiB7IC4uLmV2ZW50LCBpZCB9IH0pOyB9IGNhdGNoIChlcnIpIHt9XHJcbiAgICAgICAgLy8gcmV0aHJvdyBzbyBjYWxsZXJzIGNhbiBoYW5kbGUgZmFpbHVyZSBpZiBuZWVkZWRcclxuICAgICAgICB0aHJvdyBlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTm8gcGFyZW50IGhhbmRsZXI6IGRvIGEgbG9jYWwgb3B0aW1pc3RpYyB1cGRhdGVcclxuICAgIHRyeSB7XHJcbiAgICAgIGRpc3BhdGNoKHsgdHlwZTogXCJVUERBVEVfRVZFTlRcIiwgcGF5bG9hZDogeyAuLi5ldmVudCwgaWQgfSB9KTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgY29uc29sZS53YXJuKCdbU2NoZWR1bGVyUHJvdmlkZXJdIGxvY2FsIGRpc3BhdGNoIHVwZGF0ZSBmYWlsZWQnLCBlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IC4uLmV2ZW50LCBpZCB9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaGFuZGxlRGVsZXRlRXZlbnQoaWQ6IHN0cmluZykge1xyXG4gICAgaWYgKG9uRGVsZXRlRXZlbnQpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBtYXliZTogYW55ID0gb25EZWxldGVFdmVudChpZCk7XHJcbiAgICAgICAgcmV0dXJuIG1heWJlO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgLy8gZmFsbCBiYWNrIHRvIGxvY2FsIHJlbW92ZVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6IFwiUkVNT1ZFX0VWRU5UXCIsIHBheWxvYWQ6IHsgaWQgfSB9KTtcclxuICB9XHJcblxyXG4gIC8vIExvY2FsLW9ubHkgaGFuZGxlcnM6IGFsbG93IGNhbGxlcnMgdG8gdXBkYXRlIHByb3ZpZGVyIHN0YXRlIHdpdGhvdXQgZGVsZWdhdGluZ1xyXG4gIC8vIHBlcnNpc3RlbmNlIHRvIHBhcmVudCBwYWdlIGhhbmRsZXJzLiBVc2VmdWwgd2hlbiB0aGUgY2FsbGVyIHBlcmZvcm1zIHRoZVxyXG4gIC8vIG5ldHdvcmsgcmVxdWVzdCBpdHNlbGYgYW5kIG9ubHkgd2FudHMgdG8gdXBkYXRlIFVJIGFmdGVyIGNvbmZpcm1hdGlvbi5cclxuICBmdW5jdGlvbiBoYW5kbGVMb2NhbEFkZEV2ZW50KGV2ZW50OiBFdmVudCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBkZWJ1ZzogbG9nIHRoZSBpbmNvbWluZyBldmVudCBmb3IgdHJvdWJsZXNob290aW5nXHJcbiAgICAgICAgY29uc29sZS5kZWJ1ZygnW1NjaGVkdWxlclByb3ZpZGVyXSBoYW5kbGVMb2NhbEFkZEV2ZW50IGluY29taW5nOicsIGV2ZW50KTtcclxuICAgICAgfSBjYXRjaCAoZSkge31cclxuICAgICAgZGlzcGF0Y2goeyB0eXBlOiBcIkFERF9FVkVOVFwiLCBwYXlsb2FkOiBldmVudCB9KTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zb2xlLmRlYnVnKCdbU2NoZWR1bGVyUHJvdmlkZXJdIGV2ZW50cyBhZnRlciBhZGQgKGNvdW50KTonLCAoc3RhdGUgJiYgc3RhdGUuZXZlbnRzICYmIHN0YXRlLmV2ZW50cy5sZW5ndGgpID8gc3RhdGUuZXZlbnRzLmxlbmd0aCArIDEgOiAndW5rbm93bicpO1xyXG4gICAgICB9IGNhdGNoIChlKSB7fVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAvLyBzd2FsbG93IC0gVUkgYmVzdC1lZmZvcnRcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGhhbmRsZUxvY2FsVXBkYXRlRXZlbnQoZXZlbnQ6IEV2ZW50KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnNvbGUuZGVidWcoJ1tTY2hlZHVsZXJQcm92aWRlcl0gaGFuZGxlTG9jYWxVcGRhdGVFdmVudCBpbmNvbWluZzonLCBldmVudCk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XHJcbiAgICAgIGlmICghZXZlbnQgfHwgIWV2ZW50LmlkKSByZXR1cm47XHJcbiAgICAgIGRpc3BhdGNoKHsgdHlwZTogXCJVUERBVEVfRVZFTlRcIiwgcGF5bG9hZDogZXZlbnQgfSk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc29sZS5kZWJ1ZygnW1NjaGVkdWxlclByb3ZpZGVyXSBldmVudHMgYWZ0ZXIgdXBkYXRlIChjb3VudCk6JywgKHN0YXRlICYmIHN0YXRlLmV2ZW50cyAmJiBzdGF0ZS5ldmVudHMubGVuZ3RoKSA/IHN0YXRlLmV2ZW50cy5sZW5ndGggOiAndW5rbm93bicpO1xyXG4gICAgICB9IGNhdGNoIChlKSB7fVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAvLyBzd2FsbG93XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCBoYW5kbGVyczogSGFuZGxlcnMgPSB7XHJcbiAgICBoYW5kbGVFdmVudFN0eWxpbmcsXHJcbiAgICBoYW5kbGVBZGRFdmVudCxcclxuICAgIGhhbmRsZVVwZGF0ZUV2ZW50LFxyXG4gICAgaGFuZGxlRGVsZXRlRXZlbnQsXHJcbiAgICAvLyBsb2NhbC1vbmx5IGhlbHBlcnNcclxuICAgIGhhbmRsZUxvY2FsQWRkRXZlbnQsXHJcbiAgICBoYW5kbGVMb2NhbFVwZGF0ZUV2ZW50LFxyXG4gIH07XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8U2NoZWR1bGVyQ29udGV4dC5Qcm92aWRlclxyXG4gICAgICAvLyBpbmNsdWRlIHJlY3VycmVuY2VPcHRpb25zIGlmIHBhc3NlZCB2aWEgcHJvcHMgKGtlcHQgYmFja3dhcmQgY29tcGF0aWJsZSlcclxuICAgICAgdmFsdWU9e3sgZXZlbnRzOiBzdGF0ZSwgZGlzcGF0Y2gsIGdldHRlcnMsIGhhbmRsZXJzLCB3ZWVrU3RhcnRzT24sIHJlY3VycmVuY2VPcHRpb25zIH19XHJcbiAgICA+XHJcbiAgICAgIDxNb2RhbFByb3ZpZGVyPntjaGlsZHJlbn08L01vZGFsUHJvdmlkZXI+XHJcbiAgICA8L1NjaGVkdWxlckNvbnRleHQuUHJvdmlkZXI+XHJcbiAgKTtcclxufTtcclxuXHJcbi8vIEN1c3RvbSBob29rIHRvIHVzZSB0aGUgc2NoZWR1bGVyIGNvbnRleHRcclxuZXhwb3J0IGNvbnN0IHVzZVNjaGVkdWxlciA9ICgpID0+IHtcclxuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChTY2hlZHVsZXJDb250ZXh0KTtcclxuICBpZiAoIWNvbnRleHQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcInVzZVNjaGVkdWxlciBtdXN0IGJlIHVzZWQgd2l0aGluIGEgU2NoZWR1bGVyUHJvdmlkZXJcIik7XHJcbiAgfVxyXG4gIHJldHVybiBjb250ZXh0O1xyXG59O1xyXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZVJlZHVjZXIiLCJ1c2VFZmZlY3QiLCJNb2RhbFByb3ZpZGVyIiwidmFyaWFudHMiLCJpbml0aWFsU3RhdGUiLCJldmVudHMiLCJzY2hlZHVsZXJSZWR1Y2VyIiwic3RhdGUiLCJhY3Rpb24iLCJ0eXBlIiwicGF5bG9hZCIsImlkIiwic29tZSIsImUiLCJmaWx0ZXIiLCJldmVudCIsIm1hcCIsImxpc3QiLCJBcnJheSIsImlzQXJyYXkiLCJzZWVuIiwiU2V0IiwiZGVkdXBlZCIsImV2IiwiaGFzIiwiYWRkIiwiU2NoZWR1bGVyQ29udGV4dCIsInVuZGVmaW5lZCIsIlNjaGVkdWxlclByb3ZpZGVyIiwiY2hpbGRyZW4iLCJvbkFkZEV2ZW50Iiwib25VcGRhdGVFdmVudCIsIm9uRGVsZXRlRXZlbnQiLCJ3ZWVrU3RhcnRzT24iLCJyZWN1cnJlbmNlT3B0aW9ucyIsImRpc3BhdGNoIiwiZ2V0RGF5c0luTW9udGgiLCJtb250aCIsInllYXIiLCJmcm9tIiwibGVuZ3RoIiwiRGF0ZSIsImdldERhdGUiLCJfIiwiaW5kZXgiLCJkYXkiLCJnZXREYXlzSW5XZWVrIiwid2VlayIsInN0YXJ0RGF5IiwiamFuRmlyc3QiLCJqYW5GaXJzdERheU9mV2VlayIsImdldERheSIsIndlZWtTdGFydCIsInNldERhdGUiLCJkYXlzIiwiaSIsInB1c2giLCJnZXRXZWVrTnVtYmVyIiwiZGF0ZSIsImQiLCJVVEMiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwic2V0VVRDRGF0ZSIsImdldFVUQ0RhdGUiLCJnZXRVVENEYXkiLCJ5ZWFyU3RhcnQiLCJnZXRVVENGdWxsWWVhciIsIndlZWtObyIsIk1hdGgiLCJjZWlsIiwiZ2V0VGltZSIsImdldEV2ZW50c0ZvckRheSIsImN1cnJlbnREYXRlIiwiZXZlbnRTdGFydCIsInN0YXJ0RGF0ZSIsImV2ZW50RW5kIiwiZW5kRGF0ZSIsInN0YXJ0T2ZEYXkiLCJzZXRIb3VycyIsImVuZE9mRGF5IiwiaXNTYW1lRGF5IiwiaXNTcGFubmluZ0RheSIsImdldERheU5hbWUiLCJnZXR0ZXJzIiwiaGFuZGxlRXZlbnRTdHlsaW5nIiwiZGF5RXZlbnRzIiwicGVyaW9kT3B0aW9ucyIsInRvTWlsbGlzIiwiZW5zdXJlRGF0ZSIsIlJPV19QWF9QRVJfSE9VUiIsIml0ZW1zIiwicyIsInN0YXJ0TWludXRlcyIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImVuZE1pbnV0ZXMiLCJkdXJhdGlvbiIsIm1heCIsInNvcnQiLCJhIiwiYiIsImNvbHVtbnMiLCJjb2x1bW5zSW5kZXhNYXAiLCJmb3JFYWNoIiwiaXQiLCJpZHgiLCJwbGFjZWQiLCJjaSIsImNvbCIsImxhc3QiLCJ0b3RhbENvbHMiLCJ0aGlzU3RhcnQiLCJ0aGlzRW5kIiwidGhpc1N0YXJ0TWluIiwidGhpc0VuZE1pbiIsInRoaXNEdXJhdGlvbiIsImNvbEluZGV4Iiwid2lkdGhQZXJjZW50IiwibGVmdFBlcmNlbnQiLCJ0b3BQeCIsImhlaWdodFB4IiwiaGVpZ2h0IiwidG9wIiwiekluZGV4IiwibGVmdCIsIm1heFdpZHRoIiwibWluV2lkdGgiLCJoYW5kbGVBZGRFdmVudCIsInJlcyIsInN0YXR1cyIsInN0YXR1c0NvZGUiLCJyZXNwb25zZSIsIk51bWJlciIsImNvbnNvbGUiLCJ3YXJuIiwiaW5uZXIiLCJoYW5kbGVVcGRhdGVFdmVudCIsImVyciIsImhhbmRsZURlbGV0ZUV2ZW50IiwibWF5YmUiLCJoYW5kbGVMb2NhbEFkZEV2ZW50IiwiZGVidWciLCJoYW5kbGVMb2NhbFVwZGF0ZUV2ZW50IiwiaGFuZGxlcnMiLCJQcm92aWRlciIsInZhbHVlIiwidXNlU2NoZWR1bGVyIiwiY29udGV4dCIsIkVycm9yIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./src/providers/schedular-provider.tsx\n");

/***/ })

};
;