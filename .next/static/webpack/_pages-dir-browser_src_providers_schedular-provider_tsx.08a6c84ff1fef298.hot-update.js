"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_src_providers_schedular-provider_tsx",{

/***/ "(pages-dir-browser)/./src/providers/schedular-provider.tsx":
/*!**********************************************!*\
  !*** ./src/providers/schedular-provider.tsx ***!
  \**********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SchedulerProvider: () => (/* binding */ SchedulerProvider),\n/* harmony export */   useScheduler: () => (/* binding */ useScheduler),\n/* harmony export */   variants: () => (/* binding */ variants)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _modal_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modal-context */ \"(pages-dir-browser)/./src/providers/modal-context.tsx\");\n/* __next_internal_client_entry_do_not_use__ variants,SchedulerProvider,useScheduler auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n// SchedulerContext.tsx\n\n\n// Define the variant options\nconst variants = [\n    \"success\",\n    \"primary\",\n    \"default\",\n    \"warning\",\n    \"danger\"\n];\n// Initial state\nconst initialState = {\n    events: []\n};\n// Reducer function\nconst schedulerReducer = (state, action)=>{\n    switch(action.type){\n        case \"ADD_EVENT\":\n            // avoid duplicates by id\n            if (!action.payload || !action.payload.id) {\n                return state;\n            }\n            if (state.events.some((e)=>e.id === action.payload.id)) return state;\n            return {\n                ...state,\n                events: [\n                    ...state.events,\n                    action.payload\n                ]\n            };\n        case \"REMOVE_EVENT\":\n            return {\n                ...state,\n                events: state.events.filter((event)=>event.id !== action.payload.id)\n            };\n        case \"UPDATE_EVENT\":\n            return {\n                ...state,\n                events: state.events.map((event)=>event.id === action.payload.id ? action.payload : event)\n            };\n        case \"SET_EVENTS\":\n            // ensure payload is deduped by id\n            const list = Array.isArray(action.payload) ? action.payload : [];\n            const seen = new Set();\n            const deduped = list.filter((ev)=>{\n                if (!ev || !ev.id) return false;\n                if (seen.has(ev.id)) return false;\n                seen.add(ev.id);\n                return true;\n            });\n            return {\n                ...state,\n                events: deduped\n            };\n        default:\n            return state;\n    }\n};\n// Create the context with the correct type\nconst SchedulerContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\n// Provider component\nconst SchedulerProvider = ({ children, onAddEvent, onUpdateEvent, onDeleteEvent, initialState, weekStartsOn = \"sunday\", recurrenceOptions })=>{\n    _s();\n    const [state, dispatch] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useReducer)(schedulerReducer, {\n        events: initialState ?? []\n    } // Sets initialState or an empty array as the default\n    );\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SchedulerProvider.useEffect\": ()=>{\n            if (initialState) {\n                dispatch({\n                    type: \"SET_EVENTS\",\n                    payload: initialState\n                });\n            }\n        }\n    }[\"SchedulerProvider.useEffect\"], [\n        initialState\n    ]);\n    // global getters\n    const getDaysInMonth = (month, year)=>{\n        return Array.from({\n            length: new Date(year, month + 1, 0).getDate()\n        }, (_, index)=>({\n                day: index + 1,\n                events: []\n            }));\n    };\n    const getDaysInWeek = (week, year)=>{\n        // Determine if the week should start on Sunday (0) or Monday (1)\n        const startDay = weekStartsOn === \"sunday\" ? 0 : 1;\n        // Get January 1st of the year\n        const janFirst = new Date(year, 0, 1);\n        // Calculate how many days we are offsetting from January 1st\n        const janFirstDayOfWeek = janFirst.getDay();\n        // Calculate the start of the week by finding the correct day in the year\n        const weekStart = new Date(janFirst);\n        weekStart.setDate(janFirst.getDate() + (week - 1) * 7 + (startDay - janFirstDayOfWeek + 7) % 7);\n        // Generate the week's days\n        const days = [];\n        for(let i = 0; i < 7; i++){\n            const day = new Date(weekStart);\n            day.setDate(day.getDate() + i);\n            days.push(day);\n        }\n        return days;\n    };\n    const getWeekNumber = (date)=>{\n        const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));\n        d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));\n        const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));\n        const weekNo = Math.ceil(((d.getTime() - yearStart.getTime()) / 86400000 + 1) / 7);\n        return weekNo;\n    };\n    // Helper function to filter events for a specific day\n    const getEventsForDay = (day, currentDate)=>{\n        return state?.events.filter((event)=>{\n            const eventStart = new Date(event.startDate);\n            const eventEnd = new Date(event.endDate);\n            // Create new Date objects to avoid mutating `currentDate`\n            const startOfDay = new Date(currentDate);\n            startOfDay.setDate(day);\n            startOfDay.setHours(0, 0, 0, 0);\n            const endOfDay = new Date(currentDate);\n            endOfDay.setDate(day + 1);\n            endOfDay.setHours(0, 0, 0, 0);\n            // Check if the event starts or spans across the given day\n            const isSameDay = eventStart.getDate() === day && eventStart.getMonth() === currentDate.getMonth() && eventStart.getFullYear() === currentDate.getFullYear();\n            const isSpanningDay = eventStart < endOfDay && eventEnd >= startOfDay;\n            return isSameDay || isSpanningDay;\n        });\n    };\n    const getDayName = (day)=>{\n        const days = [\n            \"Sun\",\n            \"Mon\",\n            \"Tue\",\n            \"Wed\",\n            \"Thu\",\n            \"Fri\",\n            \"Sat\"\n        ];\n        return days[day];\n    };\n    const getters = {\n        getDaysInMonth,\n        getEventsForDay,\n        getDaysInWeek,\n        getWeekNumber,\n        getDayName\n    };\n    // handlers\n    function handleEventStyling(event, dayEvents, periodOptions) {\n        // Mina-inspired minutes-based layout\n        const toMillis = (d)=>d instanceof Date ? d.getTime() : new Date(d).getTime();\n        const ensureDate = (d)=>d instanceof Date ? d : new Date(d);\n        // Row height per hour - matches the hourly row height used in day/week views (64px)\n        const ROW_PX_PER_HOUR = 64;\n        // Build a list of items for the same day (or overlapping range)\n        const items = (dayEvents || []).filter((ev)=>ev && ev.startDate && ev.endDate).map((ev)=>{\n            const s = ensureDate(ev.startDate);\n            const e = ensureDate(ev.endDate);\n            const startMinutes = s.getHours() * 60 + s.getMinutes();\n            const endMinutes = e.getHours() * 60 + e.getMinutes();\n            const duration = Math.max(1, endMinutes - startMinutes);\n            return {\n                ev,\n                startMinutes,\n                endMinutes,\n                duration\n            };\n        }).sort((a, b)=>a.startMinutes - b.startMinutes || b.endMinutes - a.endMinutes);\n        // Simple column packing like Mina: place each event in the first column that doesn't overlap\n        const columns = [];\n        const columnsIndexMap = [];\n        items.forEach((it, idx)=>{\n            let placed = false;\n            for(let ci = 0; ci < columns.length; ci++){\n                const col = columns[ci];\n                const last = col[col.length - 1];\n                if (it.startMinutes >= last.endMinutes) {\n                    col.push(it);\n                    columnsIndexMap[idx] = ci;\n                    placed = true;\n                    break;\n                }\n            }\n            if (!placed) {\n                columnsIndexMap[idx] = columns.length;\n                columns.push([\n                    it\n                ]);\n            }\n        });\n        const totalCols = Math.max(1, columns.length);\n        // Find current event item\n        const thisStart = ensureDate(event.startDate);\n        const thisEnd = ensureDate(event.endDate);\n        const thisStartMin = thisStart.getHours() * 60 + thisStart.getMinutes();\n        const thisEndMin = thisEnd.getHours() * 60 + thisEnd.getMinutes();\n        const thisDuration = Math.max(1, thisEndMin - thisStartMin);\n        // Determine which column index this event occupies (fallback to 0)\n        let colIndex = 0;\n        for(let ci = 0; ci < columns.length; ci++){\n            if (columns[ci].some((it)=>it.ev.id === event.id)) {\n                colIndex = ci;\n                break;\n            }\n        }\n        const widthPercent = 100 / totalCols;\n        const leftPercent = colIndex * widthPercent;\n        // Compute pixels\n        const topPx = thisStartMin / 60 * ROW_PX_PER_HOUR;\n        const heightPx = Math.max(20, thisDuration / 60 * ROW_PX_PER_HOUR);\n        return {\n            height: `${heightPx}px`,\n            top: `${topPx}px`,\n            zIndex: colIndex + 1,\n            left: `${leftPercent}%`,\n            maxWidth: `${widthPercent}%`,\n            minWidth: `${widthPercent}%`\n        };\n    }\n    async function handleAddEvent(event) {\n        // If a parent handler is provided, call it and await its result. Only\n        // update local state after the parent returns a server-canonical event so\n        // the provider does not keep optimistic (possibly different) values that\n        // get overwritten on reload.\n        if (onAddEvent) {\n            try {\n                const res = await onAddEvent(event);\n                // If parent returned the saved canonical event, use it to update local state\n                if (res && res.id) {\n                    try {\n                        dispatch({\n                            type: \"ADD_EVENT\",\n                            payload: res\n                        });\n                    } catch (e) {}\n                }\n                return res;\n            } catch (e) {\n                // If the error is a client-side (4xx) response, rethrow so callers can show validation\n                // Otherwise (network error or 5xx) we can fallback to local optimistic add to keep UI responsive\n                try {\n                    const status = e && (e.status || e.statusCode || e.response && e.response.status);\n                    if (status && Number(status) >= 400 && Number(status) < 500) {\n                        console.warn('[SchedulerProvider] onAddEvent returned client error, aborting local fallback', status, e);\n                        throw e;\n                    }\n                } catch (inner) {}\n                console.warn('[SchedulerProvider] onAddEvent handler failed, falling back to local add', e);\n            }\n        }\n        dispatch({\n            type: \"ADD_EVENT\",\n            payload: event\n        });\n        return event;\n    }\n    async function handleUpdateEvent(event, id) {\n        // Prefer to let the parent persist the change and return the canonical\n        // event; only then update local state with the authoritative values.\n        if (onUpdateEvent) {\n            try {\n                const res = await onUpdateEvent({\n                    ...event,\n                    id\n                });\n                if (res && res.id) {\n                    try {\n                        dispatch({\n                            type: \"UPDATE_EVENT\",\n                            payload: res\n                        });\n                    } catch (e) {}\n                }\n                return res;\n            } catch (e) {\n                // If parent handler fails, fall back to optimistic local update so UI still reflects change\n                console.warn('[SchedulerProvider] onUpdateEvent handler failed, applying optimistic update', e);\n                try {\n                    dispatch({\n                        type: \"UPDATE_EVENT\",\n                        payload: {\n                            ...event,\n                            id\n                        }\n                    });\n                } catch (err) {}\n                // rethrow so callers can handle failure if needed\n                throw e;\n            }\n        }\n        // No parent handler: do a local optimistic update\n        try {\n            dispatch({\n                type: \"UPDATE_EVENT\",\n                payload: {\n                    ...event,\n                    id\n                }\n            });\n        } catch (e) {\n            console.warn('[SchedulerProvider] local dispatch update failed', e);\n        }\n        return {\n            ...event,\n            id\n        };\n    }\n    function handleDeleteEvent(id) {\n        if (onDeleteEvent) {\n            try {\n                const maybe = onDeleteEvent(id);\n                return maybe;\n            } catch (e) {\n            // fall back to local remove\n            }\n        }\n        dispatch({\n            type: \"REMOVE_EVENT\",\n            payload: {\n                id\n            }\n        });\n    }\n    // Local-only handlers: allow callers to update provider state without delegating\n    // persistence to parent page handlers. Useful when the caller performs the\n    // network request itself and only wants to update UI after confirmation.\n    function handleLocalAddEvent(event) {\n        try {\n            try {\n                // debug: log the incoming event for troubleshooting\n                console.debug('[SchedulerProvider] handleLocalAddEvent incoming:', event);\n            } catch (e) {}\n            dispatch({\n                type: \"ADD_EVENT\",\n                payload: event\n            });\n            try {\n                console.debug('[SchedulerProvider] events after add (count):', state && state.events && state.events.length ? state.events.length + 1 : 'unknown');\n            } catch (e) {}\n        } catch (e) {\n        // swallow - UI best-effort\n        }\n    }\n    function handleLocalUpdateEvent(event) {\n        try {\n            try {\n                console.debug('[SchedulerProvider] handleLocalUpdateEvent incoming:', event);\n            } catch (e) {}\n            if (!event || !event.id) return;\n            dispatch({\n                type: \"UPDATE_EVENT\",\n                payload: event\n            });\n            try {\n                console.debug('[SchedulerProvider] events after update (count):', state && state.events && state.events.length ? state.events.length : 'unknown');\n            } catch (e) {}\n        } catch (e) {\n        // swallow\n        }\n    }\n    const handlers = {\n        handleEventStyling,\n        handleAddEvent,\n        handleUpdateEvent,\n        handleDeleteEvent,\n        // local-only helpers\n        handleLocalAddEvent,\n        handleLocalUpdateEvent\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(SchedulerContext.Provider, {\n        // include recurrenceOptions if passed via props (kept backward compatible)\n        value: {\n            events: state,\n            dispatch,\n            getters,\n            handlers,\n            weekStartsOn,\n            recurrenceOptions\n        },\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_modal_context__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n            children: children\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\university-planner\\\\src\\\\providers\\\\schedular-provider.tsx\",\n            lineNumber: 410,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\university-planner\\\\src\\\\providers\\\\schedular-provider.tsx\",\n        lineNumber: 406,\n        columnNumber: 5\n    }, undefined);\n};\n_s(SchedulerProvider, \"+GWmRPgPwRqyHMb75g9kmdyxOrA=\");\n_c = SchedulerProvider;\n// Custom hook to use the scheduler context\nconst useScheduler = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(SchedulerContext);\n    if (!context) {\n        throw new Error(\"useScheduler must be used within a SchedulerProvider\");\n    }\n    return context;\n};\n_s1(useScheduler, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"SchedulerProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9wcm92aWRlcnMvc2NoZWR1bGFyLXByb3ZpZGVyLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBRUEsdUJBQXVCO0FBUVI7QUFXNkI7QUFPNUMsNkJBQTZCO0FBQ3RCLE1BQU1NLFdBQVc7SUFDdEI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNELENBQVU7QUFFWCxnQkFBZ0I7QUFDaEIsTUFBTUMsZUFBK0I7SUFDbkNDLFFBQVEsRUFBRTtBQUNaO0FBRUEsbUJBQW1CO0FBQ25CLE1BQU1DLG1CQUFtQixDQUN2QkMsT0FDQUM7SUFFQSxPQUFRQSxPQUFPQyxJQUFJO1FBQ2pCLEtBQUs7WUFDSCx5QkFBeUI7WUFDekIsSUFBSSxDQUFDRCxPQUFPRSxPQUFPLElBQUksQ0FBQ0YsT0FBT0UsT0FBTyxDQUFDQyxFQUFFLEVBQUU7Z0JBQ3pDLE9BQU9KO1lBQ1Q7WUFDQSxJQUFJQSxNQUFNRixNQUFNLENBQUNPLElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUYsRUFBRSxLQUFLSCxPQUFPRSxPQUFPLENBQUNDLEVBQUUsR0FBRyxPQUFPSjtZQUMvRCxPQUFPO2dCQUFFLEdBQUdBLEtBQUs7Z0JBQUVGLFFBQVE7dUJBQUlFLE1BQU1GLE1BQU07b0JBQUVHLE9BQU9FLE9BQU87aUJBQUM7WUFBQztRQUUvRCxLQUFLO1lBQ0gsT0FBTztnQkFDTCxHQUFHSCxLQUFLO2dCQUNSRixRQUFRRSxNQUFNRixNQUFNLENBQUNTLE1BQU0sQ0FBQyxDQUFDQyxRQUFVQSxNQUFNSixFQUFFLEtBQUtILE9BQU9FLE9BQU8sQ0FBQ0MsRUFBRTtZQUN2RTtRQUNGLEtBQUs7WUFDSCxPQUFPO2dCQUNMLEdBQUdKLEtBQUs7Z0JBQ1JGLFFBQVFFLE1BQU1GLE1BQU0sQ0FBQ1csR0FBRyxDQUFDLENBQUNELFFBQ3hCQSxNQUFNSixFQUFFLEtBQUtILE9BQU9FLE9BQU8sQ0FBQ0MsRUFBRSxHQUFHSCxPQUFPRSxPQUFPLEdBQUdLO1lBRXRE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QUNGO0lBRUEscUJBQ0UsOERBQUNySCxpQkFBaUJ1SCxRQUFRO1FBQ3hCLDJFQUEyRTtRQUMzRUMsT0FBTztZQUFFN0ksUUFBUUU7WUFBTzRCO1lBQVVpRDtZQUFTNEQ7WUFBVS9HO1lBQWNDO1FBQWtCO2tCQUVyRiw0RUFBQ2hDLHNEQUFhQTtzQkFBRTJCOzs7Ozs7Ozs7OztBQUd0QixFQUFFO0dBalVXRDtLQUFBQTtBQW1VYiwyQ0FBMkM7QUFDcEMsTUFBTXVILGVBQWU7O0lBQzFCLE1BQU1DLFVBQVVySixpREFBVUEsQ0FBQzJCO0lBQzNCLElBQUksQ0FBQzBILFNBQVM7UUFDWixNQUFNLElBQUlDLE1BQU07SUFDbEI7SUFDQSxPQUFPRDtBQUNULEVBQUU7SUFOV0QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcdW5pdmVyc2l0eS1wbGFubmVyXFxzcmNcXHByb3ZpZGVyc1xcc2NoZWR1bGFyLXByb3ZpZGVyLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcclxuXHJcbi8vIFNjaGVkdWxlckNvbnRleHQudHN4XHJcbmltcG9ydCBSZWFjdCwge1xyXG4gIGNyZWF0ZUNvbnRleHQsXHJcbiAgdXNlQ29udGV4dCxcclxuICB1c2VSZWR1Y2VyLFxyXG4gIFJlYWN0Tm9kZSxcclxuICBEaXNwYXRjaCxcclxuICB1c2VFZmZlY3QsXHJcbn0gZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCB7IHogfSBmcm9tIFwiem9kXCI7XHJcblxyXG5pbXBvcnQge1xyXG4gIEFjdGlvbixcclxuICBFdmVudCxcclxuICBHZXR0ZXJzLFxyXG4gIEhhbmRsZXJzLFxyXG4gIFNjaGVkdWxlckNvbnRleHRUeXBlLFxyXG4gIHN0YXJ0T2ZXZWVrLFxyXG59IGZyb20gXCJAL3R5cGVzL2luZGV4XCI7XHJcbmltcG9ydCBNb2RhbFByb3ZpZGVyIGZyb20gXCIuL21vZGFsLWNvbnRleHRcIjtcclxuLy8gRGVmaW5lIGV2ZW50IGFuZCBzdGF0ZSB0eXBlc1xyXG5cclxuaW50ZXJmYWNlIFNjaGVkdWxlclN0YXRlIHtcclxuICBldmVudHM6IEV2ZW50W107XHJcbn1cclxuXHJcbi8vIERlZmluZSB0aGUgdmFyaWFudCBvcHRpb25zXHJcbmV4cG9ydCBjb25zdCB2YXJpYW50cyA9IFtcclxuICBcInN1Y2Nlc3NcIixcclxuICBcInByaW1hcnlcIixcclxuICBcImRlZmF1bHRcIixcclxuICBcIndhcm5pbmdcIixcclxuICBcImRhbmdlclwiLFxyXG5dIGFzIGNvbnN0O1xyXG5cclxuLy8gSW5pdGlhbCBzdGF0ZVxyXG5jb25zdCBpbml0aWFsU3RhdGU6IFNjaGVkdWxlclN0YXRlID0ge1xyXG4gIGV2ZW50czogW10sXHJcbn07XHJcblxyXG4vLyBSZWR1Y2VyIGZ1bmN0aW9uXHJcbmNvbnN0IHNjaGVkdWxlclJlZHVjZXIgPSAoXHJcbiAgc3RhdGU6IFNjaGVkdWxlclN0YXRlLFxyXG4gIGFjdGlvbjogQWN0aW9uXHJcbik6IFNjaGVkdWxlclN0YXRlID0+IHtcclxuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XHJcbiAgICBjYXNlIFwiQUREX0VWRU5UXCI6XHJcbiAgICAgIC8vIGF2b2lkIGR1cGxpY2F0ZXMgYnkgaWRcclxuICAgICAgaWYgKCFhY3Rpb24ucGF5bG9hZCB8fCAhYWN0aW9uLnBheWxvYWQuaWQpIHtcclxuICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHN0YXRlLmV2ZW50cy5zb21lKGUgPT4gZS5pZCA9PT0gYWN0aW9uLnBheWxvYWQuaWQpKSByZXR1cm4gc3RhdGU7XHJcbiAgICAgIHJldHVybiB7IC4uLnN0YXRlLCBldmVudHM6IFsuLi5zdGF0ZS5ldmVudHMsIGFjdGlvbi5wYXlsb2FkXSB9O1xyXG5cclxuICAgIGNhc2UgXCJSRU1PVkVfRVZFTlRcIjpcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICAuLi5zdGF0ZSxcclxuICAgICAgICBldmVudHM6IHN0YXRlLmV2ZW50cy5maWx0ZXIoKGV2ZW50KSA9PiBldmVudC5pZCAhPT0gYWN0aW9uLnBheWxvYWQuaWQpLFxyXG4gICAgICB9O1xyXG4gICAgY2FzZSBcIlVQREFURV9FVkVOVFwiOlxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIC4uLnN0YXRlLFxyXG4gICAgICAgIGV2ZW50czogc3RhdGUuZXZlbnRzLm1hcCgoZXZlbnQpID0+XHJcbiAgICAgICAgICBldmVudC5pZCA9PT0gYWN0aW9uLnBheWxvYWQuaWQgPyBhY3Rpb24ucGF5bG9hZCA6IGV2ZW50XHJcbiAgICAgICAgKSxcclxuICAgICAgfTtcclxuICAgIGNhc2UgXCJTRVRfRVZFTlRTXCI6XHJcbiAgICAgIC8vIGVuc3VyZSBwYXlsb2FkIGlzIGRlZHVwZWQgYnkgaWRcclxuICAgICAgY29uc3QgbGlzdCA9IEFycmF5LmlzQXJyYXkoYWN0aW9uLnBheWxvYWQpID8gYWN0aW9uLnBheWxvYWQgOiBbXTtcclxuICAgICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcclxuICAgICAgY29uc3QgZGVkdXBlZCA9IGxpc3QuZmlsdGVyKChldjogRXZlbnQpID0+IHtcclxuICAgICAgICBpZiAoIWV2IHx8ICFldi5pZCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmIChzZWVuLmhhcyhldi5pZCkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBzZWVuLmFkZChldi5pZCk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4geyAuLi5zdGF0ZSwgZXZlbnRzOiBkZWR1cGVkIH07XHJcblxyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIENyZWF0ZSB0aGUgY29udGV4dCB3aXRoIHRoZSBjb3JyZWN0IHR5cGVcclxuY29uc3QgU2NoZWR1bGVyQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8U2NoZWR1bGVyQ29udGV4dFR5cGUgfCB1bmRlZmluZWQ+KFxyXG4gIHVuZGVmaW5lZFxyXG4pO1xyXG5cclxuLy8gUHJvdmlkZXIgY29tcG9uZW50XHJcbmV4cG9ydCBjb25zdCBTY2hlZHVsZXJQcm92aWRlciA9ICh7XHJcbiAgY2hpbGRyZW4sXHJcbiAgb25BZGRFdmVudCxcclxuICBvblVwZGF0ZUV2ZW50LFxyXG4gIG9uRGVsZXRlRXZlbnQsXHJcbiAgaW5pdGlhbFN0YXRlLFxyXG4gIHdlZWtTdGFydHNPbiA9IFwic3VuZGF5XCIsXHJcbiAgcmVjdXJyZW5jZU9wdGlvbnMsXHJcbn06IHtcclxuICBvbkFkZEV2ZW50PzogKGV2ZW50OiBFdmVudCkgPT4gdm9pZDtcclxuICBvblVwZGF0ZUV2ZW50PzogKGV2ZW50OiBFdmVudCkgPT4gdm9pZDtcclxuICBvbkRlbGV0ZUV2ZW50PzogKGlkOiBzdHJpbmcpID0+IHZvaWQ7XHJcbiAgd2Vla1N0YXJ0c09uPzogc3RhcnRPZldlZWs7XHJcbiAgY2hpbGRyZW46IFJlYWN0Tm9kZTtcclxuICBpbml0aWFsU3RhdGU/OiBFdmVudFtdO1xyXG4gIHJlY3VycmVuY2VPcHRpb25zPzogQXJyYXk8eyBpZDogc3RyaW5nOyBsYWJlbDogc3RyaW5nOyBycnVsZVRlbXBsYXRlPzogc3RyaW5nIHwgbnVsbCB9PlxyXG59KSA9PiB7XHJcbiAgY29uc3QgW3N0YXRlLCBkaXNwYXRjaF0gPSB1c2VSZWR1Y2VyKFxyXG4gICAgc2NoZWR1bGVyUmVkdWNlcixcclxuICAgIHsgZXZlbnRzOiBpbml0aWFsU3RhdGUgPz8gW10gfSAvLyBTZXRzIGluaXRpYWxTdGF0ZSBvciBhbiBlbXB0eSBhcnJheSBhcyB0aGUgZGVmYXVsdFxyXG4gICk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoaW5pdGlhbFN0YXRlKSB7XHJcbiAgICAgIGRpc3BhdGNoKHsgdHlwZTogXCJTRVRfRVZFTlRTXCIsIHBheWxvYWQ6IGluaXRpYWxTdGF0ZSB9KTtcclxuICAgIH1cclxuICB9LCBbaW5pdGlhbFN0YXRlXSk7XHJcblxyXG4gIC8vIGdsb2JhbCBnZXR0ZXJzXHJcbiAgY29uc3QgZ2V0RGF5c0luTW9udGggPSAobW9udGg6IG51bWJlciwgeWVhcjogbnVtYmVyKSA9PiB7XHJcbiAgICByZXR1cm4gQXJyYXkuZnJvbShcclxuICAgICAgeyBsZW5ndGg6IG5ldyBEYXRlKHllYXIsIG1vbnRoICsgMSwgMCkuZ2V0RGF0ZSgpIH0sXHJcbiAgICAgIChfLCBpbmRleCkgPT4gKHtcclxuICAgICAgICBkYXk6IGluZGV4ICsgMSxcclxuICAgICAgICBldmVudHM6IFtdLFxyXG4gICAgICB9KVxyXG4gICAgKTtcclxuICB9O1xyXG5cclxuICBjb25zdCBnZXREYXlzSW5XZWVrID0gKHdlZWs6IG51bWJlciwgeWVhcjogbnVtYmVyKSA9PiB7XHJcbiAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIHdlZWsgc2hvdWxkIHN0YXJ0IG9uIFN1bmRheSAoMCkgb3IgTW9uZGF5ICgxKVxyXG4gICAgY29uc3Qgc3RhcnREYXkgPSB3ZWVrU3RhcnRzT24gPT09IFwic3VuZGF5XCIgPyAwIDogMTtcclxuXHJcbiAgICAvLyBHZXQgSmFudWFyeSAxc3Qgb2YgdGhlIHllYXJcclxuICAgIGNvbnN0IGphbkZpcnN0ID0gbmV3IERhdGUoeWVhciwgMCwgMSk7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGhvdyBtYW55IGRheXMgd2UgYXJlIG9mZnNldHRpbmcgZnJvbSBKYW51YXJ5IDFzdFxyXG4gICAgY29uc3QgamFuRmlyc3REYXlPZldlZWsgPSBqYW5GaXJzdC5nZXREYXkoKTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIHN0YXJ0IG9mIHRoZSB3ZWVrIGJ5IGZpbmRpbmcgdGhlIGNvcnJlY3QgZGF5IGluIHRoZSB5ZWFyXHJcbiAgICBjb25zdCB3ZWVrU3RhcnQgPSBuZXcgRGF0ZShqYW5GaXJzdCk7XHJcbiAgICB3ZWVrU3RhcnQuc2V0RGF0ZShcclxuICAgICAgamFuRmlyc3QuZ2V0RGF0ZSgpICtcclxuICAgICAgICAod2VlayAtIDEpICogNyArXHJcbiAgICAgICAgKChzdGFydERheSAtIGphbkZpcnN0RGF5T2ZXZWVrICsgNykgJSA3KVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBHZW5lcmF0ZSB0aGUgd2VlaydzIGRheXNcclxuICAgIGNvbnN0IGRheXMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNzsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGRheSA9IG5ldyBEYXRlKHdlZWtTdGFydCk7XHJcbiAgICAgIGRheS5zZXREYXRlKGRheS5nZXREYXRlKCkgKyBpKTtcclxuICAgICAgZGF5cy5wdXNoKGRheSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRheXM7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgZ2V0V2Vla051bWJlciA9IChkYXRlOiBEYXRlKSA9PiB7XHJcbiAgICBjb25zdCBkID0gbmV3IERhdGUoXHJcbiAgICAgIERhdGUuVVRDKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSlcclxuICAgICk7XHJcbiAgICBkLnNldFVUQ0RhdGUoZC5nZXRVVENEYXRlKCkgKyA0IC0gKGQuZ2V0VVRDRGF5KCkgfHwgNykpO1xyXG4gICAgY29uc3QgeWVhclN0YXJ0ID0gbmV3IERhdGUoRGF0ZS5VVEMoZC5nZXRVVENGdWxsWWVhcigpLCAwLCAxKSk7XHJcbiAgICBjb25zdCB3ZWVrTm8gPSBNYXRoLmNlaWwoXHJcbiAgICAgICgoZC5nZXRUaW1lKCkgLSB5ZWFyU3RhcnQuZ2V0VGltZSgpKSAvIDg2NDAwMDAwICsgMSkgLyA3XHJcbiAgICApO1xyXG4gICAgcmV0dXJuIHdlZWtObztcclxuICB9O1xyXG5cclxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZmlsdGVyIGV2ZW50cyBmb3IgYSBzcGVjaWZpYyBkYXlcclxuICBjb25zdCBnZXRFdmVudHNGb3JEYXkgPSAoZGF5OiBudW1iZXIsIGN1cnJlbnREYXRlOiBEYXRlKSA9PiB7XHJcbiAgICByZXR1cm4gc3RhdGU/LmV2ZW50cy5maWx0ZXIoKGV2ZW50KSA9PiB7XHJcbiAgICAgIGNvbnN0IGV2ZW50U3RhcnQgPSBuZXcgRGF0ZShldmVudC5zdGFydERhdGUpO1xyXG4gICAgICBjb25zdCBldmVudEVuZCA9IG5ldyBEYXRlKGV2ZW50LmVuZERhdGUpO1xyXG5cclxuICAgICAgLy8gQ3JlYXRlIG5ldyBEYXRlIG9iamVjdHMgdG8gYXZvaWQgbXV0YXRpbmcgYGN1cnJlbnREYXRlYFxyXG4gICAgICBjb25zdCBzdGFydE9mRGF5ID0gbmV3IERhdGUoY3VycmVudERhdGUpO1xyXG4gICAgICBzdGFydE9mRGF5LnNldERhdGUoZGF5KTtcclxuICAgICAgc3RhcnRPZkRheS5zZXRIb3VycygwLCAwLCAwLCAwKTtcclxuXHJcbiAgICAgIGNvbnN0IGVuZE9mRGF5ID0gbmV3IERhdGUoY3VycmVudERhdGUpO1xyXG4gICAgICBlbmRPZkRheS5zZXREYXRlKGRheSArIDEpO1xyXG4gICAgICBlbmRPZkRheS5zZXRIb3VycygwLCAwLCAwLCAwKTtcclxuXHJcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBldmVudCBzdGFydHMgb3Igc3BhbnMgYWNyb3NzIHRoZSBnaXZlbiBkYXlcclxuICAgICAgY29uc3QgaXNTYW1lRGF5ID1cclxuICAgICAgICBldmVudFN0YXJ0LmdldERhdGUoKSA9PT0gZGF5ICYmXHJcbiAgICAgICAgZXZlbnRTdGFydC5nZXRNb250aCgpID09PSBjdXJyZW50RGF0ZS5nZXRNb250aCgpICYmXHJcbiAgICAgICAgZXZlbnRTdGFydC5nZXRGdWxsWWVhcigpID09PSBjdXJyZW50RGF0ZS5nZXRGdWxsWWVhcigpO1xyXG5cclxuICAgICAgY29uc3QgaXNTcGFubmluZ0RheSA9IGV2ZW50U3RhcnQgPCBlbmRPZkRheSAmJiBldmVudEVuZCA+PSBzdGFydE9mRGF5O1xyXG5cclxuICAgICAgcmV0dXJuIGlzU2FtZURheSB8fCBpc1NwYW5uaW5nRGF5O1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgZ2V0RGF5TmFtZSA9IChkYXk6IG51bWJlcikgPT4ge1xyXG4gICAgY29uc3QgZGF5cyA9IFtcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiXTtcclxuICAgIHJldHVybiBkYXlzW2RheV07XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgZ2V0dGVyczogR2V0dGVycyA9IHtcclxuICAgIGdldERheXNJbk1vbnRoLFxyXG4gICAgZ2V0RXZlbnRzRm9yRGF5LFxyXG4gICAgZ2V0RGF5c0luV2VlayxcclxuICAgIGdldFdlZWtOdW1iZXIsXHJcbiAgICBnZXREYXlOYW1lLFxyXG4gIH07XHJcblxyXG4gIC8vIGhhbmRsZXJzXHJcbiAgZnVuY3Rpb24gaGFuZGxlRXZlbnRTdHlsaW5nKFxyXG4gICAgZXZlbnQ6IEV2ZW50LCBcclxuICAgIGRheUV2ZW50czogRXZlbnRbXSxcclxuICAgIHBlcmlvZE9wdGlvbnM/OiB7IFxyXG4gICAgICBldmVudHNJblNhbWVQZXJpb2Q/OiBudW1iZXI7IFxyXG4gICAgICBwZXJpb2RJbmRleD86IG51bWJlcjsgXHJcbiAgICAgIGFkanVzdEZvclBlcmlvZD86IGJvb2xlYW47XHJcbiAgICB9XHJcbiAgKSB7XHJcbiAgICAvLyBNaW5hLWluc3BpcmVkIG1pbnV0ZXMtYmFzZWQgbGF5b3V0XHJcbiAgICBjb25zdCB0b01pbGxpcyA9IChkOiBhbnkpID0+IChkIGluc3RhbmNlb2YgRGF0ZSA/IGQuZ2V0VGltZSgpIDogbmV3IERhdGUoZCkuZ2V0VGltZSgpKTtcclxuICAgIGNvbnN0IGVuc3VyZURhdGUgPSAoZDogYW55KSA9PiAoZCBpbnN0YW5jZW9mIERhdGUgPyBkIDogbmV3IERhdGUoZCkpO1xyXG5cclxuICAgIC8vIFJvdyBoZWlnaHQgcGVyIGhvdXIgLSBtYXRjaGVzIHRoZSBob3VybHkgcm93IGhlaWdodCB1c2VkIGluIGRheS93ZWVrIHZpZXdzICg2NHB4KVxyXG4gICAgY29uc3QgUk9XX1BYX1BFUl9IT1VSID0gNjQ7XHJcblxyXG4gICAgLy8gQnVpbGQgYSBsaXN0IG9mIGl0ZW1zIGZvciB0aGUgc2FtZSBkYXkgKG9yIG92ZXJsYXBwaW5nIHJhbmdlKVxyXG4gICAgY29uc3QgaXRlbXMgPSAoZGF5RXZlbnRzIHx8IFtdKS5maWx0ZXIoKGV2KSA9PiBldiAmJiBldi5zdGFydERhdGUgJiYgZXYuZW5kRGF0ZSkubWFwKGV2ID0+IHtcclxuICAgICAgY29uc3QgcyA9IGVuc3VyZURhdGUoZXYuc3RhcnREYXRlKTtcclxuICAgICAgY29uc3QgZSA9IGVuc3VyZURhdGUoZXYuZW5kRGF0ZSk7XHJcbiAgICAgIGNvbnN0IHN0YXJ0TWludXRlcyA9IHMuZ2V0SG91cnMoKSAqIDYwICsgcy5nZXRNaW51dGVzKCk7XHJcbiAgICAgIGNvbnN0IGVuZE1pbnV0ZXMgPSBlLmdldEhvdXJzKCkgKiA2MCArIGUuZ2V0TWludXRlcygpO1xyXG4gICAgICBjb25zdCBkdXJhdGlvbiA9IE1hdGgubWF4KDEsIGVuZE1pbnV0ZXMgLSBzdGFydE1pbnV0ZXMpO1xyXG4gICAgICByZXR1cm4geyBldiwgc3RhcnRNaW51dGVzLCBlbmRNaW51dGVzLCBkdXJhdGlvbiB9O1xyXG4gICAgfSkuc29ydCgoYSxiKSA9PiBhLnN0YXJ0TWludXRlcyAtIGIuc3RhcnRNaW51dGVzIHx8IGIuZW5kTWludXRlcyAtIGEuZW5kTWludXRlcyk7XHJcblxyXG4gICAgLy8gU2ltcGxlIGNvbHVtbiBwYWNraW5nIGxpa2UgTWluYTogcGxhY2UgZWFjaCBldmVudCBpbiB0aGUgZmlyc3QgY29sdW1uIHRoYXQgZG9lc24ndCBvdmVybGFwXHJcbiAgICBjb25zdCBjb2x1bW5zOiBBcnJheTxBcnJheTxhbnk+PiA9IFtdO1xyXG4gICAgY29uc3QgY29sdW1uc0luZGV4TWFwOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgaXRlbXMuZm9yRWFjaCgoaXQsIGlkeCkgPT4ge1xyXG4gICAgICBsZXQgcGxhY2VkID0gZmFsc2U7XHJcbiAgICAgIGZvciAobGV0IGNpID0gMDsgY2kgPCBjb2x1bW5zLmxlbmd0aDsgY2krKykge1xyXG4gICAgICAgIGNvbnN0IGNvbCA9IGNvbHVtbnNbY2ldO1xyXG4gICAgICAgIGNvbnN0IGxhc3QgPSBjb2xbY29sLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIGlmIChpdC5zdGFydE1pbnV0ZXMgPj0gbGFzdC5lbmRNaW51dGVzKSB7XHJcbiAgICAgICAgICBjb2wucHVzaChpdCk7XHJcbiAgICAgICAgICBjb2x1bW5zSW5kZXhNYXBbaWR4XSA9IGNpO1xyXG4gICAgICAgICAgcGxhY2VkID0gdHJ1ZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoIXBsYWNlZCkge1xyXG4gICAgICAgIGNvbHVtbnNJbmRleE1hcFtpZHhdID0gY29sdW1ucy5sZW5ndGg7XHJcbiAgICAgICAgY29sdW1ucy5wdXNoKFtpdF0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB0b3RhbENvbHMgPSBNYXRoLm1heCgxLCBjb2x1bW5zLmxlbmd0aCk7XHJcblxyXG4gICAgLy8gRmluZCBjdXJyZW50IGV2ZW50IGl0ZW1cclxuICAgIGNvbnN0IHRoaXNTdGFydCA9IGVuc3VyZURhdGUoZXZlbnQuc3RhcnREYXRlKTtcclxuICAgIGNvbnN0IHRoaXNFbmQgPSBlbnN1cmVEYXRlKGV2ZW50LmVuZERhdGUpO1xyXG4gICAgY29uc3QgdGhpc1N0YXJ0TWluID0gdGhpc1N0YXJ0LmdldEhvdXJzKCkgKiA2MCArIHRoaXNTdGFydC5nZXRNaW51dGVzKCk7XHJcbiAgICBjb25zdCB0aGlzRW5kTWluID0gdGhpc0VuZC5nZXRIb3VycygpICogNjAgKyB0aGlzRW5kLmdldE1pbnV0ZXMoKTtcclxuICAgIGNvbnN0IHRoaXNEdXJhdGlvbiA9IE1hdGgubWF4KDEsIHRoaXNFbmRNaW4gLSB0aGlzU3RhcnRNaW4pO1xyXG5cclxuICAgIC8vIERldGVybWluZSB3aGljaCBjb2x1bW4gaW5kZXggdGhpcyBldmVudCBvY2N1cGllcyAoZmFsbGJhY2sgdG8gMClcclxuICAgIGxldCBjb2xJbmRleCA9IDA7XHJcbiAgICBmb3IgKGxldCBjaSA9IDA7IGNpIDwgY29sdW1ucy5sZW5ndGg7IGNpKyspIHtcclxuICAgICAgaWYgKGNvbHVtbnNbY2ldLnNvbWUoaXQgPT4gaXQuZXYuaWQgPT09IGV2ZW50LmlkKSkgeyBjb2xJbmRleCA9IGNpOyBicmVhazsgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHdpZHRoUGVyY2VudCA9IDEwMCAvIHRvdGFsQ29scztcclxuICAgIGNvbnN0IGxlZnRQZXJjZW50ID0gY29sSW5kZXggKiB3aWR0aFBlcmNlbnQ7XHJcblxyXG4gICAgLy8gQ29tcHV0ZSBwaXhlbHNcclxuICAgIGNvbnN0IHRvcFB4ID0gKHRoaXNTdGFydE1pbiAvIDYwKSAqIFJPV19QWF9QRVJfSE9VUjtcclxuICAgIGNvbnN0IGhlaWdodFB4ID0gTWF0aC5tYXgoMjAsICh0aGlzRHVyYXRpb24gLyA2MCkgKiBST1dfUFhfUEVSX0hPVVIpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGhlaWdodDogYCR7aGVpZ2h0UHh9cHhgLFxyXG4gICAgICB0b3A6IGAke3RvcFB4fXB4YCxcclxuICAgICAgekluZGV4OiBjb2xJbmRleCArIDEsXHJcbiAgICAgIGxlZnQ6IGAke2xlZnRQZXJjZW50fSVgLFxyXG4gICAgICBtYXhXaWR0aDogYCR7d2lkdGhQZXJjZW50fSVgLFxyXG4gICAgICBtaW5XaWR0aDogYCR7d2lkdGhQZXJjZW50fSVgLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUFkZEV2ZW50KGV2ZW50OiBFdmVudCkge1xyXG4gICAgLy8gSWYgYSBwYXJlbnQgaGFuZGxlciBpcyBwcm92aWRlZCwgY2FsbCBpdCBhbmQgYXdhaXQgaXRzIHJlc3VsdC4gT25seVxyXG4gICAgLy8gdXBkYXRlIGxvY2FsIHN0YXRlIGFmdGVyIHRoZSBwYXJlbnQgcmV0dXJucyBhIHNlcnZlci1jYW5vbmljYWwgZXZlbnQgc29cclxuICAgIC8vIHRoZSBwcm92aWRlciBkb2VzIG5vdCBrZWVwIG9wdGltaXN0aWMgKHBvc3NpYmx5IGRpZmZlcmVudCkgdmFsdWVzIHRoYXRcclxuICAgIC8vIGdldCBvdmVyd3JpdHRlbiBvbiByZWxvYWQuXHJcbiAgICBpZiAob25BZGRFdmVudCkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHJlczogYW55ID0gYXdhaXQgb25BZGRFdmVudChldmVudCk7XHJcbiAgICAgICAgLy8gSWYgcGFyZW50IHJldHVybmVkIHRoZSBzYXZlZCBjYW5vbmljYWwgZXZlbnQsIHVzZSBpdCB0byB1cGRhdGUgbG9jYWwgc3RhdGVcclxuICAgICAgICBpZiAocmVzICYmIHJlcy5pZCkge1xyXG4gICAgICAgICAgdHJ5IHsgZGlzcGF0Y2goeyB0eXBlOiBcIkFERF9FVkVOVFwiLCBwYXlsb2FkOiByZXMgfSk7IH0gY2F0Y2ggKGUpIHt9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfSBjYXRjaCAoZTogYW55KSB7XHJcbiAgICAgICAgICAvLyBJZiB0aGUgZXJyb3IgaXMgYSBjbGllbnQtc2lkZSAoNHh4KSByZXNwb25zZSwgcmV0aHJvdyBzbyBjYWxsZXJzIGNhbiBzaG93IHZhbGlkYXRpb25cclxuICAgICAgICAgIC8vIE90aGVyd2lzZSAobmV0d29yayBlcnJvciBvciA1eHgpIHdlIGNhbiBmYWxsYmFjayB0byBsb2NhbCBvcHRpbWlzdGljIGFkZCB0byBrZWVwIFVJIHJlc3BvbnNpdmVcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IGUgJiYgKGUuc3RhdHVzIHx8IGUuc3RhdHVzQ29kZSB8fCAoZS5yZXNwb25zZSAmJiBlLnJlc3BvbnNlLnN0YXR1cykpXHJcbiAgICAgICAgICAgIGlmIChzdGF0dXMgJiYgTnVtYmVyKHN0YXR1cykgPj0gNDAwICYmIE51bWJlcihzdGF0dXMpIDwgNTAwKSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdbU2NoZWR1bGVyUHJvdmlkZXJdIG9uQWRkRXZlbnQgcmV0dXJuZWQgY2xpZW50IGVycm9yLCBhYm9ydGluZyBsb2NhbCBmYWxsYmFjaycsIHN0YXR1cywgZSlcclxuICAgICAgICAgICAgICB0aHJvdyBlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gY2F0Y2ggKGlubmVyKSB7fVxyXG4gICAgICAgICAgY29uc29sZS53YXJuKCdbU2NoZWR1bGVyUHJvdmlkZXJdIG9uQWRkRXZlbnQgaGFuZGxlciBmYWlsZWQsIGZhbGxpbmcgYmFjayB0byBsb2NhbCBhZGQnLCBlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6IFwiQUREX0VWRU5UXCIsIHBheWxvYWQ6IGV2ZW50IH0pO1xyXG4gICAgcmV0dXJuIGV2ZW50O1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlVXBkYXRlRXZlbnQoZXZlbnQ6IEV2ZW50LCBpZDogc3RyaW5nKSB7XHJcbiAgICAvLyBQcmVmZXIgdG8gbGV0IHRoZSBwYXJlbnQgcGVyc2lzdCB0aGUgY2hhbmdlIGFuZCByZXR1cm4gdGhlIGNhbm9uaWNhbFxyXG4gICAgLy8gZXZlbnQ7IG9ubHkgdGhlbiB1cGRhdGUgbG9jYWwgc3RhdGUgd2l0aCB0aGUgYXV0aG9yaXRhdGl2ZSB2YWx1ZXMuXHJcbiAgICBpZiAob25VcGRhdGVFdmVudCkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHJlczogYW55ID0gYXdhaXQgb25VcGRhdGVFdmVudCh7IC4uLmV2ZW50LCBpZCB9KTtcclxuICAgICAgICBpZiAocmVzICYmIHJlcy5pZCkge1xyXG4gICAgICAgICAgdHJ5IHsgZGlzcGF0Y2goeyB0eXBlOiBcIlVQREFURV9FVkVOVFwiLCBwYXlsb2FkOiByZXMgfSk7IH0gY2F0Y2ggKGUpIHt9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAvLyBJZiBwYXJlbnQgaGFuZGxlciBmYWlscywgZmFsbCBiYWNrIHRvIG9wdGltaXN0aWMgbG9jYWwgdXBkYXRlIHNvIFVJIHN0aWxsIHJlZmxlY3RzIGNoYW5nZVxyXG4gICAgICAgIGNvbnNvbGUud2FybignW1NjaGVkdWxlclByb3ZpZGVyXSBvblVwZGF0ZUV2ZW50IGhhbmRsZXIgZmFpbGVkLCBhcHBseWluZyBvcHRpbWlzdGljIHVwZGF0ZScsIGUpO1xyXG4gICAgICAgIHRyeSB7IGRpc3BhdGNoKHsgdHlwZTogXCJVUERBVEVfRVZFTlRcIiwgcGF5bG9hZDogeyAuLi5ldmVudCwgaWQgfSB9KTsgfSBjYXRjaCAoZXJyKSB7fVxyXG4gICAgICAgIC8vIHJldGhyb3cgc28gY2FsbGVycyBjYW4gaGFuZGxlIGZhaWx1cmUgaWYgbmVlZGVkXHJcbiAgICAgICAgdGhyb3cgZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIE5vIHBhcmVudCBoYW5kbGVyOiBkbyBhIGxvY2FsIG9wdGltaXN0aWMgdXBkYXRlXHJcbiAgICB0cnkge1xyXG4gICAgICBkaXNwYXRjaCh7IHR5cGU6IFwiVVBEQVRFX0VWRU5UXCIsIHBheWxvYWQ6IHsgLi4uZXZlbnQsIGlkIH0gfSk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignW1NjaGVkdWxlclByb3ZpZGVyXSBsb2NhbCBkaXNwYXRjaCB1cGRhdGUgZmFpbGVkJywgZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyAuLi5ldmVudCwgaWQgfTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGhhbmRsZURlbGV0ZUV2ZW50KGlkOiBzdHJpbmcpIHtcclxuICAgIGlmIChvbkRlbGV0ZUV2ZW50KSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgbWF5YmU6IGFueSA9IG9uRGVsZXRlRXZlbnQoaWQpO1xyXG4gICAgICAgIHJldHVybiBtYXliZTtcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIC8vIGZhbGwgYmFjayB0byBsb2NhbCByZW1vdmVcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiBcIlJFTU9WRV9FVkVOVFwiLCBwYXlsb2FkOiB7IGlkIH0gfSk7XHJcbiAgfVxyXG5cclxuICAvLyBMb2NhbC1vbmx5IGhhbmRsZXJzOiBhbGxvdyBjYWxsZXJzIHRvIHVwZGF0ZSBwcm92aWRlciBzdGF0ZSB3aXRob3V0IGRlbGVnYXRpbmdcclxuICAvLyBwZXJzaXN0ZW5jZSB0byBwYXJlbnQgcGFnZSBoYW5kbGVycy4gVXNlZnVsIHdoZW4gdGhlIGNhbGxlciBwZXJmb3JtcyB0aGVcclxuICAvLyBuZXR3b3JrIHJlcXVlc3QgaXRzZWxmIGFuZCBvbmx5IHdhbnRzIHRvIHVwZGF0ZSBVSSBhZnRlciBjb25maXJtYXRpb24uXHJcbiAgZnVuY3Rpb24gaGFuZGxlTG9jYWxBZGRFdmVudChldmVudDogRXZlbnQpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgLy8gZGVidWc6IGxvZyB0aGUgaW5jb21pbmcgZXZlbnQgZm9yIHRyb3VibGVzaG9vdGluZ1xyXG4gICAgICAgIGNvbnNvbGUuZGVidWcoJ1tTY2hlZHVsZXJQcm92aWRlcl0gaGFuZGxlTG9jYWxBZGRFdmVudCBpbmNvbWluZzonLCBldmVudCk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XHJcbiAgICAgIGRpc3BhdGNoKHsgdHlwZTogXCJBRERfRVZFTlRcIiwgcGF5bG9hZDogZXZlbnQgfSk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc29sZS5kZWJ1ZygnW1NjaGVkdWxlclByb3ZpZGVyXSBldmVudHMgYWZ0ZXIgYWRkIChjb3VudCk6JywgKHN0YXRlICYmIHN0YXRlLmV2ZW50cyAmJiBzdGF0ZS5ldmVudHMubGVuZ3RoKSA/IHN0YXRlLmV2ZW50cy5sZW5ndGggKyAxIDogJ3Vua25vd24nKTtcclxuICAgICAgfSBjYXRjaCAoZSkge31cclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgLy8gc3dhbGxvdyAtIFVJIGJlc3QtZWZmb3J0XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBoYW5kbGVMb2NhbFVwZGF0ZUV2ZW50KGV2ZW50OiBFdmVudCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zb2xlLmRlYnVnKCdbU2NoZWR1bGVyUHJvdmlkZXJdIGhhbmRsZUxvY2FsVXBkYXRlRXZlbnQgaW5jb21pbmc6JywgZXZlbnQpO1xyXG4gICAgICB9IGNhdGNoIChlKSB7fVxyXG4gICAgICBpZiAoIWV2ZW50IHx8ICFldmVudC5pZCkgcmV0dXJuO1xyXG4gICAgICBkaXNwYXRjaCh7IHR5cGU6IFwiVVBEQVRFX0VWRU5UXCIsIHBheWxvYWQ6IGV2ZW50IH0pO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnNvbGUuZGVidWcoJ1tTY2hlZHVsZXJQcm92aWRlcl0gZXZlbnRzIGFmdGVyIHVwZGF0ZSAoY291bnQpOicsIChzdGF0ZSAmJiBzdGF0ZS5ldmVudHMgJiYgc3RhdGUuZXZlbnRzLmxlbmd0aCkgPyBzdGF0ZS5ldmVudHMubGVuZ3RoIDogJ3Vua25vd24nKTtcclxuICAgICAgfSBjYXRjaCAoZSkge31cclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgLy8gc3dhbGxvd1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29uc3QgaGFuZGxlcnM6IEhhbmRsZXJzID0ge1xyXG4gICAgaGFuZGxlRXZlbnRTdHlsaW5nLFxyXG4gICAgaGFuZGxlQWRkRXZlbnQsXHJcbiAgICBoYW5kbGVVcGRhdGVFdmVudCxcclxuICAgIGhhbmRsZURlbGV0ZUV2ZW50LFxyXG4gICAgLy8gbG9jYWwtb25seSBoZWxwZXJzXHJcbiAgICBoYW5kbGVMb2NhbEFkZEV2ZW50LFxyXG4gICAgaGFuZGxlTG9jYWxVcGRhdGVFdmVudCxcclxuICB9O1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPFNjaGVkdWxlckNvbnRleHQuUHJvdmlkZXJcclxuICAgICAgLy8gaW5jbHVkZSByZWN1cnJlbmNlT3B0aW9ucyBpZiBwYXNzZWQgdmlhIHByb3BzIChrZXB0IGJhY2t3YXJkIGNvbXBhdGlibGUpXHJcbiAgICAgIHZhbHVlPXt7IGV2ZW50czogc3RhdGUsIGRpc3BhdGNoLCBnZXR0ZXJzLCBoYW5kbGVycywgd2Vla1N0YXJ0c09uLCByZWN1cnJlbmNlT3B0aW9ucyB9fVxyXG4gICAgPlxyXG4gICAgICA8TW9kYWxQcm92aWRlcj57Y2hpbGRyZW59PC9Nb2RhbFByb3ZpZGVyPlxyXG4gICAgPC9TY2hlZHVsZXJDb250ZXh0LlByb3ZpZGVyPlxyXG4gICk7XHJcbn07XHJcblxyXG4vLyBDdXN0b20gaG9vayB0byB1c2UgdGhlIHNjaGVkdWxlciBjb250ZXh0XHJcbmV4cG9ydCBjb25zdCB1c2VTY2hlZHVsZXIgPSAoKSA9PiB7XHJcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoU2NoZWR1bGVyQ29udGV4dCk7XHJcbiAgaWYgKCFjb250ZXh0KSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1c2VTY2hlZHVsZXIgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIFNjaGVkdWxlclByb3ZpZGVyXCIpO1xyXG4gIH1cclxuICByZXR1cm4gY29udGV4dDtcclxufTtcclxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VSZWR1Y2VyIiwidXNlRWZmZWN0IiwiTW9kYWxQcm92aWRlciIsInZhcmlhbnRzIiwiaW5pdGlhbFN0YXRlIiwiZXZlbnRzIiwic2NoZWR1bGVyUmVkdWNlciIsInN0YXRlIiwiYWN0aW9uIiwidHlwZSIsInBheWxvYWQiLCJpZCIsInNvbWUiLCJlIiwiZmlsdGVyIiwiZXZlbnQiLCJtYXAiLCJsaXN0IiwiQXJyYXkiLCJpc0FycmF5Iiwic2VlbiIsIlNldCIsImRlZHVwZWQiLCJldiIsImhhcyIsImFkZCIsIlNjaGVkdWxlckNvbnRleHQiLCJ1bmRlZmluZWQiLCJTY2hlZHVsZXJQcm92aWRlciIsImNoaWxkcmVuIiwib25BZGRFdmVudCIsIm9uVXBkYXRlRXZlbnQiLCJvbkRlbGV0ZUV2ZW50Iiwid2Vla1N0YXJ0c09uIiwicmVjdXJyZW5jZU9wdGlvbnMiLCJkaXNwYXRjaCIsImdldERheXNJbk1vbnRoIiwibW9udGgiLCJ5ZWFyIiwiZnJvbSIsImxlbmd0aCIsIkRhdGUiLCJnZXREYXRlIiwiXyIsImluZGV4IiwiZGF5IiwiZ2V0RGF5c0luV2VlayIsIndlZWsiLCJzdGFydERheSIsImphbkZpcnN0IiwiamFuRmlyc3REYXlPZldlZWsiLCJnZXREYXkiLCJ3ZWVrU3RhcnQiLCJzZXREYXRlIiwiZGF5cyIsImkiLCJwdXNoIiwiZ2V0V2Vla051bWJlciIsImRhdGUiLCJkIiwiVVRDIiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsInNldFVUQ0RhdGUiLCJnZXRVVENEYXRlIiwiZ2V0VVRDRGF5IiwieWVhclN0YXJ0IiwiZ2V0VVRDRnVsbFllYXIiLCJ3ZWVrTm8iLCJNYXRoIiwiY2VpbCIsImdldFRpbWUiLCJnZXRFdmVudHNGb3JEYXkiLCJjdXJyZW50RGF0ZSIsImV2ZW50U3RhcnQiLCJzdGFydERhdGUiLCJldmVudEVuZCIsImVuZERhdGUiLCJzdGFydE9mRGF5Iiwic2V0SG91cnMiLCJlbmRPZkRheSIsImlzU2FtZURheSIsImlzU3Bhbm5pbmdEYXkiLCJnZXREYXlOYW1lIiwiZ2V0dGVycyIsImhhbmRsZUV2ZW50U3R5bGluZyIsImRheUV2ZW50cyIsInBlcmlvZE9wdGlvbnMiLCJ0b01pbGxpcyIsImVuc3VyZURhdGUiLCJST1dfUFhfUEVSX0hPVVIiLCJpdGVtcyIsInMiLCJzdGFydE1pbnV0ZXMiLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJlbmRNaW51dGVzIiwiZHVyYXRpb24iLCJtYXgiLCJzb3J0IiwiYSIsImIiLCJjb2x1bW5zIiwiY29sdW1uc0luZGV4TWFwIiwiZm9yRWFjaCIsIml0IiwiaWR4IiwicGxhY2VkIiwiY2kiLCJjb2wiLCJsYXN0IiwidG90YWxDb2xzIiwidGhpc1N0YXJ0IiwidGhpc0VuZCIsInRoaXNTdGFydE1pbiIsInRoaXNFbmRNaW4iLCJ0aGlzRHVyYXRpb24iLCJjb2xJbmRleCIsIndpZHRoUGVyY2VudCIsImxlZnRQZXJjZW50IiwidG9wUHgiLCJoZWlnaHRQeCIsImhlaWdodCIsInRvcCIsInpJbmRleCIsImxlZnQiLCJtYXhXaWR0aCIsIm1pbldpZHRoIiwiaGFuZGxlQWRkRXZlbnQiLCJyZXMiLCJzdGF0dXMiLCJzdGF0dXNDb2RlIiwicmVzcG9uc2UiLCJOdW1iZXIiLCJjb25zb2xlIiwid2FybiIsImlubmVyIiwiaGFuZGxlVXBkYXRlRXZlbnQiLCJlcnIiLCJoYW5kbGVEZWxldGVFdmVudCIsIm1heWJlIiwiaGFuZGxlTG9jYWxBZGRFdmVudCIsImRlYnVnIiwiaGFuZGxlTG9jYWxVcGRhdGVFdmVudCIsImhhbmRsZXJzIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsInVzZVNjaGVkdWxlciIsImNvbnRleHQiLCJFcnJvciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/providers/schedular-provider.tsx\n"));

/***/ })

});