"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_src_components_schedule__components_view_week_week-view_tsx",{

/***/ "(pages-dir-browser)/./src/providers/schedular-provider.tsx":
/*!**********************************************!*\
  !*** ./src/providers/schedular-provider.tsx ***!
  \**********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SchedulerProvider: () => (/* binding */ SchedulerProvider),\n/* harmony export */   useScheduler: () => (/* binding */ useScheduler),\n/* harmony export */   variants: () => (/* binding */ variants)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _modal_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modal-context */ \"(pages-dir-browser)/./src/providers/modal-context.tsx\");\n/* __next_internal_client_entry_do_not_use__ variants,SchedulerProvider,useScheduler auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n// SchedulerContext.tsx\n\n\n// Define the variant options\nconst variants = [\n    \"success\",\n    \"primary\",\n    \"default\",\n    \"warning\",\n    \"danger\"\n];\n// Initial state\nconst initialState = {\n    events: []\n};\n// Reducer function\nconst schedulerReducer = (state, action)=>{\n    switch(action.type){\n        case \"ADD_EVENT\":\n            // avoid duplicates by id\n            if (!action.payload || !action.payload.id) {\n                return state;\n            }\n            if (state.events.some((e)=>e.id === action.payload.id)) return state;\n            return {\n                ...state,\n                events: [\n                    ...state.events,\n                    action.payload\n                ]\n            };\n        case \"REMOVE_EVENT\":\n            return {\n                ...state,\n                events: state.events.filter((event)=>event.id !== action.payload.id)\n            };\n        case \"UPDATE_EVENT\":\n            return {\n                ...state,\n                events: state.events.map((event)=>event.id === action.payload.id ? action.payload : event)\n            };\n        case \"SET_EVENTS\":\n            // ensure payload is deduped by id\n            const list = Array.isArray(action.payload) ? action.payload : [];\n            const seen = new Set();\n            const deduped = list.filter((ev)=>{\n                if (!ev || !ev.id) return false;\n                if (seen.has(ev.id)) return false;\n                seen.add(ev.id);\n                return true;\n            });\n            return {\n                ...state,\n                events: deduped\n            };\n        default:\n            return state;\n    }\n};\n// Create the context with the correct type\nconst SchedulerContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\n// Provider component\nconst SchedulerProvider = ({ children, onAddEvent, onUpdateEvent, onDeleteEvent, initialState, weekStartsOn = \"sunday\" })=>{\n    _s();\n    const [state, dispatch] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useReducer)(schedulerReducer, {\n        events: initialState ?? []\n    } // Sets initialState or an empty array as the default\n    );\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SchedulerProvider.useEffect\": ()=>{\n            if (initialState) {\n                dispatch({\n                    type: \"SET_EVENTS\",\n                    payload: initialState\n                });\n            }\n        }\n    }[\"SchedulerProvider.useEffect\"], [\n        initialState\n    ]);\n    // global getters\n    const getDaysInMonth = (month, year)=>{\n        return Array.from({\n            length: new Date(year, month + 1, 0).getDate()\n        }, (_, index)=>({\n                day: index + 1,\n                events: []\n            }));\n    };\n    const getDaysInWeek = (week, year)=>{\n        // Determine if the week should start on Sunday (0) or Monday (1)\n        const startDay = weekStartsOn === \"sunday\" ? 0 : 1;\n        // Get January 1st of the year\n        const janFirst = new Date(year, 0, 1);\n        // Calculate how many days we are offsetting from January 1st\n        const janFirstDayOfWeek = janFirst.getDay();\n        // Calculate the start of the week by finding the correct day in the year\n        const weekStart = new Date(janFirst);\n        weekStart.setDate(janFirst.getDate() + (week - 1) * 7 + (startDay - janFirstDayOfWeek + 7) % 7);\n        // Generate the week's days\n        const days = [];\n        for(let i = 0; i < 7; i++){\n            const day = new Date(weekStart);\n            day.setDate(day.getDate() + i);\n            days.push(day);\n        }\n        return days;\n    };\n    const getWeekNumber = (date)=>{\n        const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));\n        d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));\n        const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));\n        const weekNo = Math.ceil(((d.getTime() - yearStart.getTime()) / 86400000 + 1) / 7);\n        return weekNo;\n    };\n    // Helper function to filter events for a specific day\n    const getEventsForDay = (day, currentDate)=>{\n        return state?.events.filter((event)=>{\n            const eventStart = new Date(event.startDate);\n            const eventEnd = new Date(event.endDate);\n            // Create new Date objects to avoid mutating `currentDate`\n            const startOfDay = new Date(currentDate);\n            startOfDay.setDate(day);\n            startOfDay.setHours(0, 0, 0, 0);\n            const endOfDay = new Date(currentDate);\n            endOfDay.setDate(day + 1);\n            endOfDay.setHours(0, 0, 0, 0);\n            // Check if the event starts or spans across the given day\n            const isSameDay = eventStart.getDate() === day && eventStart.getMonth() === currentDate.getMonth() && eventStart.getFullYear() === currentDate.getFullYear();\n            const isSpanningDay = eventStart < endOfDay && eventEnd >= startOfDay;\n            return isSameDay || isSpanningDay;\n        });\n    };\n    const getDayName = (day)=>{\n        const days = [\n            \"Sun\",\n            \"Mon\",\n            \"Tue\",\n            \"Wed\",\n            \"Thu\",\n            \"Fri\",\n            \"Sat\"\n        ];\n        return days[day];\n    };\n    const getters = {\n        getDaysInMonth,\n        getEventsForDay,\n        getDaysInWeek,\n        getWeekNumber,\n        getDayName\n    };\n    // handlers\n    function handleEventStyling(event, dayEvents, periodOptions) {\n        // Mina-inspired minutes-based layout\n        const toMillis = (d)=>d instanceof Date ? d.getTime() : new Date(d).getTime();\n        const ensureDate = (d)=>d instanceof Date ? d : new Date(d);\n        // Row height per hour - matches the hourly row height used in day/week views (64px)\n        const ROW_PX_PER_HOUR = 64;\n        // Build a list of items for the same day (or overlapping range)\n        const items = (dayEvents || []).filter((ev)=>ev && ev.startDate && ev.endDate).map((ev)=>{\n            const s = ensureDate(ev.startDate);\n            const e = ensureDate(ev.endDate);\n            const startMinutes = s.getHours() * 60 + s.getMinutes();\n            const endMinutes = e.getHours() * 60 + e.getMinutes();\n            const duration = Math.max(1, endMinutes - startMinutes);\n            return {\n                ev,\n                startMinutes,\n                endMinutes,\n                duration\n            };\n        }).sort((a, b)=>a.startMinutes - b.startMinutes || b.endMinutes - a.endMinutes);\n        // Simple column packing like Mina: place each event in the first column that doesn't overlap\n        const columns = [];\n        const columnsIndexMap = [];\n        items.forEach((it, idx)=>{\n            let placed = false;\n            for(let ci = 0; ci < columns.length; ci++){\n                const col = columns[ci];\n                const last = col[col.length - 1];\n                if (it.startMinutes >= last.endMinutes) {\n                    col.push(it);\n                    columnsIndexMap[idx] = ci;\n                    placed = true;\n                    break;\n                }\n            }\n            if (!placed) {\n                columnsIndexMap[idx] = columns.length;\n                columns.push([\n                    it\n                ]);\n            }\n        });\n        const totalCols = Math.max(1, columns.length);\n        // Find current event item\n        const thisStart = ensureDate(event.startDate);\n        const thisEnd = ensureDate(event.endDate);\n        const thisStartMin = thisStart.getHours() * 60 + thisStart.getMinutes();\n        const thisEndMin = thisEnd.getHours() * 60 + thisEnd.getMinutes();\n        const thisDuration = Math.max(1, thisEndMin - thisStartMin);\n        // Determine which column index this event occupies (fallback to 0)\n        let colIndex = 0;\n        for(let ci = 0; ci < columns.length; ci++){\n            if (columns[ci].some((it)=>it.ev.id === event.id)) {\n                colIndex = ci;\n                break;\n            }\n        }\n        const widthPercent = 100 / totalCols;\n        const leftPercent = colIndex * widthPercent;\n        // Compute pixels\n        const topPx = thisStartMin / 60 * ROW_PX_PER_HOUR;\n        const heightPx = Math.max(20, thisDuration / 60 * ROW_PX_PER_HOUR);\n        return {\n            height: `${heightPx}px`,\n            top: `${topPx}px`,\n            zIndex: colIndex + 1,\n            left: `${leftPercent}%`,\n            maxWidth: `${widthPercent}%`,\n            minWidth: `${widthPercent}%`\n        };\n    }\n    async function handleAddEvent(event) {\n        // If a parent handler is provided, call it and await its result. Only\n        // update local state after the parent returns a server-canonical event so\n        // the provider does not keep optimistic (possibly different) values that\n        // get overwritten on reload.\n        if (onAddEvent) {\n            try {\n                const res = await onAddEvent(event);\n                // If parent returned the saved canonical event, use it to update local state\n                if (res && res.id) {\n                    try {\n                        dispatch({\n                            type: \"ADD_EVENT\",\n                            payload: res\n                        });\n                    } catch (e) {}\n                }\n                return res;\n            } catch (e) {\n                // If the error is a client-side (4xx) response, rethrow so callers can show validation\n                // Otherwise (network error or 5xx) we can fallback to local optimistic add to keep UI responsive\n                try {\n                    const status = e && (e.status || e.statusCode || e.response && e.response.status);\n                    if (status && Number(status) >= 400 && Number(status) < 500) {\n                        console.warn('[SchedulerProvider] onAddEvent returned client error, aborting local fallback', status, e);\n                        throw e;\n                    }\n                } catch (inner) {}\n                console.warn('[SchedulerProvider] onAddEvent handler failed, falling back to local add', e);\n            }\n        }\n        dispatch({\n            type: \"ADD_EVENT\",\n            payload: event\n        });\n        return event;\n    }\n    async function handleUpdateEvent(event, id) {\n        // Prefer to let the parent persist the change and return the canonical\n        // event; only then update local state with the authoritative values.\n        if (onUpdateEvent) {\n            try {\n                const res = await onUpdateEvent({\n                    ...event,\n                    id\n                });\n                if (res && res.id) {\n                    try {\n                        dispatch({\n                            type: \"UPDATE_EVENT\",\n                            payload: res\n                        });\n                    } catch (e) {}\n                }\n                return res;\n            } catch (e) {\n                // If parent handler fails, fall back to optimistic local update so UI still reflects change\n                console.warn('[SchedulerProvider] onUpdateEvent handler failed, applying optimistic update', e);\n                try {\n                    dispatch({\n                        type: \"UPDATE_EVENT\",\n                        payload: {\n                            ...event,\n                            id\n                        }\n                    });\n                } catch (err) {}\n                // rethrow so callers can handle failure if needed\n                throw e;\n            }\n        }\n        // No parent handler: do a local optimistic update\n        try {\n            dispatch({\n                type: \"UPDATE_EVENT\",\n                payload: {\n                    ...event,\n                    id\n                }\n            });\n        } catch (e) {\n            console.warn('[SchedulerProvider] local dispatch update failed', e);\n        }\n        return {\n            ...event,\n            id\n        };\n    }\n    function handleDeleteEvent(id) {\n        if (onDeleteEvent) {\n            try {\n                const maybe = onDeleteEvent(id);\n                return maybe;\n            } catch (e) {\n            // fall back to local remove\n            }\n        }\n        dispatch({\n            type: \"REMOVE_EVENT\",\n            payload: {\n                id\n            }\n        });\n    }\n    // Local-only handlers: allow callers to update provider state without delegating\n    // persistence to parent page handlers. Useful when the caller performs the\n    // network request itself and only wants to update UI after confirmation.\n    function handleLocalAddEvent(event) {\n        try {\n            try {\n                // debug: log the incoming event for troubleshooting\n                console.debug('[SchedulerProvider] handleLocalAddEvent incoming:', event);\n            } catch (e) {}\n            dispatch({\n                type: \"ADD_EVENT\",\n                payload: event\n            });\n            try {\n                console.debug('[SchedulerProvider] events after add (count):', state && state.events && state.events.length ? state.events.length + 1 : 'unknown');\n            } catch (e) {}\n        } catch (e) {\n        // swallow - UI best-effort\n        }\n    }\n    function handleLocalUpdateEvent(event) {\n        try {\n            try {\n                console.debug('[SchedulerProvider] handleLocalUpdateEvent incoming:', event);\n            } catch (e) {}\n            if (!event || !event.id) return;\n            dispatch({\n                type: \"UPDATE_EVENT\",\n                payload: event\n            });\n            try {\n                console.debug('[SchedulerProvider] events after update (count):', state && state.events && state.events.length ? state.events.length : 'unknown');\n            } catch (e) {}\n        } catch (e) {\n        // swallow\n        }\n    }\n    const handlers = {\n        handleEventStyling,\n        handleAddEvent,\n        handleUpdateEvent,\n        handleDeleteEvent,\n        // local-only helpers\n        handleLocalAddEvent,\n        handleLocalUpdateEvent\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(SchedulerContext.Provider, {\n        // include recurrenceOptions if passed via props (kept backward compatible)\n        value: {\n            events: state,\n            dispatch,\n            getters,\n            handlers,\n            weekStartsOn\n        },\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_modal_context__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n            children: children\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\university-planner\\\\src\\\\providers\\\\schedular-provider.tsx\",\n            lineNumber: 408,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\university-planner\\\\src\\\\providers\\\\schedular-provider.tsx\",\n        lineNumber: 404,\n        columnNumber: 5\n    }, undefined);\n};\n_s(SchedulerProvider, \"+GWmRPgPwRqyHMb75g9kmdyxOrA=\");\n_c = SchedulerProvider;\n// Custom hook to use the scheduler context\nconst useScheduler = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(SchedulerContext);\n    if (!context) {\n        throw new Error(\"useScheduler must be used within a SchedulerProvider\");\n    }\n    return context;\n};\n_s1(useScheduler, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"SchedulerProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9wcm92aWRlcnMvc2NoZWR1bGFyLXByb3ZpZGVyLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBRUEsdUJBQXVCO0FBUVI7QUFXNkI7QUFPNUMsNkJBQTZCO0FBQ3RCLE1BQU1NLFdBQVc7SUFDdEI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNELENBQVU7QUFFWCxnQkFBZ0I7QUFDaEIsTUFBTUMsZUFBK0I7SUFDbkNDLFFBQVEsRUFBRTtBQUNaO0FBRUEsbUJBQW1CO0FBQ25CLE1BQU1DLG1CQUFtQixDQUN2QkMsT0FDQUM7SUFFQSxPQUFRQSxPQUFPQyxJQUFJO1FBQ2pCLEtBQUs7WUFDSCx5QkFBeUI7WUFDekIsSUFBSSxDQUFDRCxPQUFPRSxPQUFPLElBQUksQ0FBQ0YsT0FBT0UsT0FBTyxDQUFDQyxFQUFFLEVBQUU7Z0JBQ3pDLE9BQU9KO1lBQ1Q7WUFDQSxJQUFJQSxNQUFNRixNQUFNLENBQUNPLElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUYsRUFBRSxLQUFLSCxPQUFPRSxPQUFPLENBQUNDLEVBQUUsR0FBRyxPQUFPSjtZQUMvRCxPQUFPO2dCQUFFLEdBQUdBLEtBQUs7Z0JBQUVGLFFBQVE7dUJBQUlFLE1BQU1GLE1BQU07b0JBQUVHLE9BQU9FLE9BQU87aUJBQUM7WUFBQztRQUUvRCxLQUFLO1lBQ0gsT0FBTztnQkFDTCxHQUFHSCxLQUFLO2dCQUNSRixRQUFRRSxNQUFNRixNQUFNLENBQUNTLE1BQU0sQ0FBQyxDQUFDQyxRQUFVQSxNQUFNSixFQUFFLEtBQUtILE9BQU9FLE9BQU8sQ0FBQ0MsRUFBRTtZQUN2RTtRQUNGLEtBQUs7WUFDSCxPQUFPO2dCQUNMLEdBQUdKLEtBQUs7Z0JBQ1JGLFFBQVFFLE1BQU1GLE1BQU0sQ0FBQ1csR0FBRyxDQUFDLENBQUNELFFBQ3hCQSxNQUFNSixFQUFFLEtBQUtILE9BQU9FLE9BQU8sQ0FBQ0MsRUFBRSxHQUFHSCxPQUFPRSxPQUFPLEdBQUdLO1lBRXRE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OERBQUNwSCxpQkFBaUJzSCxRQUFRO1FBQ3hCLDJFQUEyRTtRQUMzRUMsT0FBTztZQUFFNUksUUFBUUU7WUFBTzJCO1lBQVVpRDtZQUFTNEQ7WUFBVTlHO1FBQWE7a0JBRWxFLDRFQUFDL0Isc0RBQWFBO3NCQUFFMkI7Ozs7Ozs7Ozs7O0FBR3RCLEVBQUU7R0EvVFdEO0tBQUFBO0FBaVViLDJDQUEyQztBQUNwQyxNQUFNc0gsZUFBZTs7SUFDMUIsTUFBTUMsVUFBVXBKLGlEQUFVQSxDQUFDMkI7SUFDM0IsSUFBSSxDQUFDeUgsU0FBUztRQUNaLE1BQU0sSUFBSUMsTUFBTTtJQUNsQjtJQUNBLE9BQU9EO0FBQ1QsRUFBRTtJQU5XRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFx1bml2ZXJzaXR5LXBsYW5uZXJcXHNyY1xccHJvdmlkZXJzXFxzY2hlZHVsYXItcHJvdmlkZXIudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xyXG5cclxuLy8gU2NoZWR1bGVyQ29udGV4dC50c3hcclxuaW1wb3J0IFJlYWN0LCB7XHJcbiAgY3JlYXRlQ29udGV4dCxcclxuICB1c2VDb250ZXh0LFxyXG4gIHVzZVJlZHVjZXIsXHJcbiAgUmVhY3ROb2RlLFxyXG4gIERpc3BhdGNoLFxyXG4gIHVzZUVmZmVjdCxcclxufSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IHsgeiB9IGZyb20gXCJ6b2RcIjtcclxuXHJcbmltcG9ydCB7XHJcbiAgQWN0aW9uLFxyXG4gIEV2ZW50LFxyXG4gIEdldHRlcnMsXHJcbiAgSGFuZGxlcnMsXHJcbiAgU2NoZWR1bGVyQ29udGV4dFR5cGUsXHJcbiAgc3RhcnRPZldlZWssXHJcbn0gZnJvbSBcIkAvdHlwZXMvaW5kZXhcIjtcclxuaW1wb3J0IE1vZGFsUHJvdmlkZXIgZnJvbSBcIi4vbW9kYWwtY29udGV4dFwiO1xyXG4vLyBEZWZpbmUgZXZlbnQgYW5kIHN0YXRlIHR5cGVzXHJcblxyXG5pbnRlcmZhY2UgU2NoZWR1bGVyU3RhdGUge1xyXG4gIGV2ZW50czogRXZlbnRbXTtcclxufVxyXG5cclxuLy8gRGVmaW5lIHRoZSB2YXJpYW50IG9wdGlvbnNcclxuZXhwb3J0IGNvbnN0IHZhcmlhbnRzID0gW1xyXG4gIFwic3VjY2Vzc1wiLFxyXG4gIFwicHJpbWFyeVwiLFxyXG4gIFwiZGVmYXVsdFwiLFxyXG4gIFwid2FybmluZ1wiLFxyXG4gIFwiZGFuZ2VyXCIsXHJcbl0gYXMgY29uc3Q7XHJcblxyXG4vLyBJbml0aWFsIHN0YXRlXHJcbmNvbnN0IGluaXRpYWxTdGF0ZTogU2NoZWR1bGVyU3RhdGUgPSB7XHJcbiAgZXZlbnRzOiBbXSxcclxufTtcclxuXHJcbi8vIFJlZHVjZXIgZnVuY3Rpb25cclxuY29uc3Qgc2NoZWR1bGVyUmVkdWNlciA9IChcclxuICBzdGF0ZTogU2NoZWR1bGVyU3RhdGUsXHJcbiAgYWN0aW9uOiBBY3Rpb25cclxuKTogU2NoZWR1bGVyU3RhdGUgPT4ge1xyXG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcclxuICAgIGNhc2UgXCJBRERfRVZFTlRcIjpcclxuICAgICAgLy8gYXZvaWQgZHVwbGljYXRlcyBieSBpZFxyXG4gICAgICBpZiAoIWFjdGlvbi5wYXlsb2FkIHx8ICFhY3Rpb24ucGF5bG9hZC5pZCkge1xyXG4gICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc3RhdGUuZXZlbnRzLnNvbWUoZSA9PiBlLmlkID09PSBhY3Rpb24ucGF5bG9hZC5pZCkpIHJldHVybiBzdGF0ZTtcclxuICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsIGV2ZW50czogWy4uLnN0YXRlLmV2ZW50cywgYWN0aW9uLnBheWxvYWRdIH07XHJcblxyXG4gICAgY2FzZSBcIlJFTU9WRV9FVkVOVFwiOlxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIC4uLnN0YXRlLFxyXG4gICAgICAgIGV2ZW50czogc3RhdGUuZXZlbnRzLmZpbHRlcigoZXZlbnQpID0+IGV2ZW50LmlkICE9PSBhY3Rpb24ucGF5bG9hZC5pZCksXHJcbiAgICAgIH07XHJcbiAgICBjYXNlIFwiVVBEQVRFX0VWRU5UXCI6XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgLi4uc3RhdGUsXHJcbiAgICAgICAgZXZlbnRzOiBzdGF0ZS5ldmVudHMubWFwKChldmVudCkgPT5cclxuICAgICAgICAgIGV2ZW50LmlkID09PSBhY3Rpb24ucGF5bG9hZC5pZCA/IGFjdGlvbi5wYXlsb2FkIDogZXZlbnRcclxuICAgICAgICApLFxyXG4gICAgICB9O1xyXG4gICAgY2FzZSBcIlNFVF9FVkVOVFNcIjpcclxuICAgICAgLy8gZW5zdXJlIHBheWxvYWQgaXMgZGVkdXBlZCBieSBpZFxyXG4gICAgICBjb25zdCBsaXN0ID0gQXJyYXkuaXNBcnJheShhY3Rpb24ucGF5bG9hZCkgPyBhY3Rpb24ucGF5bG9hZCA6IFtdO1xyXG4gICAgICBjb25zdCBzZWVuID0gbmV3IFNldCgpO1xyXG4gICAgICBjb25zdCBkZWR1cGVkID0gbGlzdC5maWx0ZXIoKGV2OiBFdmVudCkgPT4ge1xyXG4gICAgICAgIGlmICghZXYgfHwgIWV2LmlkKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKHNlZW4uaGFzKGV2LmlkKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHNlZW4uYWRkKGV2LmlkKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiB7IC4uLnN0YXRlLCBldmVudHM6IGRlZHVwZWQgfTtcclxuXHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gc3RhdGU7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gQ3JlYXRlIHRoZSBjb250ZXh0IHdpdGggdGhlIGNvcnJlY3QgdHlwZVxyXG5jb25zdCBTY2hlZHVsZXJDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxTY2hlZHVsZXJDb250ZXh0VHlwZSB8IHVuZGVmaW5lZD4oXHJcbiAgdW5kZWZpbmVkXHJcbik7XHJcblxyXG4vLyBQcm92aWRlciBjb21wb25lbnRcclxuZXhwb3J0IGNvbnN0IFNjaGVkdWxlclByb3ZpZGVyID0gKHtcclxuICBjaGlsZHJlbixcclxuICBvbkFkZEV2ZW50LFxyXG4gIG9uVXBkYXRlRXZlbnQsXHJcbiAgb25EZWxldGVFdmVudCxcclxuICBpbml0aWFsU3RhdGUsXHJcbiAgd2Vla1N0YXJ0c09uID0gXCJzdW5kYXlcIixcclxufToge1xyXG4gIG9uQWRkRXZlbnQ/OiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkO1xyXG4gIG9uVXBkYXRlRXZlbnQ/OiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkO1xyXG4gIG9uRGVsZXRlRXZlbnQ/OiAoaWQ6IHN0cmluZykgPT4gdm9pZDtcclxuICB3ZWVrU3RhcnRzT24/OiBzdGFydE9mV2VlaztcclxuICBjaGlsZHJlbjogUmVhY3ROb2RlO1xyXG4gIGluaXRpYWxTdGF0ZT86IEV2ZW50W107XHJcbn0pID0+IHtcclxuICBjb25zdCBbc3RhdGUsIGRpc3BhdGNoXSA9IHVzZVJlZHVjZXIoXHJcbiAgICBzY2hlZHVsZXJSZWR1Y2VyLFxyXG4gICAgeyBldmVudHM6IGluaXRpYWxTdGF0ZSA/PyBbXSB9IC8vIFNldHMgaW5pdGlhbFN0YXRlIG9yIGFuIGVtcHR5IGFycmF5IGFzIHRoZSBkZWZhdWx0XHJcbiAgKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmIChpbml0aWFsU3RhdGUpIHtcclxuICAgICAgZGlzcGF0Y2goeyB0eXBlOiBcIlNFVF9FVkVOVFNcIiwgcGF5bG9hZDogaW5pdGlhbFN0YXRlIH0pO1xyXG4gICAgfVxyXG4gIH0sIFtpbml0aWFsU3RhdGVdKTtcclxuXHJcbiAgLy8gZ2xvYmFsIGdldHRlcnNcclxuICBjb25zdCBnZXREYXlzSW5Nb250aCA9IChtb250aDogbnVtYmVyLCB5ZWFyOiBudW1iZXIpID0+IHtcclxuICAgIHJldHVybiBBcnJheS5mcm9tKFxyXG4gICAgICB7IGxlbmd0aDogbmV3IERhdGUoeWVhciwgbW9udGggKyAxLCAwKS5nZXREYXRlKCkgfSxcclxuICAgICAgKF8sIGluZGV4KSA9PiAoe1xyXG4gICAgICAgIGRheTogaW5kZXggKyAxLFxyXG4gICAgICAgIGV2ZW50czogW10sXHJcbiAgICAgIH0pXHJcbiAgICApO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGdldERheXNJbldlZWsgPSAod2VlazogbnVtYmVyLCB5ZWFyOiBudW1iZXIpID0+IHtcclxuICAgIC8vIERldGVybWluZSBpZiB0aGUgd2VlayBzaG91bGQgc3RhcnQgb24gU3VuZGF5ICgwKSBvciBNb25kYXkgKDEpXHJcbiAgICBjb25zdCBzdGFydERheSA9IHdlZWtTdGFydHNPbiA9PT0gXCJzdW5kYXlcIiA/IDAgOiAxO1xyXG5cclxuICAgIC8vIEdldCBKYW51YXJ5IDFzdCBvZiB0aGUgeWVhclxyXG4gICAgY29uc3QgamFuRmlyc3QgPSBuZXcgRGF0ZSh5ZWFyLCAwLCAxKTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgaG93IG1hbnkgZGF5cyB3ZSBhcmUgb2Zmc2V0dGluZyBmcm9tIEphbnVhcnkgMXN0XHJcbiAgICBjb25zdCBqYW5GaXJzdERheU9mV2VlayA9IGphbkZpcnN0LmdldERheSgpO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSB0aGUgc3RhcnQgb2YgdGhlIHdlZWsgYnkgZmluZGluZyB0aGUgY29ycmVjdCBkYXkgaW4gdGhlIHllYXJcclxuICAgIGNvbnN0IHdlZWtTdGFydCA9IG5ldyBEYXRlKGphbkZpcnN0KTtcclxuICAgIHdlZWtTdGFydC5zZXREYXRlKFxyXG4gICAgICBqYW5GaXJzdC5nZXREYXRlKCkgK1xyXG4gICAgICAgICh3ZWVrIC0gMSkgKiA3ICtcclxuICAgICAgICAoKHN0YXJ0RGF5IC0gamFuRmlyc3REYXlPZldlZWsgKyA3KSAlIDcpXHJcbiAgICApO1xyXG5cclxuICAgIC8vIEdlbmVyYXRlIHRoZSB3ZWVrJ3MgZGF5c1xyXG4gICAgY29uc3QgZGF5cyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA3OyBpKyspIHtcclxuICAgICAgY29uc3QgZGF5ID0gbmV3IERhdGUod2Vla1N0YXJ0KTtcclxuICAgICAgZGF5LnNldERhdGUoZGF5LmdldERhdGUoKSArIGkpO1xyXG4gICAgICBkYXlzLnB1c2goZGF5KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGF5cztcclxuICB9O1xyXG5cclxuICBjb25zdCBnZXRXZWVrTnVtYmVyID0gKGRhdGU6IERhdGUpID0+IHtcclxuICAgIGNvbnN0IGQgPSBuZXcgRGF0ZShcclxuICAgICAgRGF0ZS5VVEMoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpKVxyXG4gICAgKTtcclxuICAgIGQuc2V0VVRDRGF0ZShkLmdldFVUQ0RhdGUoKSArIDQgLSAoZC5nZXRVVENEYXkoKSB8fCA3KSk7XHJcbiAgICBjb25zdCB5ZWFyU3RhcnQgPSBuZXcgRGF0ZShEYXRlLlVUQyhkLmdldFVUQ0Z1bGxZZWFyKCksIDAsIDEpKTtcclxuICAgIGNvbnN0IHdlZWtObyA9IE1hdGguY2VpbChcclxuICAgICAgKChkLmdldFRpbWUoKSAtIHllYXJTdGFydC5nZXRUaW1lKCkpIC8gODY0MDAwMDAgKyAxKSAvIDdcclxuICAgICk7XHJcbiAgICByZXR1cm4gd2Vla05vO1xyXG4gIH07XHJcblxyXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBmaWx0ZXIgZXZlbnRzIGZvciBhIHNwZWNpZmljIGRheVxyXG4gIGNvbnN0IGdldEV2ZW50c0ZvckRheSA9IChkYXk6IG51bWJlciwgY3VycmVudERhdGU6IERhdGUpID0+IHtcclxuICAgIHJldHVybiBzdGF0ZT8uZXZlbnRzLmZpbHRlcigoZXZlbnQpID0+IHtcclxuICAgICAgY29uc3QgZXZlbnRTdGFydCA9IG5ldyBEYXRlKGV2ZW50LnN0YXJ0RGF0ZSk7XHJcbiAgICAgIGNvbnN0IGV2ZW50RW5kID0gbmV3IERhdGUoZXZlbnQuZW5kRGF0ZSk7XHJcblxyXG4gICAgICAvLyBDcmVhdGUgbmV3IERhdGUgb2JqZWN0cyB0byBhdm9pZCBtdXRhdGluZyBgY3VycmVudERhdGVgXHJcbiAgICAgIGNvbnN0IHN0YXJ0T2ZEYXkgPSBuZXcgRGF0ZShjdXJyZW50RGF0ZSk7XHJcbiAgICAgIHN0YXJ0T2ZEYXkuc2V0RGF0ZShkYXkpO1xyXG4gICAgICBzdGFydE9mRGF5LnNldEhvdXJzKDAsIDAsIDAsIDApO1xyXG5cclxuICAgICAgY29uc3QgZW5kT2ZEYXkgPSBuZXcgRGF0ZShjdXJyZW50RGF0ZSk7XHJcbiAgICAgIGVuZE9mRGF5LnNldERhdGUoZGF5ICsgMSk7XHJcbiAgICAgIGVuZE9mRGF5LnNldEhvdXJzKDAsIDAsIDAsIDApO1xyXG5cclxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGV2ZW50IHN0YXJ0cyBvciBzcGFucyBhY3Jvc3MgdGhlIGdpdmVuIGRheVxyXG4gICAgICBjb25zdCBpc1NhbWVEYXkgPVxyXG4gICAgICAgIGV2ZW50U3RhcnQuZ2V0RGF0ZSgpID09PSBkYXkgJiZcclxuICAgICAgICBldmVudFN0YXJ0LmdldE1vbnRoKCkgPT09IGN1cnJlbnREYXRlLmdldE1vbnRoKCkgJiZcclxuICAgICAgICBldmVudFN0YXJ0LmdldEZ1bGxZZWFyKCkgPT09IGN1cnJlbnREYXRlLmdldEZ1bGxZZWFyKCk7XHJcblxyXG4gICAgICBjb25zdCBpc1NwYW5uaW5nRGF5ID0gZXZlbnRTdGFydCA8IGVuZE9mRGF5ICYmIGV2ZW50RW5kID49IHN0YXJ0T2ZEYXk7XHJcblxyXG4gICAgICByZXR1cm4gaXNTYW1lRGF5IHx8IGlzU3Bhbm5pbmdEYXk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICBjb25zdCBnZXREYXlOYW1lID0gKGRheTogbnVtYmVyKSA9PiB7XHJcbiAgICBjb25zdCBkYXlzID0gW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdO1xyXG4gICAgcmV0dXJuIGRheXNbZGF5XTtcclxuICB9O1xyXG5cclxuICBjb25zdCBnZXR0ZXJzOiBHZXR0ZXJzID0ge1xyXG4gICAgZ2V0RGF5c0luTW9udGgsXHJcbiAgICBnZXRFdmVudHNGb3JEYXksXHJcbiAgICBnZXREYXlzSW5XZWVrLFxyXG4gICAgZ2V0V2Vla051bWJlcixcclxuICAgIGdldERheU5hbWUsXHJcbiAgfTtcclxuXHJcbiAgLy8gaGFuZGxlcnNcclxuICBmdW5jdGlvbiBoYW5kbGVFdmVudFN0eWxpbmcoXHJcbiAgICBldmVudDogRXZlbnQsIFxyXG4gICAgZGF5RXZlbnRzOiBFdmVudFtdLFxyXG4gICAgcGVyaW9kT3B0aW9ucz86IHsgXHJcbiAgICAgIGV2ZW50c0luU2FtZVBlcmlvZD86IG51bWJlcjsgXHJcbiAgICAgIHBlcmlvZEluZGV4PzogbnVtYmVyOyBcclxuICAgICAgYWRqdXN0Rm9yUGVyaW9kPzogYm9vbGVhbjtcclxuICAgIH1cclxuICApIHtcclxuICAgIC8vIE1pbmEtaW5zcGlyZWQgbWludXRlcy1iYXNlZCBsYXlvdXRcclxuICAgIGNvbnN0IHRvTWlsbGlzID0gKGQ6IGFueSkgPT4gKGQgaW5zdGFuY2VvZiBEYXRlID8gZC5nZXRUaW1lKCkgOiBuZXcgRGF0ZShkKS5nZXRUaW1lKCkpO1xyXG4gICAgY29uc3QgZW5zdXJlRGF0ZSA9IChkOiBhbnkpID0+IChkIGluc3RhbmNlb2YgRGF0ZSA/IGQgOiBuZXcgRGF0ZShkKSk7XHJcblxyXG4gICAgLy8gUm93IGhlaWdodCBwZXIgaG91ciAtIG1hdGNoZXMgdGhlIGhvdXJseSByb3cgaGVpZ2h0IHVzZWQgaW4gZGF5L3dlZWsgdmlld3MgKDY0cHgpXHJcbiAgICBjb25zdCBST1dfUFhfUEVSX0hPVVIgPSA2NDtcclxuXHJcbiAgICAvLyBCdWlsZCBhIGxpc3Qgb2YgaXRlbXMgZm9yIHRoZSBzYW1lIGRheSAob3Igb3ZlcmxhcHBpbmcgcmFuZ2UpXHJcbiAgICBjb25zdCBpdGVtcyA9IChkYXlFdmVudHMgfHwgW10pLmZpbHRlcigoZXYpID0+IGV2ICYmIGV2LnN0YXJ0RGF0ZSAmJiBldi5lbmREYXRlKS5tYXAoZXYgPT4ge1xyXG4gICAgICBjb25zdCBzID0gZW5zdXJlRGF0ZShldi5zdGFydERhdGUpO1xyXG4gICAgICBjb25zdCBlID0gZW5zdXJlRGF0ZShldi5lbmREYXRlKTtcclxuICAgICAgY29uc3Qgc3RhcnRNaW51dGVzID0gcy5nZXRIb3VycygpICogNjAgKyBzLmdldE1pbnV0ZXMoKTtcclxuICAgICAgY29uc3QgZW5kTWludXRlcyA9IGUuZ2V0SG91cnMoKSAqIDYwICsgZS5nZXRNaW51dGVzKCk7XHJcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gTWF0aC5tYXgoMSwgZW5kTWludXRlcyAtIHN0YXJ0TWludXRlcyk7XHJcbiAgICAgIHJldHVybiB7IGV2LCBzdGFydE1pbnV0ZXMsIGVuZE1pbnV0ZXMsIGR1cmF0aW9uIH07XHJcbiAgICB9KS5zb3J0KChhLGIpID0+IGEuc3RhcnRNaW51dGVzIC0gYi5zdGFydE1pbnV0ZXMgfHwgYi5lbmRNaW51dGVzIC0gYS5lbmRNaW51dGVzKTtcclxuXHJcbiAgICAvLyBTaW1wbGUgY29sdW1uIHBhY2tpbmcgbGlrZSBNaW5hOiBwbGFjZSBlYWNoIGV2ZW50IGluIHRoZSBmaXJzdCBjb2x1bW4gdGhhdCBkb2Vzbid0IG92ZXJsYXBcclxuICAgIGNvbnN0IGNvbHVtbnM6IEFycmF5PEFycmF5PGFueT4+ID0gW107XHJcbiAgICBjb25zdCBjb2x1bW5zSW5kZXhNYXA6IG51bWJlcltdID0gW107XHJcbiAgICBpdGVtcy5mb3JFYWNoKChpdCwgaWR4KSA9PiB7XHJcbiAgICAgIGxldCBwbGFjZWQgPSBmYWxzZTtcclxuICAgICAgZm9yIChsZXQgY2kgPSAwOyBjaSA8IGNvbHVtbnMubGVuZ3RoOyBjaSsrKSB7XHJcbiAgICAgICAgY29uc3QgY29sID0gY29sdW1uc1tjaV07XHJcbiAgICAgICAgY29uc3QgbGFzdCA9IGNvbFtjb2wubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgaWYgKGl0LnN0YXJ0TWludXRlcyA+PSBsYXN0LmVuZE1pbnV0ZXMpIHtcclxuICAgICAgICAgIGNvbC5wdXNoKGl0KTtcclxuICAgICAgICAgIGNvbHVtbnNJbmRleE1hcFtpZHhdID0gY2k7XHJcbiAgICAgICAgICBwbGFjZWQgPSB0cnVlO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmICghcGxhY2VkKSB7XHJcbiAgICAgICAgY29sdW1uc0luZGV4TWFwW2lkeF0gPSBjb2x1bW5zLmxlbmd0aDtcclxuICAgICAgICBjb2x1bW5zLnB1c2goW2l0XSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHRvdGFsQ29scyA9IE1hdGgubWF4KDEsIGNvbHVtbnMubGVuZ3RoKTtcclxuXHJcbiAgICAvLyBGaW5kIGN1cnJlbnQgZXZlbnQgaXRlbVxyXG4gICAgY29uc3QgdGhpc1N0YXJ0ID0gZW5zdXJlRGF0ZShldmVudC5zdGFydERhdGUpO1xyXG4gICAgY29uc3QgdGhpc0VuZCA9IGVuc3VyZURhdGUoZXZlbnQuZW5kRGF0ZSk7XHJcbiAgICBjb25zdCB0aGlzU3RhcnRNaW4gPSB0aGlzU3RhcnQuZ2V0SG91cnMoKSAqIDYwICsgdGhpc1N0YXJ0LmdldE1pbnV0ZXMoKTtcclxuICAgIGNvbnN0IHRoaXNFbmRNaW4gPSB0aGlzRW5kLmdldEhvdXJzKCkgKiA2MCArIHRoaXNFbmQuZ2V0TWludXRlcygpO1xyXG4gICAgY29uc3QgdGhpc0R1cmF0aW9uID0gTWF0aC5tYXgoMSwgdGhpc0VuZE1pbiAtIHRoaXNTdGFydE1pbik7XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGNvbHVtbiBpbmRleCB0aGlzIGV2ZW50IG9jY3VwaWVzIChmYWxsYmFjayB0byAwKVxyXG4gICAgbGV0IGNvbEluZGV4ID0gMDtcclxuICAgIGZvciAobGV0IGNpID0gMDsgY2kgPCBjb2x1bW5zLmxlbmd0aDsgY2krKykge1xyXG4gICAgICBpZiAoY29sdW1uc1tjaV0uc29tZShpdCA9PiBpdC5ldi5pZCA9PT0gZXZlbnQuaWQpKSB7IGNvbEluZGV4ID0gY2k7IGJyZWFrOyB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgd2lkdGhQZXJjZW50ID0gMTAwIC8gdG90YWxDb2xzO1xyXG4gICAgY29uc3QgbGVmdFBlcmNlbnQgPSBjb2xJbmRleCAqIHdpZHRoUGVyY2VudDtcclxuXHJcbiAgICAvLyBDb21wdXRlIHBpeGVsc1xyXG4gICAgY29uc3QgdG9wUHggPSAodGhpc1N0YXJ0TWluIC8gNjApICogUk9XX1BYX1BFUl9IT1VSO1xyXG4gICAgY29uc3QgaGVpZ2h0UHggPSBNYXRoLm1heCgyMCwgKHRoaXNEdXJhdGlvbiAvIDYwKSAqIFJPV19QWF9QRVJfSE9VUik7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgaGVpZ2h0OiBgJHtoZWlnaHRQeH1weGAsXHJcbiAgICAgIHRvcDogYCR7dG9wUHh9cHhgLFxyXG4gICAgICB6SW5kZXg6IGNvbEluZGV4ICsgMSxcclxuICAgICAgbGVmdDogYCR7bGVmdFBlcmNlbnR9JWAsXHJcbiAgICAgIG1heFdpZHRoOiBgJHt3aWR0aFBlcmNlbnR9JWAsXHJcbiAgICAgIG1pbldpZHRoOiBgJHt3aWR0aFBlcmNlbnR9JWAsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlQWRkRXZlbnQoZXZlbnQ6IEV2ZW50KSB7XHJcbiAgICAvLyBJZiBhIHBhcmVudCBoYW5kbGVyIGlzIHByb3ZpZGVkLCBjYWxsIGl0IGFuZCBhd2FpdCBpdHMgcmVzdWx0LiBPbmx5XHJcbiAgICAvLyB1cGRhdGUgbG9jYWwgc3RhdGUgYWZ0ZXIgdGhlIHBhcmVudCByZXR1cm5zIGEgc2VydmVyLWNhbm9uaWNhbCBldmVudCBzb1xyXG4gICAgLy8gdGhlIHByb3ZpZGVyIGRvZXMgbm90IGtlZXAgb3B0aW1pc3RpYyAocG9zc2libHkgZGlmZmVyZW50KSB2YWx1ZXMgdGhhdFxyXG4gICAgLy8gZ2V0IG92ZXJ3cml0dGVuIG9uIHJlbG9hZC5cclxuICAgIGlmIChvbkFkZEV2ZW50KSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzOiBhbnkgPSBhd2FpdCBvbkFkZEV2ZW50KGV2ZW50KTtcclxuICAgICAgICAvLyBJZiBwYXJlbnQgcmV0dXJuZWQgdGhlIHNhdmVkIGNhbm9uaWNhbCBldmVudCwgdXNlIGl0IHRvIHVwZGF0ZSBsb2NhbCBzdGF0ZVxyXG4gICAgICAgIGlmIChyZXMgJiYgcmVzLmlkKSB7XHJcbiAgICAgICAgICB0cnkgeyBkaXNwYXRjaCh7IHR5cGU6IFwiQUREX0VWRU5UXCIsIHBheWxvYWQ6IHJlcyB9KTsgfSBjYXRjaCAoZSkge31cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcclxuICAgICAgICAgIC8vIElmIHRoZSBlcnJvciBpcyBhIGNsaWVudC1zaWRlICg0eHgpIHJlc3BvbnNlLCByZXRocm93IHNvIGNhbGxlcnMgY2FuIHNob3cgdmFsaWRhdGlvblxyXG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIChuZXR3b3JrIGVycm9yIG9yIDV4eCkgd2UgY2FuIGZhbGxiYWNrIHRvIGxvY2FsIG9wdGltaXN0aWMgYWRkIHRvIGtlZXAgVUkgcmVzcG9uc2l2ZVxyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gZSAmJiAoZS5zdGF0dXMgfHwgZS5zdGF0dXNDb2RlIHx8IChlLnJlc3BvbnNlICYmIGUucmVzcG9uc2Uuc3RhdHVzKSlcclxuICAgICAgICAgICAgaWYgKHN0YXR1cyAmJiBOdW1iZXIoc3RhdHVzKSA+PSA0MDAgJiYgTnVtYmVyKHN0YXR1cykgPCA1MDApIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tTY2hlZHVsZXJQcm92aWRlcl0gb25BZGRFdmVudCByZXR1cm5lZCBjbGllbnQgZXJyb3IsIGFib3J0aW5nIGxvY2FsIGZhbGxiYWNrJywgc3RhdHVzLCBlKVxyXG4gICAgICAgICAgICAgIHRocm93IGVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBjYXRjaCAoaW5uZXIpIHt9XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1tTY2hlZHVsZXJQcm92aWRlcl0gb25BZGRFdmVudCBoYW5kbGVyIGZhaWxlZCwgZmFsbGluZyBiYWNrIHRvIGxvY2FsIGFkZCcsIGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRpc3BhdGNoKHsgdHlwZTogXCJBRERfRVZFTlRcIiwgcGF5bG9hZDogZXZlbnQgfSk7XHJcbiAgICByZXR1cm4gZXZlbnQ7XHJcbiAgfVxyXG5cclxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVVcGRhdGVFdmVudChldmVudDogRXZlbnQsIGlkOiBzdHJpbmcpIHtcclxuICAgIC8vIFByZWZlciB0byBsZXQgdGhlIHBhcmVudCBwZXJzaXN0IHRoZSBjaGFuZ2UgYW5kIHJldHVybiB0aGUgY2Fub25pY2FsXHJcbiAgICAvLyBldmVudDsgb25seSB0aGVuIHVwZGF0ZSBsb2NhbCBzdGF0ZSB3aXRoIHRoZSBhdXRob3JpdGF0aXZlIHZhbHVlcy5cclxuICAgIGlmIChvblVwZGF0ZUV2ZW50KSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzOiBhbnkgPSBhd2FpdCBvblVwZGF0ZUV2ZW50KHsgLi4uZXZlbnQsIGlkIH0pO1xyXG4gICAgICAgIGlmIChyZXMgJiYgcmVzLmlkKSB7XHJcbiAgICAgICAgICB0cnkgeyBkaXNwYXRjaCh7IHR5cGU6IFwiVVBEQVRFX0VWRU5UXCIsIHBheWxvYWQ6IHJlcyB9KTsgfSBjYXRjaCAoZSkge31cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIC8vIElmIHBhcmVudCBoYW5kbGVyIGZhaWxzLCBmYWxsIGJhY2sgdG8gb3B0aW1pc3RpYyBsb2NhbCB1cGRhdGUgc28gVUkgc3RpbGwgcmVmbGVjdHMgY2hhbmdlXHJcbiAgICAgICAgY29uc29sZS53YXJuKCdbU2NoZWR1bGVyUHJvdmlkZXJdIG9uVXBkYXRlRXZlbnQgaGFuZGxlciBmYWlsZWQsIGFwcGx5aW5nIG9wdGltaXN0aWMgdXBkYXRlJywgZSk7XHJcbiAgICAgICAgdHJ5IHsgZGlzcGF0Y2goeyB0eXBlOiBcIlVQREFURV9FVkVOVFwiLCBwYXlsb2FkOiB7IC4uLmV2ZW50LCBpZCB9IH0pOyB9IGNhdGNoIChlcnIpIHt9XHJcbiAgICAgICAgLy8gcmV0aHJvdyBzbyBjYWxsZXJzIGNhbiBoYW5kbGUgZmFpbHVyZSBpZiBuZWVkZWRcclxuICAgICAgICB0aHJvdyBlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTm8gcGFyZW50IGhhbmRsZXI6IGRvIGEgbG9jYWwgb3B0aW1pc3RpYyB1cGRhdGVcclxuICAgIHRyeSB7XHJcbiAgICAgIGRpc3BhdGNoKHsgdHlwZTogXCJVUERBVEVfRVZFTlRcIiwgcGF5bG9hZDogeyAuLi5ldmVudCwgaWQgfSB9KTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgY29uc29sZS53YXJuKCdbU2NoZWR1bGVyUHJvdmlkZXJdIGxvY2FsIGRpc3BhdGNoIHVwZGF0ZSBmYWlsZWQnLCBlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IC4uLmV2ZW50LCBpZCB9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaGFuZGxlRGVsZXRlRXZlbnQoaWQ6IHN0cmluZykge1xyXG4gICAgaWYgKG9uRGVsZXRlRXZlbnQpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBtYXliZTogYW55ID0gb25EZWxldGVFdmVudChpZCk7XHJcbiAgICAgICAgcmV0dXJuIG1heWJlO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgLy8gZmFsbCBiYWNrIHRvIGxvY2FsIHJlbW92ZVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6IFwiUkVNT1ZFX0VWRU5UXCIsIHBheWxvYWQ6IHsgaWQgfSB9KTtcclxuICB9XHJcblxyXG4gIC8vIExvY2FsLW9ubHkgaGFuZGxlcnM6IGFsbG93IGNhbGxlcnMgdG8gdXBkYXRlIHByb3ZpZGVyIHN0YXRlIHdpdGhvdXQgZGVsZWdhdGluZ1xyXG4gIC8vIHBlcnNpc3RlbmNlIHRvIHBhcmVudCBwYWdlIGhhbmRsZXJzLiBVc2VmdWwgd2hlbiB0aGUgY2FsbGVyIHBlcmZvcm1zIHRoZVxyXG4gIC8vIG5ldHdvcmsgcmVxdWVzdCBpdHNlbGYgYW5kIG9ubHkgd2FudHMgdG8gdXBkYXRlIFVJIGFmdGVyIGNvbmZpcm1hdGlvbi5cclxuICBmdW5jdGlvbiBoYW5kbGVMb2NhbEFkZEV2ZW50KGV2ZW50OiBFdmVudCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBkZWJ1ZzogbG9nIHRoZSBpbmNvbWluZyBldmVudCBmb3IgdHJvdWJsZXNob290aW5nXHJcbiAgICAgICAgY29uc29sZS5kZWJ1ZygnW1NjaGVkdWxlclByb3ZpZGVyXSBoYW5kbGVMb2NhbEFkZEV2ZW50IGluY29taW5nOicsIGV2ZW50KTtcclxuICAgICAgfSBjYXRjaCAoZSkge31cclxuICAgICAgZGlzcGF0Y2goeyB0eXBlOiBcIkFERF9FVkVOVFwiLCBwYXlsb2FkOiBldmVudCB9KTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zb2xlLmRlYnVnKCdbU2NoZWR1bGVyUHJvdmlkZXJdIGV2ZW50cyBhZnRlciBhZGQgKGNvdW50KTonLCAoc3RhdGUgJiYgc3RhdGUuZXZlbnRzICYmIHN0YXRlLmV2ZW50cy5sZW5ndGgpID8gc3RhdGUuZXZlbnRzLmxlbmd0aCArIDEgOiAndW5rbm93bicpO1xyXG4gICAgICB9IGNhdGNoIChlKSB7fVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAvLyBzd2FsbG93IC0gVUkgYmVzdC1lZmZvcnRcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGhhbmRsZUxvY2FsVXBkYXRlRXZlbnQoZXZlbnQ6IEV2ZW50KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnNvbGUuZGVidWcoJ1tTY2hlZHVsZXJQcm92aWRlcl0gaGFuZGxlTG9jYWxVcGRhdGVFdmVudCBpbmNvbWluZzonLCBldmVudCk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XHJcbiAgICAgIGlmICghZXZlbnQgfHwgIWV2ZW50LmlkKSByZXR1cm47XHJcbiAgICAgIGRpc3BhdGNoKHsgdHlwZTogXCJVUERBVEVfRVZFTlRcIiwgcGF5bG9hZDogZXZlbnQgfSk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc29sZS5kZWJ1ZygnW1NjaGVkdWxlclByb3ZpZGVyXSBldmVudHMgYWZ0ZXIgdXBkYXRlIChjb3VudCk6JywgKHN0YXRlICYmIHN0YXRlLmV2ZW50cyAmJiBzdGF0ZS5ldmVudHMubGVuZ3RoKSA/IHN0YXRlLmV2ZW50cy5sZW5ndGggOiAndW5rbm93bicpO1xyXG4gICAgICB9IGNhdGNoIChlKSB7fVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAvLyBzd2FsbG93XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCBoYW5kbGVyczogSGFuZGxlcnMgPSB7XHJcbiAgICBoYW5kbGVFdmVudFN0eWxpbmcsXHJcbiAgICBoYW5kbGVBZGRFdmVudCxcclxuICAgIGhhbmRsZVVwZGF0ZUV2ZW50LFxyXG4gICAgaGFuZGxlRGVsZXRlRXZlbnQsXHJcbiAgICAvLyBsb2NhbC1vbmx5IGhlbHBlcnNcclxuICAgIGhhbmRsZUxvY2FsQWRkRXZlbnQsXHJcbiAgICBoYW5kbGVMb2NhbFVwZGF0ZUV2ZW50LFxyXG4gIH07XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8U2NoZWR1bGVyQ29udGV4dC5Qcm92aWRlclxyXG4gICAgICAvLyBpbmNsdWRlIHJlY3VycmVuY2VPcHRpb25zIGlmIHBhc3NlZCB2aWEgcHJvcHMgKGtlcHQgYmFja3dhcmQgY29tcGF0aWJsZSlcclxuICAgICAgdmFsdWU9e3sgZXZlbnRzOiBzdGF0ZSwgZGlzcGF0Y2gsIGdldHRlcnMsIGhhbmRsZXJzLCB3ZWVrU3RhcnRzT24gfX1cclxuICAgID5cclxuICAgICAgPE1vZGFsUHJvdmlkZXI+e2NoaWxkcmVufTwvTW9kYWxQcm92aWRlcj5cclxuICAgIDwvU2NoZWR1bGVyQ29udGV4dC5Qcm92aWRlcj5cclxuICApO1xyXG59O1xyXG5cclxuLy8gQ3VzdG9tIGhvb2sgdG8gdXNlIHRoZSBzY2hlZHVsZXIgY29udGV4dFxyXG5leHBvcnQgY29uc3QgdXNlU2NoZWR1bGVyID0gKCkgPT4ge1xyXG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KFNjaGVkdWxlckNvbnRleHQpO1xyXG4gIGlmICghY29udGV4dCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwidXNlU2NoZWR1bGVyIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBTY2hlZHVsZXJQcm92aWRlclwiKTtcclxuICB9XHJcbiAgcmV0dXJuIGNvbnRleHQ7XHJcbn07XHJcbiJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlUmVkdWNlciIsInVzZUVmZmVjdCIsIk1vZGFsUHJvdmlkZXIiLCJ2YXJpYW50cyIsImluaXRpYWxTdGF0ZSIsImV2ZW50cyIsInNjaGVkdWxlclJlZHVjZXIiLCJzdGF0ZSIsImFjdGlvbiIsInR5cGUiLCJwYXlsb2FkIiwiaWQiLCJzb21lIiwiZSIsImZpbHRlciIsImV2ZW50IiwibWFwIiwibGlzdCIsIkFycmF5IiwiaXNBcnJheSIsInNlZW4iLCJTZXQiLCJkZWR1cGVkIiwiZXYiLCJoYXMiLCJhZGQiLCJTY2hlZHVsZXJDb250ZXh0IiwidW5kZWZpbmVkIiwiU2NoZWR1bGVyUHJvdmlkZXIiLCJjaGlsZHJlbiIsIm9uQWRkRXZlbnQiLCJvblVwZGF0ZUV2ZW50Iiwib25EZWxldGVFdmVudCIsIndlZWtTdGFydHNPbiIsImRpc3BhdGNoIiwiZ2V0RGF5c0luTW9udGgiLCJtb250aCIsInllYXIiLCJmcm9tIiwibGVuZ3RoIiwiRGF0ZSIsImdldERhdGUiLCJfIiwiaW5kZXgiLCJkYXkiLCJnZXREYXlzSW5XZWVrIiwid2VlayIsInN0YXJ0RGF5IiwiamFuRmlyc3QiLCJqYW5GaXJzdERheU9mV2VlayIsImdldERheSIsIndlZWtTdGFydCIsInNldERhdGUiLCJkYXlzIiwiaSIsInB1c2giLCJnZXRXZWVrTnVtYmVyIiwiZGF0ZSIsImQiLCJVVEMiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwic2V0VVRDRGF0ZSIsImdldFVUQ0RhdGUiLCJnZXRVVENEYXkiLCJ5ZWFyU3RhcnQiLCJnZXRVVENGdWxsWWVhciIsIndlZWtObyIsIk1hdGgiLCJjZWlsIiwiZ2V0VGltZSIsImdldEV2ZW50c0ZvckRheSIsImN1cnJlbnREYXRlIiwiZXZlbnRTdGFydCIsInN0YXJ0RGF0ZSIsImV2ZW50RW5kIiwiZW5kRGF0ZSIsInN0YXJ0T2ZEYXkiLCJzZXRIb3VycyIsImVuZE9mRGF5IiwiaXNTYW1lRGF5IiwiaXNTcGFubmluZ0RheSIsImdldERheU5hbWUiLCJnZXR0ZXJzIiwiaGFuZGxlRXZlbnRTdHlsaW5nIiwiZGF5RXZlbnRzIiwicGVyaW9kT3B0aW9ucyIsInRvTWlsbGlzIiwiZW5zdXJlRGF0ZSIsIlJPV19QWF9QRVJfSE9VUiIsIml0ZW1zIiwicyIsInN0YXJ0TWludXRlcyIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImVuZE1pbnV0ZXMiLCJkdXJhdGlvbiIsIm1heCIsInNvcnQiLCJhIiwiYiIsImNvbHVtbnMiLCJjb2x1bW5zSW5kZXhNYXAiLCJmb3JFYWNoIiwiaXQiLCJpZHgiLCJwbGFjZWQiLCJjaSIsImNvbCIsImxhc3QiLCJ0b3RhbENvbHMiLCJ0aGlzU3RhcnQiLCJ0aGlzRW5kIiwidGhpc1N0YXJ0TWluIiwidGhpc0VuZE1pbiIsInRoaXNEdXJhdGlvbiIsImNvbEluZGV4Iiwid2lkdGhQZXJjZW50IiwibGVmdFBlcmNlbnQiLCJ0b3BQeCIsImhlaWdodFB4IiwiaGVpZ2h0IiwidG9wIiwiekluZGV4IiwibGVmdCIsIm1heFdpZHRoIiwibWluV2lkdGgiLCJoYW5kbGVBZGRFdmVudCIsInJlcyIsInN0YXR1cyIsInN0YXR1c0NvZGUiLCJyZXNwb25zZSIsIk51bWJlciIsImNvbnNvbGUiLCJ3YXJuIiwiaW5uZXIiLCJoYW5kbGVVcGRhdGVFdmVudCIsImVyciIsImhhbmRsZURlbGV0ZUV2ZW50IiwibWF5YmUiLCJoYW5kbGVMb2NhbEFkZEV2ZW50IiwiZGVidWciLCJoYW5kbGVMb2NhbFVwZGF0ZUV2ZW50IiwiaGFuZGxlcnMiLCJQcm92aWRlciIsInZhbHVlIiwidXNlU2NoZWR1bGVyIiwiY29udGV4dCIsIkVycm9yIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/providers/schedular-provider.tsx\n"));

/***/ })

});